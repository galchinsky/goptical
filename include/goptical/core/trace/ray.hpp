/*

      This file is part of the <goptical/core Core library.
  
      The <goptical/core library is free software; you can redistribute it
      and/or modify it under the terms of the GNU General Public
      License as published by the Free Software Foundation; either
      version 3 of the License, or (at your option) any later version.
  
      The <goptical/core library is distributed in the hope that it will be
      useful, but WITHOUT ANY WARRANTY; without even the implied
      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
      See the GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public
      License along with the <goptical/core library; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place, Suite 330,
      Boston, MA 02111-1307 USA
  
      Copyright (C) 2010-2011 Free Software Foundation, Inc
      Author: Alexandre Becoulet

*/


#ifndef GOPTICAL_TRACEDRAY_HH_
#define GOPTICAL_TRACEDRAY_HH_

#include "goptical/core/common.hpp"

#include "goptical/core/light/ray.hpp"
#include "goptical/core/math/vector.hpp"

namespace _goptical {

  namespace trace {

    /**
       @short Propagated light ray class
       @header <goptical/core/trace/Ray
       @module {Core}

       This class is used to describe a @ref light::Ray with all
       tracing and propagation informations attached.
     */
    class Ray : public light::Ray
    {
    public:

      /** Create a propagated light ray */
      inline Ray();

      /** Create a propagated light ray */
      inline Ray(const light::Ray &r);

      GOPTICAL_ACCESSORS(const sys::Element *, creator, "element which generated this ray.");

      GOPTICAL_ACCESSORS(const material::Base *, material, "material ray is propagated in.");

      GOPTICAL_ACCESSORS(double, intercept_intensity, "ray intensity at interception point.");

      GOPTICAL_ACCESSORS(double, len, "light ray length.");

      /** Define a new child generated ray */
      inline void add_generated(trace::Ray *r);

      /** Set light ray interception point and element */
      inline void set_intercept(const sys::Element &e, const math::Vector3 &point);
      /** Get light ray interception point */
      inline const math::Vector3 & get_intercept_point() const;
      /** Get light ray interception element */
      inline sys::Element & get_intercept_element() const;

      /** Get ray which generated this one */
      inline Ray * get_parent() const;
      /** Get first ray generated from this one */
      inline Ray * get_first_child() const;
      /** Get next sibling ray generated by same parent */
      inline Ray * get_next_child() const;

      /** Return true if ray is not intercepted */
      inline bool is_lost() const;

      /** Get global position */
      inline math::Vector3 get_position() const;
      /** Get global direction */
      inline math::Vector3 get_direction() const;

      /** Get position relative to given element */
      inline math::Vector3 get_position(const sys::Element &e) const;
      /** Get direction relative to given element */
      inline math::Vector3 get_direction(const sys::Element &e) const;

    private:
      Ray(const Ray &);
      const Ray & operator=(const Ray &r);

      math::Vector3             _point;         // ray intersection point (intersect surface local)
      double                    _intercept_intensity;   // intersection point intensity
      double                    _len;           // ray length
      const sys::Element        *_creator;      // element which generated this ray
      const material::Base  *_material;     // material
      sys::Element              *_i_element;    // intersect element
      Ray                       *_parent;       // ray which generated this one
      Ray                       *_child;        // pointer to generated ray
      Ray                       *_next;         // pointer to sibling generated ray
      bool                      _lost;          // does the ray intersect with an element ?
    };

  }

}

#endif

