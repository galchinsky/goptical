/*

      This file is part of the <goptical/core Core library.
  
      The <goptical/core library is free software; you can redistribute it
      and/or modify it under the terms of the GNU General Public
      License as published by the Free Software Foundation; either
      version 3 of the License, or (at your option) any later version.
  
      The <goptical/core library is distributed in the hope that it will be
      useful, but WITHOUT ANY WARRANTY; without even the implied
      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
      See the GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public
      License along with the <goptical/core library; if not, write to the
      Free Software Foundation, Inc., 59 Temple Place, Suite 330,
      Boston, MA 02111-1307 USA
  
      Copyright (C) 2010-2011 Free Software Foundation, Inc
      Author: Alexandre Becoulet

*/


#include <deque>

#include <goptical/core/trace/Tracer>
#include <goptical/core/trace/Result>
#include <goptical/core/trace/Ray>
#include <goptical/core/trace/Ray>
#include <goptical/core/sys/System>
#include <goptical/core/sys/Source>
#include <goptical/core/Error>
#include <goptical/core/sys/Surface>
#include <goptical/core/math/VectorPair>
#include <goptical/core/trace/Distribution>
#include <goptical/core/trace/Sequence>

namespace _goptical {

  namespace trace {

    tracer::tracer(const const_ref<sys::system> &system)
      : _system(system),
        _params(system->get_tracer_params()),
        _result(),
        _result_ptr(&_result)
    {
    }

    tracer::~tracer()
    {
    }

    template <IntensityMode m> void tracer::trace_seq_template()
    {
      Result &result = *_result_ptr;

      result.init(*_system);

      // stack of rays to propagate
      rays_queue_t tmp[2];

      unsigned int swaped = 0;
      rays_queue_t *generated;
      rays_queue_t *source_rays = &tmp[1];
      const std::vector<const_ref<sys::Element> > &seq = _params._sequence->_list;
      const sys::Element *entrance = 0;

      // find entry element (first non source)
      for (unsigned int i = 0; i < seq.size(); i++)
        {
          if (!dynamic_cast<const sys::Source *>(seq[i].ptr()))
            {
              entrance = seq[i].ptr();
              break;
            }
        }

      for (unsigned int i = 0; i < seq.size(); i++)
        {
          const sys::Element *element = seq[i].ptr();

          if (_system != element->get_system())
            throw Error("Sequence contains element which is not part of the system");

          if (!element->is_enabled())
            continue;

          Result::element_result_s &er = result.get_element_result(*element);

          generated = er._generated ? er._generated.get() : &tmp[swaped];
          result._generated_queue = generated;
          generated->clear();

          if (const sys::Source *source = dynamic_cast<const sys::Source *>(element))
            {
              result._sources.push_back(source);
              sys::Source::targets_t elist;
              if (entrance)
                elist.push_back(entrance);
              source->generate_rays<m>(result, elist);
            }
          else
            {
              element->process_rays<m>(result, source_rays);
              // swap ray buffers
            }

          GOPTICAL_DEBUG(" " << generated->size() << " rays generated by " << *element);
          source_rays = generated;
          swaped ^= 1;
        }

      

      result._generated_queue = 0;
    }

    template <IntensityMode m> void tracer::trace_template()
    {
      Result            &result = *_result_ptr;

      result.init(*_system);

      if (_params._propagation_mode != RayPropagation)
        throw Error("Diffractive propagation not supported in non sequential mode");

      // stack of rays to propagate

      rays_queue_t source_rays;

      sys::Source::targets_t entry;
      entry.push_back(&_system->get_entrance_pupil());

      // FIXME avoid container use here
      std::vector<const sys::Source *> slist;
      _system->get_elements<sys::Source>([&](const sys::Source& elem) { slist.push_back(&elem); });

      for (auto &s : slist)
        {
          const sys::Source &source = *s;

          if (_system != source.get_system())
            throw Error("can not trace with Source which is not part of the system");

          if (!source.is_enabled())
            continue;

          result._sources.push_back(&source);

          // get rays from source
          source_rays.clear();
          result._generated_queue = &source_rays;
          source.generate_rays<m>(result, entry);

          // copy to source generated rays
          {
            Result::element_result_s &source_er = result.get_element_result(source);

            if (source_er._generated)
              *source_er._generated = source_rays;
          }

          GOPTICAL_DEBUG("NSeq Ray trace: " << source_rays.size() << " Rays");

          // trace each ray generated by source through the system

          rays_queue_t gqueue;
          result._generated_queue = &gqueue;

          for (auto&r : source_rays)
            {
              Ray *ray = r;
              unsigned int bounce = _params._max_bounce;

              // trace relfected/refracted ray further
              while (1)
                {
                  // check bounce limit
                  if (!bounce--)
                    result._bounce_limit_count++;
                  else
                    {
                      math::VectorPair3 intersect; // intersection point and normal (intersect surface local)

                      // find ray / surface interction
                      if (sys::Surface *s = _system->colide_next(_params, intersect, *ray))
                        {
                          result.add_intercepted(*s, *ray);

                          // transform incident ray to surface local
                          const math::Transform<3> &t = ray->get_creator()->get_transform_to(*s);
                          math::VectorPair3 local(t.transform_line(*ray));

                          s->trace_ray<m>(result, *ray, local, intersect);
                        }
                    }

                  // pick next ray to trace further through the system
                  if (gqueue.empty())
                    break;
                  
                  ray = gqueue.front();
                  gqueue.pop_front();

                  result.add_generated(*ray->get_creator(), *ray);
                }
            }
        }

      result._generated_queue = 0;
    }

    void tracer::trace()
    {
      Result    &result = *_result_ptr;

      // clear previous results
      result.prepare();

      result._params = &_params;

      switch (_params._intensity_mode)
        {
        case Simpletrace:
          if (!_params._sequential_mode)
            trace_template<Simpletrace>();
          else
            trace_seq_template<Simpletrace>();
          break;

        case Intensitytrace:
          if (!_params._sequential_mode)
            trace_template<Intensitytrace>();
          else
            trace_seq_template<Intensitytrace>();
          break;

        case Polarizedtrace:
          if (!_params._sequential_mode)
            trace_template<Polarizedtrace>();       
          else
            trace_seq_template<Polarizedtrace>();
          break;
        }
    }

  }

}

