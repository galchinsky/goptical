\input texinfo  @c -*-texinfo-*-'.$cr.
@setfilename <goptical/core.info
@settitle GNU <goptical/core manual

@copying
This manual is for GNU <goptical/core.
Copyright @copyright{} 2010-2011 Free Software Foundation, Inc

@quotation
Copyright (C) 2010-2011 Free Software Foundation, Inc. Permission is
granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with no Invariant
Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the
license is included in the section entitled ``GNU Free Documentation
License''.
@end quotation
@end copying

@ifnottex
@dircategory Scientific software
@direntry
* <goptical/core:                   GNU Optical design and simulation library
@end direntry
@end ifnottex

@titlepage
@title GNU <goptical/core manual
@subtitle GNU Optical design and simulation library
@author Alexandre Becoulet
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@page

@ifnottex
@node Top,Introduction
@top Top
@end ifnottex

@page

@menu
* Introduction:: 
* Conventions:: 
* Tutorial:: 
* API documentation:: 
* GNU Free Documentation License:: 
@end menu

@node Introduction,Conventions,Top,Top
@chapter Introduction

 <goptical/core is a C++ optical design and simulation library. <goptical/core is free software and is part of the  @uref{http://www.gnu.org/,,GNU project} .

It provides model classes for optical components@comma{} surfaces and materials. It enables building optical systems by creating and placing various optical components in a 3d space and simulates light propagation through the system. Classical optical design analysis tools can be used on optical systems.

It takes advantages of the C++ object model to allow building complex optical systems with a few classes instanciations as optical components are represented by language objects.

@menu
* Features list:: 
@end menu

@node Features list,,,Introduction
@section Features list

@itemize
@item 
<goptical/core relies on an object oriented optical design approach. This allows designing optical component models and reuse them nested in other designs. Components are stored in herarchical form and live in a three-dimentional space with group (@pxref{sys_Group_class_reference}) local coordinates.

@item 
Support for sequential and non-sequential ray-tracing.

@item 
Available components include:

@itemize
@item 
Single optical surfaces (@pxref{sys_OpticalSurface_class_reference})

@item 
Lenses (@pxref{sys_Lens_class_reference})

@item 
mirrors (@pxref{sys_mirror_class_reference})@comma{}

@item 
Point sources (@pxref{sys_source_point_class_reference}) and

@item 
image (@pxref{sys_image_class_reference}) planes.

@end itemize

Surface curve and material used by optical components are described using dedicated models.

@item 
Several surface curvature models are available:

@itemize
@item 
Conic (@pxref{curve_Conic_class_reference}) curves.

@item 
Polynomial (@pxref{curve_Polynomial_class_reference}) curves.

@item 
rotationally symmetric (@pxref{curve_Spline_class_reference}) splines and Grid (@pxref{curve_Grid_class_reference}) splines.

@item 
Zernike polynomials (@pxref{curve_Zernike_class_reference}).

@item 
Foucault test (@pxref{curve_Foucault_class_reference}) curves.

@item 
Composition (@pxref{curve_Composer_class_reference}) of other curve models.

@item 
Array (@pxref{curve_Array_class_reference}) of other curve models.

@item 
User defined (@pxref{A custom surface curve model}) curve models.

@end itemize

Most curve models can be described using model specific parameters or by best fitting any curve object.

@item 
Several glass material models are available:

@itemize
@item 
Interpolated dispersion (@pxref{material_DispersionTable_class_reference}) glass model

@item 
Abbe number (@pxref{material_Abbe_class_reference}) and mil number (@pxref{material_Mil_class_reference}) model glass model.

@item 
Sellmeier (@pxref{material_Sellmeier_class_reference}) glass model.

@item 
Schott (@pxref{material_Schott_class_reference}) glass model.

@item 
Conrady (@pxref{material_Conrady_class_reference}) glass model.

@item 
Herzberger (@pxref{material_Herzberger_class_reference}) glass model.

@item 
A simple reflective surfaces mirror (@pxref{material_mirror_class_reference}) model.

@item 
A more accurate metal (@pxref{material_Metal_class_reference}) material model.

@item 
Air (@pxref{material_Air_class_reference}) and vaccum (@pxref{material_Vacuum_class_reference}) models.

@end itemize

@item 
Surfaces outline shapes are described by a set of model classes too:

@itemize
@item 
disk (@pxref{shape_disk_class_reference}) shapes model.

@item 
Ring (@pxref{shape_Ring_class_reference}) shapes model.

@item 
Ellipse (@pxref{shape_Ellipse_class_reference}) shapes model.

@item 
Rectangle (@pxref{shape_Rectangle_class_reference}) shapes model.

@item 
Regular polygon (@pxref{shape_RegularPolygon_class_reference}) and User defined polygon (@pxref{shape_Polygon_class_reference}) shapes models.

@end itemize

@item 
Optical system analysis tools include:

@itemize
@item 
Layout and rays rendering in 2d and 3d@comma{}

@item 
Best point of focus (@pxref{analysis_focus_class_reference}) finding.

@item 
Various ray fan (@pxref{analysis_RayFan_class_reference}) plots.

@item 
spot diagram (@pxref{analysis_spot_class_reference}) plots.

@end itemize

@item 
Several graphical output driver are available to render optical layouts and plots:

@itemize
@item 
output in Svg (@pxref{io_renderer_svg_class_reference}) vector format.

@item 
output in bitmap format using the Gd (@pxref{io_RendererGd_class_reference}) library.

@item 
output in Dxf (@pxref{io_RendererDxf_class_reference}) CAD format.

@item 
output in various formats via the PlPlot (@pxref{io_renderer_pl_plot_class_reference}) library.

@item 
X11 (@pxref{io_RendererX11_class_reference}) display on UNIX boxes.

@item 
3d display using the OpenGL (@pxref{io_RendererOpengl_class_reference}) library.

@item 
output in X3D (@pxref{io_RendererX3d_class_reference})@comma{} a standard 3d format.

@end itemize

@item 
Various optical design file formats can be read:

@itemize
@item 
Oslo glass catalog

@item 
Zemax glass catalog and optical designs

@end itemize

@end itemize

@page

@node Conventions,Tutorial,Introduction,Top
@chapter Conventions

@menu
* Coordinates system:: 
* Measurement units:: 
* Object references:: 
@end menu

@node Coordinates system,Measurement units,,Conventions
@section Coordinates system

 Each optical element in <goptical/core lives in its own coordinates system. It's usually located at @emph{(0@comma{} 0@comma{} 0)} with the @emph{Z} axis being the local optical axis.

@image{coordinates}

@node Measurement units,Object references,Coordinates system,Conventions
@section Measurement units

@itemize
@item 
Lengths are expressed using millimeter unit.

@item 
Wavelengths are expressed in nanometer unit in vacuum.

@item 
Absolute refractive indexes are used@comma{} with 1 being the refractive index of vacuum.

@end itemize

@node Object references,,Measurement units,Conventions
@section Object references

 C++ objects are used to model optical elements@comma{} materials@comma{} curvatures@comma{} shapes and other kinds of object <goptical/core deals with. As the optical system is being built@comma{} some objects keep references to other objects.

The  @uref{http://diaxen.ssji.net/dpp/ref_class_reference.html,,ref}  smart pointer class is used to manage objects in a convenient way. Objects can either be statically allocated or dynamically allocated. Both can then be passed to reference holder objects in the same way but only dynamically allocated objects will be automatically deleted when not used anymore:

@example
  using namespace goptical;

  sys::system     sys;

  // statically allocated object added to the system
  sys::SourceRays src1(math::vector3_0);
  sys.add(src1);

  // dynamically allocated object added to the system
  ref<sys::SourceRays> src2 = ref<sys::SourceRays>::create(math::vector3_0);
  sys.add(src2);
@end example

@page

@node Tutorial,API documentation,Conventions,Top
@chapter Tutorial

This section contains some commented example of applications and codes which use the <goptical/core library to model optical systems.

@page

@menu
* A simple refractor design:: 
* A photo lens design:: 
* system hierarchy and groups:: 
* A parameterizable segmented mirror model:: 
* A custom surface curve model:: 
@end menu

@node A simple refractor design,A photo lens design,,Tutorial
@section A simple refractor design

@image{refractor_layout,,,Refractor optical system 2d layout}

@menu
* Building the optical system:: 
* Performing light propagation:: 
* Rendering optical layout and rays:: 
* Performing a ray fan analysis:: 
@end menu

@node Building the optical system,Performing light propagation,,A simple refractor design
@subsection Building the optical system

Unlike much optical design software which relies on a list of surfaces to sequentially propagate light through the system@comma{} <goptical/core uses an object representation of the optical system in 3d space.

To model an optical system with <goptical/core@comma{} we just have to instantiate components and add them to the system.

For this refractor example we first need to deal with glass materials used in the design. Our achromatic refractor design needs two lenses of different glass materials. In this example we choose to model Bk7 and F3 glasses with the Sellmeier model:

@example
// code from examples/simple_refractor/refractor.cc:64

  material::Sellmeier bk7(1.03961212@comma{} 6.00069867e-3@comma{} 0.231792344@comma{}
                          2.00179144e-2@comma{} 1.01046945@comma{} 1.03560653e2);

  material::Sellmeier f3(8.23583145e-1@comma{} 6.41147253e-12@comma{} 7.11376975e-1@comma{}
                         3.07327658e-2@comma{} 3.12425113e-2@comma{} 4.02094988);

@end example

 The sys::OpticalSurface (@pxref{sys_OpticalSurface_class_reference}) class is used to model a single optical surface.

The two lenses have the same disk outline shape@comma{} so we declare the shape model once:

@example
  shape::disk   lens_shape(100); // lens diameter is 100mm

  // 1st lens@comma{} left surface
  curve::Sphere curve1(2009.753); // spherical curve with given radius of curvature
  curve::Sphere curve2(-976.245);

@end example

 Surface curves rely on dedicated models which are not dependent on optical component being used. Here we need two simple spherical curves for the first lens.

The first lens component can then be instantiated. We need to specify its 3d position@comma{} thickness@comma{} shape model@comma{} curve models and material models. material::none (@pxref{_528}) will later be replaced by system environment material.

@example
  sys::OpticalSurface s1(math::vector3(0@comma{} 0@comma{} 0)@comma{} // position@comma{}
                         curve1@comma{} lens_shape@comma{}     // curve & aperture shape
                         material::none@comma{} bk7);   // materials

  // 1st lens@comma{} right surface
  sys::OpticalSurface s2(math::vector3(0@comma{} 0@comma{} 31.336)@comma{}
                         curve2@comma{} lens_shape@comma{}
                         bk7@comma{} material::none);

@end example

 More convenient optical surface constructors are available for simple cases@comma{} with circular aperture and spherical curvature. They are used for the second lens:

@example
  // 2nd lens@comma{} left surface
  sys::OpticalSurface s3(math::vector3(0@comma{} 0@comma{} 37.765)@comma{} // position@comma{}
                         -985.291@comma{} 100@comma{}        // roc & circular aperture radius@comma{}
                         material::none@comma{} f3);  // materials

  // 2nd lens@comma{} right surface
  sys::OpticalSurface s4(math::vector3(0@comma{} 0@comma{} 37.765+25.109)@comma{}
                         -3636.839@comma{} 100@comma{}
                         f3@comma{} material::none);

@end example

 The sys::Lens (@pxref{sys_Lens_class_reference}) class is more convenient to use for most designs as it can handle a list of surfaces. In this example we choose to use the sys::OpticalSurface (@pxref{sys_OpticalSurface_class_reference}) class directly to show how things work. The convenient method is used in the next example (@pxref{A photo lens design}).

We then create a point light source at infinite distance with a direction vector aimed at entry surface (left of first lens):

@example
  // light source
  sys::source_point source(sys::SourceAtInfinity@comma{}
                          math::vector3(0@comma{} 0@comma{} 1));

@end example

 And we finally create an image plane near the expected focal point:

@example
  // image plane
  sys::image    image(math::vector3(0@comma{} 0@comma{} 3014.5)@comma{}  // position
                      60);                           // square size@comma{}

@end example

 All these components need to be added to an optical system:

@example
  sys::system   sys;

  // add components
  sys.add(source);
  sys.add(s1);
  sys.add(s2);
  sys.add(s3);
  sys.add(s4);
  sys.add(image);

@end example

 This simple optical design is ready for ray tracing and analysis.

@node Performing light propagation,Rendering optical layout and rays,Building the optical system,A simple refractor design
@subsection Performing light propagation

light propagation through the optical system is performed by the trace::tracer (@pxref{trace_tracer_class_reference}) class. There are several tracer parameters which can be tweaked before starting light propagation. Some default parameters can be set for an optical system instance; they will be used for each new tracer created for the system.

When light is propagated through the system@comma{} a tracer may be instructed to keep track of rays hitting or generated by some of the components for further analysis.

Some analysis classes (@pxref{analysis_namespace_reference}) are provided which embed a tracer configured for a particular analysis@comma{} but it's still possible to request a light propagation by directly instantiating a tracer object.

There are two major approaches to trace rays through an optical system:

@itemize
@item 
Sequential ray tracing: This requires an ordered list of surfaces to traverse. Rays are generated by the light source and propagated in the specified sequence order. Any light ray which doesn't reach the next surface in order is lost.

@item 
Non-sequential ray tracing: Rays are generated by the light source and each ray interacts with the first optical component found on its path. Rays are propagated this way across system components until they reach an image plane or get lost.

@end itemize

The default behavior in <goptical/core is to perform a non-sequential ray trace when no sequence is provided.

@subsubheading Non-sequential ray trace

 A non-sequential ray trace needs the specification of an entrance pupil so that rays from light sources can be targeted at optical system entry.

Performing light propagation only needs instantiation of a trace::tracer (@pxref{trace_tracer_class_reference}) object and invocation of its trace::tracer::trace (@pxref{_1425}) function. tracer parameters are inherited from system default tracer parameters:

@example
  sys.set_entrance_pupil(s1);
  trace::tracer tracer(sys);
  tracer.trace();

@end example

 When performing a non-sequential ray trace@comma{} only optical components based on sys::Surface (@pxref{sys_Surface_class_reference}) will interact with light.

All enabled light sources which are part of the system are considered.

@subsubheading Sequential ray trace

 Switching to a sequential ray trace is easy: The sequence is setup from components found in the system@comma{} in order along the Z axis.

@example
  trace::sequence seq(sys);

  sys.get_tracer_params().set_sequential_mode(seq);

@end example

 More complicated sequences must be created empty and described explicitly using the trace::sequence::add (@pxref{_1410}) function.

Optical system and sequence objects can be displayed using stl streams:

@example
  std::cout << "system:" << std::endl << sys;
  std::cout << "sequence:" << std::endl << seq;

@end example

 Ray tracing is then performed in the same way as for non-sequential ray traces:

@example
  trace::tracer tracer(sys);
  tracer.trace();

@end example

 When performing a sequential ray trace@comma{} all optical components can process incoming light rays.

A single light source must be present at the beginning of the sequence.

@node Rendering optical layout and rays,Performing a ray fan analysis,Performing light propagation,A simple refractor design
@subsection Rendering optical layout and rays

The result of ray tracing is stored in a trace::Result (@pxref{trace_Result_class_reference}) object which stores information about generated and intercepted rays and involved components for each ray. Not all rays' interactions are stored by default@comma{} and the result object must be first configured to specify which interactions should be stored for further analysis.

Here we want to draw all rays which are traced through the system. We first have to instruct our trace::Result (@pxref{trace_Result_class_reference}) object to remember which rays were generated by the source component in the system@comma{} so that it can used as a starting point for drawing subsequently scattered and reflected rays.

We use an io::Renderer (@pxref{io_Renderer_class_reference}) based object which is able to draw various things. We use it to draw system components as well as to recursively draw all rays generated by light sources.

Here is what we need to do in order:

@itemize
@item 
Instantiate a renderer object able to write graphics in some output format.

@item 
Fit renderer viewport to optical system.

@item 
Draw system components.

@item 
Optionally change the ray distribution on entrance pupil so that only meridional rays are traced.

@item 
Instruct the result object to keep track of rays generated by the source component.

@item 
Perform the ray tracing.

@item 
Draw traced rays.

@end itemize

@example
  io::renderer_svg renderer("layout.svg"@comma{} 1024@comma{} 100);

  // draw 2d system layout
  sys.draw_2d_fit(renderer);
  sys.draw_2d(renderer);

  trace::tracer tracer(sys);

  // trace and draw rays from source
  tracer.get_params().set_default_distribution(
    trace::distribution(trace::MeridionalDist@comma{} 5));
  tracer.get_trace_result().set_generated_save_state(source);
  tracer.trace();
  tracer.get_trace_result().draw_2d(renderer);

@end example

@node Performing a ray fan analysis,,Rendering optical layout and rays,A simple refractor design
@subsection Performing a ray fan analysis

The analysis (@pxref{analysis_namespace_reference}) namespace contains classes to perform some common analysis on optical systems. analysis classes may embed a trace::tracer (@pxref{trace_tracer_class_reference}) object if light propagation is needed to perform analysis.

Ray fan plots can be computed using the analysis::RayFan (@pxref{analysis_RayFan_class_reference}) class which is able to plot various ray measurements on both 2d plot axes.

The example below shows how to produce a transverse aberration plot by plotting entrance ray height against transverse distance:

@example
  io::renderer_svg     renderer("fan.svg"@comma{} 640@comma{} 480@comma{} io::rgb_white);

  analysis::RayFan    fan(sys);

  // select light source wavelens
  source.clear_spectrum();
  source.add_spectral_line(light::SpectralLine::C);
  source.add_spectral_line(light::SpectralLine::e);
  source.add_spectral_line(light::SpectralLine::F);

  // get transverse aberration plot
  ref<data::Plot> fan_plot = fan.get_plot(analysis::RayFan::EntranceHeight@comma{}
                                          analysis::RayFan::TransverseDistance);

  fan_plot->draw(renderer);

@end example

@image{refractor_fan}

@page

@node A photo lens design,system hierarchy and groups,A simple refractor design,Tutorial
@section A photo lens design

@image{tessar_layout,,,Tessar lens system 2d layout with chief and marginal rays}

@menu
* Using the Lens component:: 
* Adding multiple light sources:: 
* Plotting spot diagram:: 
* Plotting ray fans:: 
@end menu

@node Using the Lens component,Adding multiple light sources,,A photo lens design
@subsection Using the Lens component

The sys::Lens (@pxref{sys_Lens_class_reference}) class is a convenient way to model a list of optical surfaces. In this example we use it to model a Tessar photo lens by adding all optical surfaces to the lens object. Several functions are available to add surfaces to the lens; one of the simplest can create spherical surfaces with circular aperture for us. In this example@comma{} the glass material models used are created on the fly:

@example
// code from examples/tessar_lens/tessar.cc:70

  sys::Lens     lens(math::vector3(0@comma{} 0@comma{} 0));

  //               roc@comma{}            ap.radius@comma{} thickness@comma{}

  lens.add_surface(1/0.031186861@comma{}  14.934638@comma{} 4.627804137@comma{}
                   ref<material::AbbeVd>::create(1.607170@comma{} 59.5002));

  lens.add_surface(0@comma{}              14.934638@comma{} 5.417429465);

  lens.add_surface(1/-0.014065441@comma{} 12.766446@comma{} 3.728230979@comma{}
                   ref<material::AbbeVd>::create(1.575960@comma{} 41.2999));

  lens.add_surface(1/0.034678487@comma{}  11.918098@comma{} 4.417903733);

  lens.add_stop   (                12.066273@comma{} 2.288913925);

  lens.add_surface(0@comma{}              12.372318@comma{} 1.499288597@comma{}
                   ref<material::AbbeVd>::create(1.526480@comma{} 51.4000));

  lens.add_surface(1/0.035104369@comma{}  14.642815@comma{} 7.996205852@comma{}
                   ref<material::AbbeVd>::create(1.623770@comma{} 56.8998));

  lens.add_surface(1/-0.021187519@comma{} 14.642815@comma{} 85.243965130);

  sys.add(lens);

@end example

@node Adding multiple light sources,Plotting spot diagram,Using the Lens component,A photo lens design
@subsection Adding multiple light sources

The sys::source_point (@pxref{sys_source_point_class_reference}) class can be used to create a point light source suitable for analysis@comma{} but we sometimes want to trace custom rays. This can be achieved by using the sys::SourceRays (@pxref{sys_SourceRays_class_reference}) component class.

In this example we add both source types to our system but enable a single one at the same time. The sys::SourceRays (@pxref{sys_SourceRays_class_reference}) is used to draw a 2d layout with chief and marginal rays whereas the sys::source_point (@pxref{sys_source_point_class_reference}) source is used with multiple wavelengths for ray fan and spot diagram analysis:

@example
  sys::SourceRays  source_rays(math::vector3(0@comma{} 27.5@comma{} -1000));

  sys::source_point source_point(sys::SourceAtFiniteDistance@comma{}
                                math::vector3(0@comma{} 27.5@comma{} -1000));

  // add sources to system
  sys.add(source_rays);
  sys.add(source_point);

  // configure sources
  source_rays.add_chief_rays(sys);
  source_rays.add_marginal_rays(sys@comma{} 14);

  source_point.clear_spectrum();
  source_point.add_spectral_line(light::SpectralLine::C);
  source_point.add_spectral_line(light::SpectralLine::e);
  source_point.add_spectral_line(light::SpectralLine::F);

@end example

 The object is located at -1000 on the Z axis and has a height of 27.5.

@node Plotting spot diagram,Plotting ray fans,Adding multiple light sources,A photo lens design
@subsection Plotting spot diagram

The analysis::spot (@pxref{analysis_spot_class_reference}) class can be used to plot spot diagrams:

@example
    sys.enable_single<sys::Source>(source_point);

    sys.get_tracer_params().set_default_distribution(
      trace::distribution(trace::HexaPolarDist@comma{} 12));

    analysis::spot spot(sys);

      io::renderer_svg renderer("spot.svg"@comma{} 300@comma{} 300@comma{} io::rgb_black);

      spot.draw_diagram(renderer);

@end example

@image{tessar_spot,,,Tessar lens spot diagram}

@example
      io::renderer_svg renderer("spot_intensity.svg"@comma{} 640@comma{} 480);

      ref<data::Plot> plot = spot.get_encircled_intensity_plot(50);

      plot->draw(renderer);

@end example

@image{tessar_spot_intensity}

@node Plotting ray fans,,Plotting spot diagram,A photo lens design
@subsection Plotting ray fans

Various ray fan plots can be obtained by using the analysis::RayFan (@pxref{analysis_RayFan_class_reference}) class:

@example
    sys.enable_single<sys::Source>(source_point);

    analysis::RayFan fan(sys);

      io::renderer_svg renderer("opd_fan.svg"@comma{} 640@comma{} 480);

      ref<data::Plot> fan_plot = fan.get_plot(analysis::RayFan::EntranceHeight@comma{}
                                              analysis::RayFan::OpticalPathDiff);

      fan_plot->draw(renderer);


@end example

@image{tessar_opdfan}

@example
      io::renderer_svg renderer("transverse_fan.svg"@comma{} 640@comma{} 480);

      ref<data::Plot> fan_plot = fan.get_plot(analysis::RayFan::EntranceHeight@comma{}
                                              analysis::RayFan::TransverseDistance);

      fan_plot->draw(renderer);


@end example

@image{tessar_transverse}

@example
      io::renderer_svg renderer("longitudinal_fan.svg"@comma{} 640@comma{} 480);

      ref<data::Plot> fan_plot = fan.get_plot(analysis::RayFan::EntranceHeight@comma{}
                                              analysis::RayFan::LongitudinalDistance);

      fan_plot->draw(renderer);


@end example

@image{tessar_longitudinal}

@page

@node system hierarchy and groups,A parameterizable segmented mirror model,A photo lens design,Tutorial
@section system hierarchy and groups

<goptical/core allows arranging components of the optical system in a hierarchical manner. Optical component classes all inherit from the sys::Element (@pxref{sys_Element_class_reference}) class. Elements which inherit from the sys::Group (@pxref{sys_Group_class_reference}) class can contain nested elements.

Each element has a local coordinate system and stores a math::Transform (@pxref{math_Transform_3_class_reference})<3> object which describes its translation and rotation relative to the parent coordinate system.

@menu
* The Lens component:: 
* A newton telescope with corrector:: 
@end menu

@node The Lens component,A newton telescope with corrector,,system hierarchy and groups
@subsection The Lens component

The sys::Lens (@pxref{sys_Lens_class_reference}) optical component is a good example of group component. It is based on the sys::Group (@pxref{sys_Group_class_reference}) class so that it can embed sys::OpticalSurface (@pxref{sys_OpticalSurface_class_reference}) and sys::Stop (@pxref{sys_Stop_class_reference}) elements.

When displaying the system and ray trace sequence of the tessar lens design described in the previous section (@pxref{A photo lens design})@comma{} we notice that the system hierarchy has been flattened in the sequence:

@example
system:
   [1]<goptical/core::sys::Lens at [0@comma{} 0@comma{} 0]
   [10]<goptical/core::sys::image at [0@comma{} 0@comma{} 125.596]
   [11]<goptical/core::sys::SourceRays at [0@comma{} 27.5@comma{} -1000]
   [12]<goptical/core::sys::source_point at [0@comma{} 27.5@comma{} -1000]
sequence:
   [11]<goptical/core::sys::SourceRays at [0@comma{} 27.5@comma{} -1000]
   [12]<goptical/core::sys::source_point at [0@comma{} 27.5@comma{} -1000]
   [2]<goptical/core::sys::OpticalSurface at [0@comma{} 0@comma{} 0]
   [3]<goptical/core::sys::OpticalSurface at [0@comma{} 0@comma{} 4.6278]
   [4]<goptical/core::sys::OpticalSurface at [0@comma{} 0@comma{} 10.0452]
   [5]<goptical/core::sys::OpticalSurface at [0@comma{} 0@comma{} 13.7735]
   [6]<goptical/core::sys::Stop at [0@comma{} 0@comma{} 18.1914]
   [7]<goptical/core::sys::OpticalSurface at [0@comma{} 0@comma{} 20.4803]
   [8]<goptical/core::sys::OpticalSurface at [0@comma{} 0@comma{} 21.9796]
   [9]<goptical/core::sys::OpticalSurface at [0@comma{} 0@comma{} 29.9758]
   [10]<goptical/core::sys::image at [0@comma{} 0@comma{} 125.596]
@end example

Positions of optical surfaces are relative to the parent lens position.

@node A newton telescope with corrector,,The Lens component,system hierarchy and groups
@subsection A newton telescope with corrector

Object-oriented programming together with the hierarchical optical components organization in <goptical/core allows writing complex and dynamically parameterized optical component models composed of simple components.

@subsubheading Using the telescope model

Usage of the newton telescope model class (@pxref{Design_telescope_Newton_class_reference}) is presented here as an example of parameterized models which contain simple components. The following example shows how to build an optical design composed of a light source@comma{} the newton telescope model@comma{} a corrector lens assembly and an image plane.

The model constructor is called with the basic newton telescope parameters and the model internally computes other parameters of the telescope and instantiates internal optical components as needed.

@example
// code from examples/hierarchical_design/newton.cc:61

  sys::system             sys;

  // light source
  sys::source_point        source(sys::SourceAtInfinity@comma{} math::vector3_001);
  sys.add(source);

  // Newton telescope
  Design::telescope::Newton newton(math::vector3_0@comma{} // position
                                   1494.567 / 2.@comma{}   // focal len
                                   245.1);          // aperture diameter
  sys.add(newton);

@end example

 We can query the telescope model to get the 3d position of the focal plane within parent coordinates. This enables us to attach the image plane or next optical component at right location without much calculation.

@subsubheading Adding a corrector

We choose to attach a Wynne 4 lens corrector to the telescope. As usual we describe the corrector lens group using the sys::Lens (@pxref{sys_Lens_class_reference}) component:

@example

  // Wynne 4 lens corrector for parabolic mirrors
  sys::Lens               wynne(newton.get_focal_plane()@comma{}
                                -48.4585);        // z offset of first surface

                //  roc       ap.radius  thickness  material
  wynne.add_surface(21.496@comma{}   23.2 / 2.@comma{} 1.905@comma{}     bk7);
  wynne.add_surface(24.787@comma{}   22.5 / 2.@comma{} 1.574         );
  wynne.add_surface(55.890@comma{}   22.5 / 2.@comma{} 1.270@comma{}     bk7);
  wynne.add_surface(45.164@comma{}   21.8 / 2.@comma{} 18.504        );
  wynne.add_surface(29.410@comma{}   14.7 / 2.@comma{} 0.45@comma{}      bk7);
  wynne.add_surface(13.870@comma{}   14.1 / 2.@comma{} 16.086        );
  wynne.add_surface(23.617@comma{}   13.1 / 2.@comma{} 1.805@comma{}     bk7);
  wynne.add_surface(0@comma{}        12.8 / 2.@comma{} 9.003);

  sys.add(wynne);

  // image plane
  sys::image              image(wynne.get_exit_plane()@comma{} 15);
  sys.add(image);


@end example

 The first surface of the corrector is located relative to origin of the @samp{wynne} lens component with a Z offset of -48.4585 in the lens coordinate system but the whole lens is rotated and positioned at the telescope focal plane in the parent coordinate system.

Finally an image plane is created and positioned according to the corrector position and last surface thickness.

@subsubheading Querying model and rendering layouts

The model class may also provide access to some internal construction details:

@example
  std::cout << "unvignetted image diameter: "
            << newton.get_unvignetted_image_diameter() << std::endl;

  std::cout << "secondary minor axis size: "
            << newton.get_secondary_minor_axis() << std::endl;

  std::cout << "secondary offset: "
            << newton.get_secondary_offset() << std::endl;

  std::cout << "field angle: "
            << newton.get_field_angle() << std::endl;

@end example

 2d and 3d layouts of the whole system or groups can be rendered. The following code uses paging to render two such different views of the system:

@example
  io::renderer_svg       svg_renderer("layout.svg"@comma{} 640@comma{} 480);
  io::renderer_viewport  &renderer = svg_renderer;

  // horizontal page layout
  renderer.set_page_layout(1@comma{} 2);

  // 3d system layout on 1st sub-page
  renderer.set_page(0);
  renderer.set_perspective();

  sys.draw_3d_fit(renderer@comma{} 300);
  sys.draw_3d(renderer);

  tracer.get_trace_result().draw_3d(renderer);

  // 2d Wynne corrector layout on 2nd sub-page
  renderer.set_page(1);

  wynne.draw_2d_fit(renderer);
  wynne.draw_2d(renderer);

  tracer.get_trace_result().draw_2d(renderer@comma{} false@comma{} &wynne);

@end example

@image{newton_wynne4_layout,,,3d layout of the system and 2d layout closeup of the corrector}

@page

@node A parameterizable segmented mirror model,A custom surface curve model,system hierarchy and groups,Tutorial
@section A parameterizable segmented mirror model

This section shows how to take advantages of the hierarchical design (@pxref{system hierarchy and groups}) feature of <goptical/core to write your own parameterizable optical component models. The code of a segmented mirror component model is presented and this new component is used as the primary mirror in a Ritchey-Chretien telescope design.

@image{hexseg_mirror,,,3d layout of a Ritchey-Chretien telescope with segmented primary mirror (X3D output)}

@menu
* Writing the component model class:: 
* Using the model in Ritchey-Chretien design:: 
@end menu

@node Writing the component model class,Using the model in Ritchey-Chretien design,,A parameterizable segmented mirror model
@subsection Writing the component model class

The segmented mirror model uses hexagonal segments and takes a surface curve model@comma{} an aperture shape model@comma{} segment size and segment separation as parameters. We start the definition of our model class which inherits from the sys::Group (@pxref{sys_Group_class_reference}) class:

@example
// code from examples/segmented_mirror/segmented.cc:62

class HexSegmirror : public sys::Group
@{
public:

  HexSegmirror(const math::vectorPair3 &pos@comma{}
               const const_ref<curve::Base> &curve@comma{}
               const const_ref<shape::Base> &shape@comma{}
               double seg_radius@comma{} double separation)
    : sys::Group(pos)
  @{

@end example

 When the model is instantiated@comma{} all hexagonal mirrors need to be created from the constructor. We use two loops in order to build the hexagonal mirror tessellation:

@example
    if (seg_radius > separation)
      throw(Error("overlapping segments"));

    // sqrt(3)/2
    static const double sqrt_3_2 = 0.86602540378443864676;

    // hexagonal tessellation
    int x_count = ceil(shape->max_radius() / (separation * 1.5));
    int y_count = ceil(shape->max_radius() / (separation * 2 * sqrt_3_2));

    for (int x = -x_count; x <= x_count ; x++)
      @{
        for (int y = -y_count; y <= y_count ; y++)
          @{
            // find segment mirror 2d position
            double yoffset = x % 2 ? separation * sqrt_3_2 : 0;
            math::vector2 p(x * separation * 1.5@comma{}
                              yoffset + y * separation * 2 * sqrt_3_2 );

@end example

 The aperture shape is then used to check if a segment mirror must exist at each location:

@example
            // skip if segment center is outside main shape
            if (!shape->inside(p))
              continue;

@end example

 The segment mirror curve must take into account the offset from the main mirror origin. We also decide to subtract the sagitta offset from the segment curve and add it to its Z component position instead; this allows its origin to lie on the segment surface@comma{} which may be more convenient when tilting the segment. The curve::Composer (@pxref{curve_Composer_class_reference}) class is used here to apply required transformations to the model curve passed as a parameter:

@example
            // find curve z offset at segment center to shift both
            // curve and segment in opposite directions.
            double z_offset = curve->sagitta(p);

            // create a composer curve for this segment and use it to translate main curve
            ref<curve::Composer> seg_curve = ref<curve::Composer>::create();

            seg_curve->add_curve(curve).xy_translate(-p).z_offset(-z_offset);

@end example

 The segment mirror is then created and added to the model group:

@example
            // create a segment mirror with hexagonal shape and translated curve
            ref<sys::mirror> seg = ref<sys::mirror>::create(math::vector3(p@comma{} z_offset)@comma{} seg_curve@comma{}
                                             ref<shape::RegularPolygon>::create(seg_radius@comma{} 6));

            // attach the new segment to our group component
            add(seg);

@end example

 We finally add some code to keep track of the segments so that they can be accessed (and modified) separately after model instantiation:

@example
            // keep a pointer to this new segment
            _segments.push_back(seg.ptr());
          @}
      @}
  @}

  size_t get_segments_count() const
  @{
    return _segments.size();
  @}

  sys::mirror & get_segment(size_t i) const
  @{
    return *_segments.at(i);
  @}

private:
  std::vector<sys::mirror *> _segments;
@};

@end example

 This model class is less than 70 lines long@comma{} including comments.

@node Using the model in Ritchey-Chretien design,,Writing the component model class,A parameterizable segmented mirror model
@subsection Using the model in Ritchey-Chretien design

Our new model can now be used like other component models in optical systems and groups. We use it here with a ring aperture shape and conic curvature to model the primary mirror of a Ritchey-Chretien telescope:

@example
  sys::system             sys;

  // Ring shaped segmented mirror with conic curve
  HexSegmirror            primary(math::vector3(0@comma{} 0@comma{} 800)@comma{}
                                  ref<curve::Conic>::create(-1600@comma{} -1.0869)@comma{}
                                  ref<shape::Ring>::create(300@comma{} 85)@comma{}
                                  28@comma{} 30);
  sys.add(primary);

  sys::mirror             secondary(math::vectorPair3(0@comma{} 0@comma{} 225@comma{} 0@comma{} 0@comma{} -1)@comma{} 675@comma{} -5.0434@comma{} 100);
  sys.add(secondary);

  sys::image              image(math::vectorPair3(0@comma{} 0@comma{} 900)@comma{} 15);
  sys.add(image);

  sys::Stop               stop(math::vector3_0@comma{} 300);
  sys.add(stop);
  sys.set_entrance_pupil(stop);

  sys::source_point        source(sys::SourceAtInfinity@comma{} math::vector3_001);
  sys.add(source);

@end example

@page

@node A custom surface curve model,,A parameterizable segmented mirror model,Tutorial
@section A custom surface curve model

Common curve models are available in the curve (@pxref{curve_namespace_reference}) namespace but extending this set with user-defined models is easy@comma{} as explained in this tutorial.

@menu
* Writing the curve model class:: 
* Using the new model in optical design:: 
@end menu

@node Writing the curve model class,Using the new model in optical design,,A custom surface curve model
@subsection Writing the curve model class

In this example@comma{} we chose to model a rotationally symmetric  @uref{http://en.wikipedia.org/wiki/Catenary,,catenary}  curve. This curve has the following sagitta formula:

 @math{z = a \, \cosh \left ({r \over a} \right ) - a} 

Our curve model needs to provide several functions in order to be useful to the raytracer. Fortunately there are base classes which provide default implementations for most curve model functions. This include differentiation functions and ray intersection functions.

The curve::rotational (@pxref{curve_rotational_class_reference}) class allows modeling rotationally symmetric curves by only dealing with 2d formulas. Our model class just has to inherit from this class and provide an implementation for the @samp{sagitta} function:

@example
// code from examples/curve_model/usercurve.cc:56

class MyCatenarycurve : public curve::rotational
@{
public:
  MyCatenarycurve(double a)
    : _a(a)
  @{
  @}

private:
  double sagitta(double r) const
  @{
    return _a * cosh(r / _a) - _a;
  @}

  double _a;
@};

@end example

 The model can be improved by specifying the derivative function. This make calculations more efficient by avoiding use of the default numerical differentiation implementation:

@example
  double derivative(double r) const
  @{
    return sinh(r / _a);
  @}

@end example

 Although more functions from curve::Base (@pxref{curve_Base_class_reference}) and curve::rotational (@pxref{curve_rotational_class_reference}) can be reimplemented to further improve model efficiency@comma{} this curve model can readily be used in an optical design.

@node Using the new model in optical design,,Writing the curve model class,A custom surface curve model
@subsection Using the new model in optical design

To check our model@comma{} we then use it in a simple optical system composed of a point source@comma{} a mirror and an image plane. The catenary mirror resemble a parabolic mirror as used in a newton telescope.

@example
  sys::system             sys;

  // light source
  sys::source_point        source(sys::SourceAtInfinity@comma{} math::vector3_001);
  sys.add(source);

  // mirror
  shape::disk             shape(200);
  MyCatenarycurve         curve(-3000);
  sys::mirror             primary(math::vector3(0@comma{} 0@comma{} 1500)@comma{} curve@comma{} shape);

  sys.add(primary);

  // image plane
  sys::image              image(math::vector3_0@comma{} 15);
  sys.add(image);

@end example

 The best point of focus is slightly offset from the parabola focal length. We use the analysis::focus (@pxref{analysis_focus_class_reference}) class to find the best point of focus and move the image plane at this location:

@example
    analysis::focus               focus(sys);

    image.set_plane(focus.get_best_focus());

@end example

 Finally we plot some spot diagrams using the analysis::spot (@pxref{analysis_spot_class_reference}) class. The point light source is rotated for each diagram:

@example
    io::renderer_svg            renderer("spot.svg"@comma{}        200 * 3@comma{} 200 * 2@comma{} io::rgb_black);

    renderer.set_margin_ratio(.35@comma{} .25@comma{} .1@comma{} .1);
    renderer.set_page_layout(3@comma{} 2);

    for (int i = 0; i < 6; i++)
      @{
        analysis::spot spot(sys);

        renderer.set_page(i);
        spot.draw_diagram(renderer);

        source.rotate(0@comma{} .1@comma{} 0);
      @}

@end example

@image{catenary_spot,,,spot diagrams with image at best point of focus for the catenary curve}

@page

@node API documentation,GNU Free Documentation License,Tutorial,Top
@chapter API documentation

@menu
* Modules:: 
* Namespaces list:: 
* Classes list:: 
* Main classes:: 
@end menu

@node Modules,Namespaces list,,API documentation
@section Modules

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item Core @tab <goptical/core core classes
@item Design @tab Parametrizable optical designs classes
@end multitable

@node Namespaces list,Classes list,Modules,API documentation
@section Namespaces list

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item analysis @tab Optical systems analysis tools
@item curve @tab Surface curvature models
@item data @tab Numerical data interpolation and plotting
@item Design @tab Design module classes
@item io @tab data input/output and graphical rendering
@item light @tab Physical properties of light
@item material @tab material models for optical components
@item math @tab mathematical tools and functions
@item shape @tab 2d shapes used for surface contours
@item sys @tab Optical system and components
@item trace @tab Ray tracer and light propagation
@end multitable

@node Classes list,Main classes,Namespaces list,API documentation
@section Classes list

@multitable @columnfractions 0.371794871794872 0.628205128205128
@headitem Name @tab Description
@item analysis::focus @tab Best focus point analysis
@item analysis::RayFan @tab RayFan diagram analysis
@item analysis::spot @tab spot diagram analysis
@item curve::Array @tab Enable definition of curve as square and hexagonal array of an other curve
@item curve::Base @tab Base class for surface curvature models
@item curve::Composer @tab Enable definition of curve as composition of other curves
@item curve::Composer::Attributes @tab curve::Composer base curve attributes.
@item curve::Conic @tab General purpose conic curve model
@item curve::Flat @tab Flat curve
@item curve::Foucault @tab Define surface curve from Foucault test data.
@item curve::Grid @tab Define surface curve from interpolated grid data set.
@item curve::Parabola @tab Parabola curve model
@item curve::Polynomial @tab Even and odd polynomial curve implementation.
@item curve::Sphere @tab Spherical curve model
@item curve::Spline @tab rotationally symmetric spline curve implementation
@item curve::Zernike @tab Define surface curve from Zernike polynomials
@item curve::ConicBase @tab Base class for conic family of curves
@item curve::curveRoc @tab Base class for curves with a radius of curvature
@item curve::rotational @tab Base class for rotationally symmetric curves.
@item data::DiscreteSet @tab 1d numerical data set with interpolation
@item data::Grid @tab 2d numerical data set with interpolation.
@item data::Plot @tab data plots container
@item data::Plotdata @tab data set plot
@item data::SampleSet @tab 1d fixed interval numerical data set with interpolation
@item data::Set @tab Base class for numerical data sets.
@item data::Set1d @tab Base class for 1d y = f(x) numerical data set
@item Design::telescope::Cassegrain @tab Cassegrain telescopes model
@item Design::telescope::Newton @tab Newton telescope optical design
@item Design::telescope::telescope @tab Base class for telescope optical designs
@item Error @tab Base class used for <goptical/core exceptions.
@item io::ImportOslo @tab Oslo files loader
@item io::ImportZemax @tab Zemax files loader (experimental)
@item io::Renderer @tab Base class for rendering drivers
@item io::RendererDxf @tab DXF rendering driver base (experimental)
@item io::RendererGd @tab GD rendering driver
@item io::RendererOpengl @tab OpenGL rendering driver
@item io::renderer_pl_plot @tab Plplot rendering driver
@item io::renderer_svg @tab SVG file rendering driver
@item io::RendererX11 @tab X11 rendering driver
@item io::RendererX3d @tab X3d rendering driver (experimental)
@item io::Export @tab File export class interface
@item io::Import @tab File import class interface
@item io::RendererAxes @tab RendererAxes rendering descriptor
@item io::renderer_viewport @tab Base class for viewport based rendering drivers
@item io::rgb @tab RGB color descriptor
@item light::Ray @tab Describe a ray of light
@item light::SpectralLine @tab Describe a spectral line
@item material::Abbe @tab Abbe model for optical glass material
@item material::Air @tab Air optical material model
@item material::Base @tab Optical material base class.
@item material::Catalog @tab Hold a glass material catalog
@item material::Conrady @tab Conrady model for optical glass material
@item material::DispersionTable @tab Interpolated refractive index data set model
@item material::Herzberger @tab Herzberger model for optical glass material
@item material::Metal @tab Metal optical material model.
@item material::Mil @tab Mil glass code material model
@item material::mirror @tab Simple mirror optical material model.
@item material::Schott @tab Schott model for optical glass material
@item material::Sellmeier @tab Sellmeier model for optical glass material
@item material::SellmeierMod @tab Modified sellmeier model for optical glass material
@item material::Vacuum @tab Vacuum optical material model
@item material::Dielectric @tab Dielectric optical material model base class.
@item material::Proxy @tab Optical material proxy class.
@item material::Solid @tab Solid optical material base class.
@item math::Matrix @tab NxN square matrix class.
@item math::Quaternion @tab Quaternion class.
@item math::Transform<3> @tab 3d linear and affine transformation class.
@item math::Transform<2> @tab 2d linear and affine transformation class.
@item math::Triangle @tab N dimension triangle class
@item math::Triangle<3> @tab 3d triangle class
@item math::vector @tab N dimension vector class
@item math::vector<3@comma{} T> @tab 3d vector class
@item math::vector<2@comma{} T> @tab 2d vector class
@item math::vectorPair @tab vector pair class
@item math::vectorPair<2> @tab vector pair class
@item math::vectorPair<3> @tab vector pair class
@item shape::Base @tab Base class for contour 2d shapes
@item shape::Composer @tab Enable definition of shape as composition ot other shapes (experimental)
@item shape::Composer::Attributes @tab Enable definition of shape as composition ot other shapes (experimental)
@item shape::disk @tab disk shape
@item shape::Ellipse @tab Ellipse shape
@item shape::EllipticalRing @tab Elliptical ring shape
@item shape::Infinite @tab Borderless shape
@item shape::Polygon @tab Polygon shape
@item shape::Rectangle @tab Rectangle and square shape
@item shape::RegularPolygon @tab Regular Polygon shape
@item shape::Ring @tab Ring shape
@item sys::Group @tab Optical elements group element
@item sys::image @tab image plane optical element
@item sys::Lens @tab Lens optical element
@item sys::mirror @tab Reflecting optical surface element
@item sys::OpticalSurface @tab Optical surface element
@item sys::source_point @tab Point light source
@item sys::SourceRays @tab Custom rays light source
@item sys::system @tab Optical system
@item sys::Container @tab Base class for system and Group
@item sys::Element @tab Optical element base class
@item sys::Source @tab Base class for light sources
@item sys::Stop @tab Aperture stop element
@item sys::Surface @tab Base class for surfaces
@item trace::distribution @tab Ray distribution pattern descriptor
@item trace::params @tab light propagation parameters descriptor
@item trace::Result @tab Store light propagation result
@item trace::sequence @tab Defines light propagation elemets order for sequential light propagation
@item trace::tracer @tab light propagation algorithms
@item trace::Ray @tab Propagated light ray class
@end multitable

@page

@node Main classes,,Classes list,API documentation
@section Main classes

@subheading sys namespace

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item Group @tab Optical elements group element
@item image @tab image plane optical element
@item Lens @tab Lens optical element
@item mirror @tab Reflecting optical surface element
@item OpticalSurface @tab Optical surface element
@item source_point @tab Point light source
@item SourceRays @tab Custom rays light source
@item system @tab Optical system
@end multitable

@subheading trace namespace

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item distribution @tab Ray distribution pattern descriptor
@item params @tab light propagation parameters descriptor
@item Result @tab Store light propagation result
@item sequence @tab Defines light propagation elemets order for sequential light propagation
@item tracer @tab light propagation algorithms
@end multitable

@subheading material namespace

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item Abbe @tab Abbe model for optical glass material
@item Air @tab Air optical material model
@item Base @tab Optical material base class.
@item Catalog @tab Hold a glass material catalog
@item Conrady @tab Conrady model for optical glass material
@item DispersionTable @tab Interpolated refractive index data set model
@item Herzberger @tab Herzberger model for optical glass material
@item Metal @tab Metal optical material model.
@item Mil @tab Mil glass code material model
@item mirror @tab Simple mirror optical material model.
@item Schott @tab Schott model for optical glass material
@item Sellmeier @tab Sellmeier model for optical glass material
@item SellmeierMod @tab Modified sellmeier model for optical glass material
@item Vacuum @tab Vacuum optical material model
@end multitable

@subheading io namespace

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item ImportOslo @tab Oslo files loader
@item ImportZemax @tab Zemax files loader (experimental)
@item Renderer @tab Base class for rendering drivers
@item RendererDxf @tab DXF rendering driver base (experimental)
@item RendererGd @tab GD rendering driver
@item RendererOpengl @tab OpenGL rendering driver
@item renderer_pl_plot @tab Plplot rendering driver
@item renderer_svg @tab SVG file rendering driver
@item RendererX11 @tab X11 rendering driver
@item RendererX3d @tab X3d rendering driver (experimental)
@end multitable

@subheading data namespace

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item DiscreteSet @tab 1d numerical data set with interpolation
@item Grid @tab 2d numerical data set with interpolation.
@item Plot @tab data plots container
@item Plotdata @tab data set plot
@item SampleSet @tab 1d fixed interval numerical data set with interpolation
@end multitable

@subheading math namespace

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item vector2 @tab 
@item vector3 @tab 
@item vectorPair3 @tab 
@end multitable

@subheading shape namespace

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item Base @tab Base class for contour 2d shapes
@item Composer @tab Enable definition of shape as composition ot other shapes (experimental)
@item disk @tab disk shape
@item Ellipse @tab Ellipse shape
@item EllipticalRing @tab Elliptical ring shape
@item Infinite @tab Borderless shape
@item Polygon @tab Polygon shape
@item Rectangle @tab Rectangle and square shape
@item RegularPolygon @tab Regular Polygon shape
@item Ring @tab Ring shape
@end multitable

@subheading light namespace

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item Ray @tab Describe a ray of light
@end multitable

@subheading curve namespace

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item Array @tab Enable definition of curve as square and hexagonal array of an other curve
@item Base @tab Base class for surface curvature models
@item Composer @tab Enable definition of curve as composition of other curves
@item Conic @tab General purpose conic curve model
@item Flat @tab Flat curve
@item Foucault @tab Define surface curve from Foucault test data.
@item Grid @tab Define surface curve from interpolated grid data set.
@item Parabola @tab Parabola curve model
@item Polynomial @tab Even and odd polynomial curve implementation.
@item Sphere @tab Spherical curve model
@item Spline @tab rotationally symmetric spline curve implementation
@item Zernike @tab Define surface curve from Zernike polynomials
@end multitable

@subheading analysis namespace

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item focus @tab Best focus point analysis
@item RayFan @tab RayFan diagram analysis
@item spot @tab spot diagram analysis
@end multitable

@page

@heading ::Core module reference
@anchor{_Core_module_reference}

@subheading Description

 Classes from this module are located in the @samp{<goptical/core-core} subpackage (@samp{<goptical/core} library).

@subheading Members

@subsubheading Namespaces

@itemize
@item <goptical/core::analysis
@item <goptical/core::curve
@item <goptical/core::data
@item <goptical/core::io
@item <goptical/core::light
@item <goptical/core::material
@item <goptical/core::math
@item <goptical/core::shape
@item <goptical/core::sys
@item <goptical/core::trace
@end itemize

@subsubheading Types

@itemize
@item template class Abbe
@item template class Air
@item class Array
@item class Base
@item class Base
@item class Base
@item class Catalog
@item class Composer
@item class Composer
@item class Conic
@item class Conrady
@item class DiscreteSet
@item class disk
@item class DispersionTable
@item class distribution
@item class Ellipse
@item class EllipticalRing
@item class Flat
@item class focus
@item class Foucault
@item class Grid
@item class Grid
@item class Group
@item class Herzberger
@item class image
@item class ImportOslo
@item class ImportZemax
@item class Infinite
@item class Lens
@item class Metal
@item class Mil
@item class mirror
@item class mirror
@item class OpticalSurface
@item class Parabola
@item class params
@item class Plot
@item class Plotdata
@item class Polygon
@item class Polynomial
@item class Ray
@item class RayFan
@item class Rectangle
@item class RegularPolygon
@item class Renderer
@item class RendererDxf
@item class RendererGd
@item class RendererOpengl
@item class renderer_pl_plot
@item class renderer_svg
@item class RendererX11
@item class RendererX3d
@item class Result
@item class Ring
@item class SampleSet
@item class Schott
@item class Sellmeier
@item template class SellmeierMod
@item class sequence
@item class source_point
@item class SourceRays
@item class Sphere
@item class Spline
@item class spot
@item class system
@item class tracer
@item class Vacuum
@item typedef @emph{ [...] } vector2
@item typedef @emph{ [...] } vector3
@item typedef @emph{ [...] } vectorPair3
@item class Zernike
@item typedef @emph{ [...] } AbbeVd
@item typedef @emph{ [...] } AbbeVe
@item typedef @emph{ [...] } AirBirch94
@item typedef @emph{ [...] } AirKohlrausch68
@item class Attributes
@item class Attributes
@item class ConicBase
@item class Container
@item class curveRoc
@item class Dielectric
@item class Element
@item class Error
@item class Export
@item typedef @emph{ [...] } Handbook1
@item typedef @emph{ [...] } Handbook2
@item class Import
@item template struct Matrix
@item typedef @emph{ [...] } Matrix3x3
@item class Proxy
@item class Quaternion
@item class Ray
@item class RendererAxes
@item class renderer_viewport
@item struct rgb
@item class rotational
@item typedef @emph{ [...] } SellmeierMod2
@item class Set
@item class Set1d
@item class Solid
@item class Source
@item class SpectralLine
@item class Stop
@item class Surface
@item template class Transform<2>
@item template class Transform<3>
@item typedef @emph{ [...] } Transform2
@item typedef @emph{ [...] } Transform3
@item template struct Triangle
@item template struct Triangle<3>
@item template struct vector
@item template struct vector<2@comma{} T>
@item template struct vector<3@comma{} T>
@item template struct vectorPair
@item template struct vectorPair<2>
@item template struct vectorPair<3>
@item typedef @emph{ [...] } vectorPair2
@item typedef @emph{ [...] } range_t
@item typedef @emph{ [...] } rays_queue_t
@end itemize

@subsubheading Functions

@itemize
@item double degree2rad(double x)
@item void get_rotation_matrix(<goptical/core::math::Matrix<2> &m@comma{} unsigned int axis@comma{} double rangle)
@item void get_rotation_matrix(<goptical/core::math::Matrix<3> &m@comma{} unsigned int axis@comma{} double rangle)
@item double lp_floor(double x@comma{} double n)
@item double lp_mod(double x@comma{} double n)
@item template std::ostream & operator<<(std::ostream &o@comma{} const <goptical/core::math::vectorBase<N@comma{} T> &v)
@item template std::ostream & operator<<(std::ostream &o@comma{} const <goptical/core::math::vectorPairBase<N> &l)
@item template std::ostream & operator<<(std::ostream &o@comma{} const <goptical/core::math::Matrix<N> &m)
@item std::ostream & operator<<(std::ostream &o@comma{} const <goptical/core::math::Quaternion &q)
@item template std::ostream & operator<<(std::ostream &o@comma{} const <goptical/core::math::TransformBase<N> &t)
@item std::ostream & operator<<(std::ostream &o@comma{} const <goptical/core::sys::Element &e)
@item template std::ostream & operator<<(std::ostream &o@comma{} const <goptical/core::math::Triangle<N> &l)
@item std::ostream & operator<<(std::ostream &o@comma{} const <goptical/core::trace::sequence &s)
@item std::ostream & operator<<(std::ostream &o@comma{} const <goptical/core::sys::Container &v)
@item std::ostream & operator<<(std::ostream &o@comma{} const <goptical/core::data::Set &s)
@item double rad2degree(double x)
@item double square(double x)
@end itemize

@subsubheading Constants

@itemize
@item const dpp::const_ref<goptical/core::material::Base> none
@item const <goptical/core::io::rgb rgb_black
@item const <goptical/core::io::rgb rgb_blue
@item const <goptical/core::io::rgb rgb_cyan
@item const <goptical/core::io::rgb rgb_gray
@item const <goptical/core::io::rgb rgb_green
@item const <goptical/core::io::rgb rgb_magenta
@item const <goptical/core::io::rgb rgb_red
@item const <goptical/core::io::rgb rgb_table[]
@item const size_t rgb_table_size
@item const <goptical/core::io::rgb rgb_white
@item const <goptical/core::io::rgb rgb_yellow
@item const <goptical/core::material::AirBirch94 std_air
@item const <goptical/core::math::vector2 vector2_0
@item const <goptical/core::math::vector2 vector2_01
@item const <goptical/core::math::vector2 vector2_1
@item const <goptical/core::math::vector2 vector2_10
@item const <goptical/core::math::vectorPair<2> vector2_pair_00
@item const <goptical/core::math::vectorPair<2> vector2_pair_01
@item const <goptical/core::math::vector3 vector3_0
@item const <goptical/core::math::vector3 vector3_001
@item const <goptical/core::math::vector3 vector3_010
@item const <goptical/core::math::vector3 vector3_1
@item const <goptical/core::math::vector3 vector3_100
@item const <goptical/core::math::vectorPair<3> vector3_pair_00
@item const <goptical/core::math::vectorPair<3> vector3_pair_01
@end itemize

@subsubheading Variables

@itemize
@item <goptical/core::material::AirBirch94 air
@item <goptical/core::curve::Flat flat
@item <goptical/core::shape::Infinite infinite
@item <goptical/core::material::mirror mirror
@item <goptical/core::material::Vacuum vacuum
@end itemize

@page

@heading ::Design module reference
@anchor{_Design_module_reference}

@subheading Description

 This module contains various optical design models.

Classes from this module are located in the @samp{<goptical/core-design} subpackage (@samp{<goptical/core_design} library).

@subheading Members

@subsubheading Namespace

@itemize
@item <goptical/core::Design
@end itemize

@subsubheading Types

@itemize
@item template class Cassegrain
@item class Newton
@item class telescope
@end itemize

@page

@heading <goptical/core namespace reference
@anchor{<goptical/core_namespace_reference}

@subheading Description
<goptical/core library namespace
@subheading Members

@subsubheading Namespaces

@itemize
@item analysis
@item curve
@item data
@item Design
@item io
@item light
@item material
@item math
@item shape
@item sys
@item trace
@end itemize

@subsubheading Type

@itemize
@item class Error
@end itemize

@page

@heading analysis namespace reference
@anchor{analysis_namespace_reference}

@subheading Description
Optical systems analysis tools
@subheading Members

@subsubheading Types

@itemize
@item class focus
@item class RayFan
@item class spot
@end itemize

@page

@heading analysis::focus class reference
@anchor{analysis_focus_class_reference}

@subheading Declaration

@example
#include <goptical/core/analysis/focus>

namespace goptical @{
  namespace analysis @{
    class focus;
  @};
@};

@end example

 This class is a member of the analysis namespace.

@subheading Description

This class is designed to find the best point of focus of an optical system.

@subheading Members

 See also the full member list (@pxref{analysis_focus_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item focus(sys::system &system)
@item const math::vectorPair3 & get_best_focus()
@item trace::tracer & get_tracer()
@item const trace::tracer & get_tracer() const
@item virtual void invalidate()
@item void set_image(sys::image *image)
@end itemize

@subheading Members detail

@subsubheading focus(sys::system &system)
@anchor{_}

No documentation available

@subsubheading const math::vectorPair3 & get_best_focus()
@anchor{_1}

Get best point of focus in system global coordinates.

@subsubheading virtual void invalidate()
@anchor{_2}

This virtual function implements the @code{invalidate (@pxref{_31})} pure function declared in the @code{Pointimage} base abstract class.

Documentation inherited from base class:

invalidate current analysis data

@page

@heading analysis::focus class full member list
@anchor{analysis_focus_class_full_member_list}

@subheading Functions

@itemize
@item focus(sys::system &system)
@item const math::vectorPair3 & get_best_focus()
@item trace::tracer & get_tracer()
@item const trace::tracer & get_tracer() const
@item virtual void invalidate()
@item void set_image(sys::image *image)
@end itemize

@page

@heading analysis::RayFan class reference
@anchor{analysis_RayFan_class_reference}

@subheading Declaration

@example
#include <goptical/core/analysis/RayFan>

namespace goptical @{
  namespace analysis @{
    class RayFan;
  @};
@};

@end example

 This class is a member of the analysis namespace.

@subheading Description

This class is designed to compute various ray fan plots.

See also Performing a ray fan analysis (@pxref{Performing a ray fan analysis}) section and Plotting ray fans (@pxref{Plotting ray fans}) section.

@subheading Members

 See also the full member list (@pxref{analysis_RayFan_class_full_member_list}) section for this class.

@subsubheading Types

@itemize
@item enum rayfan_plane_e
@item enum rayfan_plot_type_e
@end itemize

@subsubheading Functions

@itemize
@item RayFan(const sys::system &system@comma{} rayfan_plane_e plane = @emph{[...]})
@item trace::distribution & get_distribution()
@item ref<data::Plot> get_plot(rayfan_plot_type_e x@comma{} rayfan_plot_type_e y)
@item void invalidate()
@item void set_aberration_plane(rayfan_plane_e plane)
@item void set_entrance_surface(const sys::Surface &s)
@item void set_longitudinal_reference(const math::vectorPair3 &ref)
@item void set_plane(rayfan_plane_e plane)
@item void set_target_surface(const sys::Surface &s)
@end itemize

@subheading Members detail

@subsubheading RayFan(const sys::system &system@comma{} rayfan_plane_e plane = TangentialAberration)
@anchor{_3}

No documentation available

@subsubheading trace::distribution & get_distribution()
@anchor{_4}

Get internal distribution object

@subsubheading  @uref{http://diaxen.ssji.net/dpp/ref_class_reference.html,,ref} <data::Plot> get_plot(rayfan_plot_type_e x@comma{} rayfan_plot_type_e y)
@anchor{_5}

Get aberration plot@comma{} requested x value is plotted against requested y value.

@subsubheading void invalidate()
@anchor{_6}

Invalidate current analysis data and raytrace again on next plot request

@subsubheading enum rayfan_plane_e
@anchor{_7}

Specify aberration analysis plane on target surface

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item SagittalAberration @tab 
@item TangentialAberration @tab 
@end multitable

@subsubheading enum rayfan_plot_type_e
@anchor{_8}

Specify ray aberration values to plot. Angle and Distance aberrations values are considered in selected aberration plane. Entrance Height and Angle are considered in selected distribution plane.

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item EntranceHeight @tab 
Normalized ray height (radial distance) on entrance pupil

@item EntranceAngle @tab 
Angle of ray on entrance pupil

@item TransverseDistance @tab 
Distance on the surface from the intercept of the chief ray

@item LongitudinalDistance @tab 
Distance along the chief ray from the surface to the measured ray.

@item imageAngle @tab 
Angle of ray striking the target surface

@item ExitAngle @tab 
Angle of ray leaving (generated by) the target surface

@item OpticalPathDiff @tab 
Optical path difference in waves

@end multitable

@subsubheading void set_aberration_plane(rayfan_plane_e plane)
@anchor{_9}

Aberrations are considered in the given plane on the target surface. Default is to use the same plane as entrance pupil ray distribution plane.

@subsubheading void set_entrance_surface(const sys::Surface &s)
@anchor{_10}

Specify entrance pupil surface to use for analysis@comma{} query system for entrance pupil if none defined here.

@subsubheading void set_longitudinal_reference(const math::vectorPair3 &ref)
@anchor{_11}

Set longitudinal reference ray (local to target surface). Longitudinal aberration computes distance between each rays and target surface plane along this reference vector. Default value is along the Z axis.

@subsubheading void set_plane(rayfan_plane_e plane)
@anchor{_12}

Set entrance pupil ray distribution plane.

@subsubheading void set_target_surface(const sys::Surface &s)
@anchor{_13}

Specify target surface (image or exit pupil) to use for analysis@comma{} query system for image surface if none defined here.

@page

@heading analysis::RayFan class full member list
@anchor{analysis_RayFan_class_full_member_list}

@subheading Types

@itemize
@item enum rayfan_plane_e
@item enum rayfan_plot_type_e
@end itemize

@subheading Functions

@itemize
@item RayFan(const sys::system &system@comma{} rayfan_plane_e plane = @emph{[...]})
@item trace::distribution & get_distribution()
@item ref<data::Plot> get_plot(rayfan_plot_type_e x@comma{} rayfan_plot_type_e y)
@item void invalidate()
@item void set_aberration_plane(rayfan_plane_e plane)
@item void set_entrance_surface(const sys::Surface &s)
@item void set_longitudinal_reference(const math::vectorPair3 &ref)
@item void set_plane(rayfan_plane_e plane)
@item void set_target_surface(const sys::Surface &s)
@end itemize

@page

@heading analysis::spot class reference
@anchor{analysis_spot_class_reference}

@subheading Declaration

@example
#include <goptical/core/analysis/spot>

namespace goptical @{
  namespace analysis @{
    class spot;
  @};
@};

@end example

 This class is a member of the analysis namespace.

@subheading Description

This class is designed to plot spot diagram and perform related analysis.

See also Plotting spot diagram (@pxref{Plotting spot diagram}) section and Using the new model in optical design (@pxref{Using the new model in optical design}) section.

@subheading Members

 See also the full member list (@pxref{analysis_spot_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item spot(sys::system &system)
@item void draw_diagram(io::renderer_viewport &renderer@comma{} bool centroid_origin = @emph{[...]})
@item void draw_spot(io::renderer_viewport &renderer)
@item math::vector3 get_center()
@item const math::vector3 & get_centroid()
@item io::RendererAxes & get_diagram_axes()
@item double get_encircled_intensity(double radius)
@item ref<data::Plot> get_encircled_intensity_plot(int zones = @emph{[...]})
@item double get_max_radius()
@item double get_rms_radius()
@item double get_total_intensity()
@item trace::tracer & get_tracer()
@item const trace::tracer & get_tracer() const
@item virtual void invalidate()
@item void set_image(sys::image *image)
@item void set_useful_radius(double radius)
@end itemize

@subheading Members detail

@subsubheading spot(sys::system &system)
@anchor{_14}

No documentation available

@subsubheading void draw_diagram(io::renderer_viewport &renderer@comma{} bool centroid_origin = true)
@anchor{_15}

draw the spot diagram

@subsubheading void draw_spot(io::renderer_viewport &renderer)
@anchor{_16}

draw the rays intersection points only

@subsubheading math::vector3 get_center()
@anchor{_17}

Get spot window center

@subsubheading const math::vector3 & get_centroid()
@anchor{_18}

Get spot centroid

@subsubheading io::RendererAxes & get_diagram_axes()
@anchor{_19}

Get a reference to axes object rendered with spot diagram. io::RendererAxes (@pxref{io_RendererAxes_class_reference}) coordinates are updated on ray trace.

@subsubheading double get_encircled_intensity(double radius)
@anchor{_20}

Get amount of light intensity which falls in given radius from spot center

@subsubheading  @uref{http://diaxen.ssji.net/dpp/ref_class_reference.html,,ref} <data::Plot> get_encircled_intensity_plot(int zones = 100)
@anchor{_21}

Get encircled energy plot

@subsubheading double get_max_radius()
@anchor{_22}

Get spot maximum radius

@subsubheading double get_rms_radius()
@anchor{_23}

Get spot root mean square radius

@subsubheading double get_total_intensity()
@anchor{_24}

Get amount of light intensity in the whole spot

@subsubheading virtual void invalidate()
@anchor{_25}

This virtual function implements the @code{invalidate (@pxref{_31})} pure function declared in the @code{Pointimage} base abstract class.

Documentation inherited from base class:

invalidate current analysis data

@subsubheading void set_useful_radius(double radius)
@anchor{_26}

Set radius used for diagram drawing and encircled plots. Updated with spot max radius on ray trace

@page

@heading analysis::spot class full member list
@anchor{analysis_spot_class_full_member_list}

@subheading Functions

@itemize
@item spot(sys::system &system)
@item void draw_diagram(io::renderer_viewport &renderer@comma{} bool centroid_origin = @emph{[...]})
@item void draw_spot(io::renderer_viewport &renderer)
@item math::vector3 get_center()
@item const math::vector3 & get_centroid()
@item io::RendererAxes & get_diagram_axes()
@item double get_encircled_intensity(double radius)
@item ref<data::Plot> get_encircled_intensity_plot(int zones = @emph{[...]})
@item double get_max_radius()
@item double get_rms_radius()
@item double get_total_intensity()
@item trace::tracer & get_tracer()
@item const trace::tracer & get_tracer() const
@item virtual void invalidate()
@item void set_image(sys::image *image)
@item void set_useful_radius(double radius)
@end itemize

@page

@heading analysis::Pointimage internal class members

@subheading Pointimage(sys::system &system)

No documentation available

@subheading virtual ~Pointimage()

No documentation available

@subheading trace::tracer & get_tracer()
@anchor{_29}

return tracer object used for ray tracing. This will invalidate current analysis data

@subheading const trace::tracer & get_tracer() const
@anchor{_30}

return tracer object used for ray tracing

@subheading virtual void invalidate() = 0;
@anchor{_31}

invalidate current analysis data

@subheading void set_image(sys::image *image)
@anchor{_32}

set image which collect rays for analysis

@page

@heading curve namespace reference
@anchor{curve_namespace_reference}

@subheading Description
Surface curvature models
@subheading Members

@subsubheading Types

@itemize
@item class Array
@item class Base
@item class Composer
@item class Conic
@item class Flat
@item class Foucault
@item class Grid
@item class Parabola
@item class Polynomial
@item class Sphere
@item class Spline
@item class Zernike
@item class ConicBase
@item class curveRoc
@item class rotational
@end itemize

@subsubheading Variable

@itemize
@item Flat flat
@end itemize

@subheading Members detail

@subsubheading Flat flat
@anchor{_33}

Preallocated flat curve object

@page

@heading curve::Array class reference
@anchor{curve_Array_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/Array>

namespace goptical @{
  namespace curve @{
    class Array;
  @};
@};

@end example

 This class is a member of the curve namespace.

@subheading Inheritance

@subheading Description

This class provides a way to build an array of an other curve. It can be used to design lenses array.

@subheading Members

 See also the full member list (@pxref{curve_Array_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 5 members inherited from Base (@pxref{curve_Base_class_reference})
@end itemize

@subsubheading Type

@itemize
@item enum pattern_e
@end itemize

@subsubheading Functions

@itemize
@item Array(const const_ref<Base> &curve@comma{} double pitch@comma{} pattern_e p = @emph{[...]})
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual double sagitta(const math::vector2 &xy) const
@end itemize

@subheading Members detail

@subsubheading Array(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <Base> &curve@comma{} double pitch@comma{} pattern_e p = Square)
@anchor{_34}

No documentation available

@subsubheading virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@anchor{_35}

This virtual function overrides the @code{derivative (@pxref{_39})} virtual function defined in the @code{Base (@pxref{curve_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve x and y derivative (gradient) at specified point

@subsubheading enum pattern_e
@anchor{_36}

Specify tessellation pattern used by Array (@pxref{curve_Array_class_reference}) class

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item Square @tab 
@item SquareCenter @tab 
@item Hexagonal @tab 
@end multitable

@subsubheading virtual double sagitta(const math::vector2 &xy) const
@anchor{_37}

This virtual function implements the @code{sagitta (@pxref{_42})} pure function declared in the @code{Base (@pxref{curve_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve sagitta at specified point

@page

@heading curve::Array class full member list
@anchor{curve_Array_class_full_member_list}

@subheading Type

@itemize
@item enum pattern_e
@end itemize

@subheading Functions

@itemize
@item Array(const const_ref<Base> &curve@comma{} double pitch@comma{} pattern_e p = @emph{[...]})
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(const math::vector2 &xy) const
@end itemize

@page

@heading curve::Base class reference
@anchor{curve_Base_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/Base>

namespace goptical @{
  namespace curve @{
    class Base;
  @};
@};

@end example

 This class is a member of the curve namespace.

This abstract class contains pure virtuals.

@subheading Inheritance

@subheading Description

This class defines an interface for surface curvature implementations. Curvature is defined as a surface curve in three dimensional space. It is mainly used by the sys::Surface (@pxref{sys_Surface_class_reference}) class to describe optical surface curvature.

It provides access to sagitta (z) and gradient data on any curved surface point (x@comma{} y). Ability to find point of intersection between a given 3d ray and the curve is also provided.

See also A custom surface curve model (@pxref{A custom surface curve model}) section.

@subheading Members

 See also the full member list (@pxref{curve_Base_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item virtual ~Base()
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(const math::vector2 &xy) const = 0;
@end itemize

@subheading Members detail

@subsubheading virtual ~Base()
@anchor{_38}

No documentation available

@subsubheading virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@anchor{_39}

Get curve x and y derivative (gradient) at specified point

@subsubheading virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@anchor{_40}

Get intersection point between curve and 3d ray. Return false if no intersection occurred

@subsubheading virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@anchor{_41}

Get normal to curve surface at specified point

@subsubheading virtual double sagitta(const math::vector2 &xy) const = 0;
@anchor{_42}

Get curve sagitta at specified point

@page

@heading curve::Base class full member list
@anchor{curve_Base_class_full_member_list}

@subheading Functions

@itemize
@item virtual ~Base()
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(const math::vector2 &xy) const = 0;
@end itemize

@page

@heading curve::Composer class reference
@anchor{curve_Composer_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/Composer>

namespace goptical @{
  namespace curve @{
    class Composer;
  @};
@};

@end example

 This class is a member of the curve namespace.

@subheading Inheritance

@subheading Description

This class allows definition of a surface curve using the sum of several base curves. Each base curve involved can be translated@comma{} rotated and scaled individually.

@subheading Members

 See also the full member list (@pxref{curve_Composer_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 5 members inherited from Base (@pxref{curve_Base_class_reference})
@end itemize

@subsubheading Type

@itemize
@item class Attributes
@end itemize

@subsubheading Functions

@itemize
@item Composer()
@item Attributes & add_curve(const const_ref<Base> &curve)
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual double sagitta(const math::vector2 &xy) const
@end itemize

@subheading Members detail

@subsubheading Composer()
@anchor{_43}

No documentation available

@subsubheading Attributes & add_curve(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <Base> &curve)
@anchor{_44}

Add a base curve to use for composition. The returned Composer::Attributes object may be used to apply base curve transformations.

@subsubheading virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@anchor{_45}

This virtual function overrides the @code{derivative (@pxref{_39})} virtual function defined in the @code{Base (@pxref{curve_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve x and y derivative (gradient) at specified point

@subsubheading virtual double sagitta(const math::vector2 &xy) const
@anchor{_46}

This virtual function implements the @code{sagitta (@pxref{_42})} pure function declared in the @code{Base (@pxref{curve_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve sagitta at specified point

@page

@heading curve::Composer class full member list
@anchor{curve_Composer_class_full_member_list}

@subheading Type

@itemize
@item class Attributes
@end itemize

@subheading Functions

@itemize
@item Composer()
@item Attributes & add_curve(const const_ref<Base> &curve)
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(const math::vector2 &xy) const
@end itemize

@page

@heading curve::Composer::Attributes class reference
@anchor{curve_Composer_Attributes_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/Composer>

namespace goptical @{
  namespace curve @{
    class Composer @{
      class Attributes;
    @};
  @};
@};

@end example

 This class is a member of the Composer class.

@subheading Description

This class enables access to Composer base curve transformations. Sagitta (z) scaling and (x@comma{} y) affine transforms (translation@comma{} rotation@comma{} scaling) can be applied as needed in any order.

@subheading Members

 See also the full member list (@pxref{curve_Composer_Attributes_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item Attributes & rotate(double dangle)
@item Attributes & xy_scale(const math::vector2 &factor)
@item Attributes & xy_translate(const math::vector2 &offset)
@item Attributes & z_offset(double zoffset)
@item Attributes & z_scale(double zfactor)
@end itemize

@subheading Members detail

@subsubheading Attributes & rotate(double dangle)
@anchor{_47}

Apply rotation affine transform. Angle is in degree.

@subsubheading Attributes & xy_scale(const math::vector2 &factor)
@anchor{_48}

Apply scaling affine transform using scale factors (xscale@comma{} yscale)

@subsubheading Attributes & xy_translate(const math::vector2 &offset)
@anchor{_49}

Apply translation transform

@subsubheading Attributes & z_offset(double zoffset)
@anchor{_50}

Apply sagitta (z) offset. default is 0

@subsubheading Attributes & z_scale(double zfactor)
@anchor{_51}

Apply sagitta (z) scale factor. default is 1

@page

@heading curve::Composer::Attributes class full member list
@anchor{curve_Composer_Attributes_class_full_member_list}

@subheading Functions

@itemize
@item Attributes & rotate(double dangle)
@item Attributes & xy_scale(const math::vector2 &factor)
@item Attributes & xy_translate(const math::vector2 &offset)
@item Attributes & z_offset(double zoffset)
@item Attributes & z_scale(double zfactor)
@end itemize

@page

@heading curve::Conic class reference
@anchor{curve_Conic_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/Conic>

namespace goptical @{
  namespace curve @{
    class Conic;
  @};
@};

@end example

 This class is a member of the curve namespace.

@subheading Inheritance

@subheading Description

This class models a rotationally symmetric conic curves with given radius of curvature and deformation coefficient. The later can be provided either as Schwarzschild constant or Eccentricity value.

Fitting can be used to find best fit conic of an other rotationally symmetric curve either with fixed or free deformation parameter.

Sphere (@pxref{curve_Sphere_class_reference}) and Parabola (@pxref{curve_Parabola_class_reference}) offer optimized implementations for common special cases.

@subheading Members

 See also the full member list (@pxref{curve_Conic_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 13 members inherited from ConicBase (@pxref{curve_ConicBase_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Conic(double roc@comma{} double sc)
@item virtual double derivative(double r) const
@item double fit(const rotational &curve@comma{} double radius@comma{} unsigned int count)
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual double sagitta(double r) const
@item void set_eccentricity(double e)
@item void set_schwarzschild(double sc)
@end itemize

@subheading Members detail

@subsubheading Conic(double roc@comma{} double sc)
@anchor{_52}

Creates a conic curve with given radius of curvature and Schwarzschild constant

@subsubheading virtual double derivative(double r) const
@anchor{_53}

This virtual function implements the @code{derivative (@pxref{_130})} pure function declared in the @code{ConicBase (@pxref{curve_ConicBase_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve derivative at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@subsubheading double fit(const rotational &curve@comma{} double radius@comma{} unsigned int count)
@anchor{_54}

Adjust radius of curvature _and_ deformation to best fit given curve

Parameters list:

@itemize
@item curve: curve to fit 
@item radius: Maximum radius used to get sample points 
@item count: Number of sample points to use
@end itemize

@subsubheading virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@anchor{_55}

This virtual function implements the @code{intersect (@pxref{_134})} pure function declared in the @code{ConicBase (@pxref{curve_ConicBase_class_reference})} base abstract class.

Documentation inherited from base class:

Get intersection point between curve and 3d ray. Return false if no intersection occurred

@subsubheading virtual double sagitta(double r) const
@anchor{_56}

This virtual function implements the @code{sagitta (@pxref{_135})} pure function declared in the @code{ConicBase (@pxref{curve_ConicBase_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve sagitta at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@subsubheading void set_eccentricity(double e)
@anchor{_57}

Set eccentricity

@subsubheading void set_schwarzschild(double sc)
@anchor{_58}

Set Schwarzschild constant

@page

@heading curve::Conic class full member list
@anchor{curve_Conic_class_full_member_list}

@subheading Functions

@itemize
@item Conic(double roc@comma{} double sc)
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual double derivative(double r) const
@item double fit(const rotational &curve@comma{} double radius@comma{} unsigned int count)
@item double fit_roc(const rotational &c@comma{} double radius@comma{} unsigned int count)
@item double get_eccentricity() const
@item double get_roc() const
@item virtual void get_sample(unsigned int index@comma{} double &r@comma{} double &z) const
@item virtual unsigned int get_sample_count() const
@item double get_schwarzschild() const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(const math::vector2 &xy) const
@item virtual double sagitta(double r) const
@item void set_eccentricity(double e)
@item void set_roc(double roc)
@item void set_schwarzschild(double sc)
@end itemize

@page

@heading curve::Flat class reference
@anchor{curve_Flat_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/Flat>

namespace goptical @{
  namespace curve @{
    class Flat;
  @};
@};

@end example

 This class is a member of the curve namespace.

@subheading Inheritance

@subheading Description

The global variable flat (@pxref{_33}) provides an instance of this class.

@subheading Members

 See also the full member list (@pxref{curve_Flat_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 9 members inherited from rotational (@pxref{curve_rotational_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Flat()
@item virtual double derivative(double r) const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(double r) const
@end itemize

@subheading Members detail

@subsubheading Flat()
@anchor{_59}

Creates a flat curve

@subsubheading virtual double derivative(double r) const
@anchor{_60}

This virtual function overrides the @code{derivative (@pxref{_139})} virtual function defined in the @code{rotational (@pxref{curve_rotational_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve derivative at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@subsubheading virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@anchor{_61}

This virtual function overrides the @code{intersect (@pxref{_40})} virtual function defined in the @code{Base (@pxref{curve_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get intersection point between curve and 3d ray. Return false if no intersection occurred

@subsubheading virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@anchor{_62}

This virtual function overrides the @code{normal (@pxref{_143})} virtual function defined in the @code{rotational (@pxref{curve_rotational_class_reference})} base abstract class.

Documentation inherited from base class:

Get normal to curve surface at specified point

@subsubheading virtual double sagitta(double r) const
@anchor{_63}

This virtual function implements the @code{sagitta (@pxref{_144})} pure function declared in the @code{rotational (@pxref{curve_rotational_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve sagitta at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@page

@heading curve::Flat class full member list
@anchor{curve_Flat_class_full_member_list}

@subheading Functions

@itemize
@item Flat()
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual double derivative(double r) const
@item virtual void get_sample(unsigned int index@comma{} double &r@comma{} double &z) const
@item virtual unsigned int get_sample_count() const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(const math::vector2 &xy) const
@item virtual double sagitta(double r) const
@end itemize

@page

@heading curve::Foucault class reference
@anchor{curve_Foucault_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/Foucault>

namespace goptical @{
  namespace curve @{
    class Foucault;
  @};
@};

@end example

 This class is a member of the curve namespace.

@subheading Inheritance

@subheading Description

This class allows definition of a rotationally symmetric curve from a set of Foucault test data. Fixed and moving light sources are supported.

curve fitting can be used to find Foucault test readings from any other rotationally symmetric curve.

Foucault test data are reduced using numerical integration of a differential equation to compute sagitta from slopes.

Foucault data reduction algorithm based on "ATM mirror mathematics"  @uref{http://home.earthlink.net/~burrjaw/atm/atm_math.lwp/atm_math.htm,,http://home.earthlink.net/~burrjaw/atm/atm_math.lwp/atm_math.htm} 

Couder mask theory and formulas developed by Nils Olof Carlin  @uref{http://www.atmsite.org/contrib/Carlin/couder/,,http://www.atmsite.org/contrib/Carlin/couder/} 

@subheading Members

 See also the full member list (@pxref{curve_Foucault_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 2 members inherited from curveRoc (@pxref{curve_curveRoc_class_reference})
@item 9 members inherited from rotational (@pxref{curve_rotational_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Foucault(double roc)
@item ~Foucault()
@item unsigned int add_couder_zones(double hole_radius@comma{} unsigned int count = @emph{[...]}@comma{} std::vector<double> *edge = @emph{[...]})
@item void add_reading(double zone_radius@comma{} double knife_offset = @emph{[...]})
@item unsigned int add_uniform_zones(double hole_radius@comma{} unsigned int count)
@item void clear()
@item virtual double derivative(double r) const
@item void fit(const rotational &c)
@item double get_radius() const
@item const std::pair<double@comma{} double> get_reading(unsigned int zone_number) const
@item unsigned int get_zones_count() const
@item virtual double sagitta(double r) const
@item void set_fixed_source(double source_to_surface)
@item void set_knife_offset(unsigned int zone_number@comma{} double knife_offset)
@item void set_moving_source(double source_offset = @emph{[...]})
@item void set_ode_stepsize(double step)
@item void set_radius(double radius)
@end itemize

@subheading Members detail

@subsubheading Foucault(double roc)
@anchor{_64}

Create an empty foucault curve with no reading with the given radius of curvature

@subsubheading ~Foucault()
@anchor{_65}

No documentation available

@subsubheading unsigned int add_couder_zones(double hole_radius@comma{} unsigned int count = 0@comma{} std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01318.html,,vector} <double> *edge = 0)
@anchor{_66}

Clear current zones and add zones readings to locations suited for testing with a couder mask (as described on Nils Olof Carlin page). Zone count may be guessed if zero@comma{} provided that radius has been properly set before. Knife edge reading (offset from radius of curvature) is set to 0 for all zones. 

@itemize
@item edge: Couder zones edges will be saved here if != NULL. 
@end itemize

The return value is Zone count

@subsubheading void add_reading(double zone_radius@comma{} double knife_offset = 0.0)
@anchor{_67}

Define a new zone at given zone radius and update knife edge reading (offset from radius of curvature)

@subsubheading unsigned int add_uniform_zones(double hole_radius@comma{} unsigned int count)
@anchor{_68}

Clear current zones and add equally spaced zones readings. Knife edge reading (offset from radius of curvature) is set to 0 for all zones. 

The return value is New zones count

@subsubheading void clear()
@anchor{_69}

Clear all readings and zones

@subsubheading virtual double derivative(double r) const
@anchor{_70}

This virtual function overrides the @code{derivative (@pxref{_139})} virtual function defined in the @code{rotational (@pxref{curve_rotational_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve derivative at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@subsubheading void fit(const rotational &c)
@anchor{_71}

Switch to moving source test and update knife edge readings of previously defined zone to fit provided rotationally symmetric curve. This means simulating a foucault test of the given curve using existing zones.

@subsubheading double get_radius() const
@anchor{_72}

Get surface radius.

@subsubheading const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01149.html,,pair} <double@comma{} double> get_reading(unsigned int zone_number) const
@anchor{_73}

Get reading data for a given zone number. 

The return value is std::pair with zone radius and knife offset

@subsubheading unsigned int get_zones_count() const
@anchor{_74}

Get currently defined zones/readings count

@subsubheading virtual double sagitta(double r) const
@anchor{_75}

This virtual function implements the @code{sagitta (@pxref{_144})} pure function declared in the @code{rotational (@pxref{curve_rotational_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve sagitta at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@subsubheading void set_fixed_source(double source_to_surface)
@anchor{_76}

Set fixed light source foucault test. This clear all readings and zones. 

@itemize
@item source_to_surface: Distance between surface and light source along the optical axis.
@end itemize

@subsubheading void set_knife_offset(unsigned int zone_number@comma{} double knife_offset)
@anchor{_77}

Set knife edge reading of a previously defined zone

@subsubheading void set_moving_source(double source_offset = 0.0)
@anchor{_78}

Set moving light source foucault test. This clear all readings and zones. 

@itemize
@item source_offset: Distance between knife edge and light source along optical axis.
@end itemize

@subsubheading void set_ode_stepsize(double step)
@anchor{_79}

Set surface integration (ODE) algorithm step size@comma{} default is 1mm

@subsubheading void set_radius(double radius)
@anchor{_80}

Set surface radius. Effective surface radius must be known to let the surface integration algorithm run up to a given limit. Sagitta and gradient values above the define radius won't be accurate.

Radius is adjusted to max zone radius + 10% when adding readings.

@page

@heading curve::Foucault class full member list
@anchor{curve_Foucault_class_full_member_list}

@subheading Functions

@itemize
@item Foucault(double roc)
@item ~Foucault()
@item unsigned int add_couder_zones(double hole_radius@comma{} unsigned int count = @emph{[...]}@comma{} std::vector<double> *edge = @emph{[...]})
@item void add_reading(double zone_radius@comma{} double knife_offset = @emph{[...]})
@item unsigned int add_uniform_zones(double hole_radius@comma{} unsigned int count)
@item void clear()
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual double derivative(double r) const
@item void fit(const rotational &c)
@item double get_radius() const
@item const std::pair<double@comma{} double> get_reading(unsigned int zone_number) const
@item double get_roc() const
@item virtual void get_sample(unsigned int index@comma{} double &r@comma{} double &z) const
@item virtual unsigned int get_sample_count() const
@item unsigned int get_zones_count() const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(const math::vector2 &xy) const
@item virtual double sagitta(double r) const
@item void set_fixed_source(double source_to_surface)
@item void set_knife_offset(unsigned int zone_number@comma{} double knife_offset)
@item void set_moving_source(double source_offset = @emph{[...]})
@item void set_ode_stepsize(double step)
@item void set_radius(double radius)
@item void set_roc(double roc)
@end itemize

@page

@heading curve::Grid class reference
@anchor{curve_Grid_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/Grid>

namespace goptical @{
  namespace curve @{
    class Grid;
  @};
@};

@end example

 This class is a member of the curve namespace.

@subheading Inheritance

@subheading Description

This class use the data::Grid (@pxref{data_Grid_class_reference}) 2d data set container to define a 3d non-symmetric curve. Several data interpolation algorithms are available allowing use of data::Bicubic (@pxref{_146}) spline interpolation with or without prescribed derivative/gradient data.  .

The Spline (@pxref{curve_Spline_class_reference}) curve model is preferred when dealing with rotationally symmetric curves (@pxref{curve_rotational_class_reference}).

See also data::Grid (@pxref{data_Grid_class_reference}) class.

@subheading Members

 See also the full member list (@pxref{curve_Grid_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 5 members inherited from Base (@pxref{curve_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Grid(unsigned int n@comma{} double radius)
@item ~Grid()
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item void fit(const Base &c)
@item const data::Grid & get_data() const
@item data::Grid & get_data()
@item virtual double sagitta(const math::vector2 &xy) const
@end itemize

@subheading Members detail

@subsubheading Grid(unsigned int n@comma{} double radius)
@anchor{_81}

Creates a grid curve with n*n sample points defined over the given radius.

@subsubheading ~Grid()
@anchor{_82}

No documentation available

@subsubheading virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@anchor{_83}

This virtual function overrides the @code{derivative (@pxref{_39})} virtual function defined in the @code{Base (@pxref{curve_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve x and y derivative (gradient) at specified point

@subsubheading void fit(const Base &c)
@anchor{_84}

Set grid values to best fit an other curve. Gradient data will be extracted only if the interpolation have been set to data::BicubicDeriv previously

@subsubheading const data::Grid & get_data() const
@anchor{_85}

Get embedded sagitta/gradient data container

@subsubheading data::Grid & get_data()
@anchor{_86}

Get embedded sagitta/gradient data container

@subsubheading virtual double sagitta(const math::vector2 &xy) const
@anchor{_87}

This virtual function implements the @code{sagitta (@pxref{_42})} pure function declared in the @code{Base (@pxref{curve_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve sagitta at specified point

@page

@heading curve::Grid class full member list
@anchor{curve_Grid_class_full_member_list}

@subheading Functions

@itemize
@item Grid(unsigned int n@comma{} double radius)
@item ~Grid()
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item void fit(const Base &c)
@item const data::Grid & get_data() const
@item data::Grid & get_data()
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(const math::vector2 &xy) const
@end itemize

@page

@heading curve::Parabola class reference
@anchor{curve_Parabola_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/Parabola>

namespace goptical @{
  namespace curve @{
    class Parabola;
  @};
@};

@end example

 This class is a member of the curve namespace.

@subheading Inheritance

@subheading Description

This class provides an efficient parabola curve implementation.

@subheading Members

 See also the full member list (@pxref{curve_Parabola_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 13 members inherited from ConicBase (@pxref{curve_ConicBase_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Parabola(double roc)
@item virtual double derivative(double r) const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual double sagitta(double r) const
@end itemize

@subheading Members detail

@subsubheading Parabola(double roc)
@anchor{_88}

Creates a parabola curve with given radius of curvature

@subsubheading virtual double derivative(double r) const
@anchor{_89}

This virtual function implements the @code{derivative (@pxref{_130})} pure function declared in the @code{ConicBase (@pxref{curve_ConicBase_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve derivative at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@subsubheading virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@anchor{_90}

This virtual function implements the @code{intersect (@pxref{_134})} pure function declared in the @code{ConicBase (@pxref{curve_ConicBase_class_reference})} base abstract class.

Documentation inherited from base class:

Get intersection point between curve and 3d ray. Return false if no intersection occurred

@subsubheading virtual double sagitta(double r) const
@anchor{_91}

This virtual function implements the @code{sagitta (@pxref{_135})} pure function declared in the @code{ConicBase (@pxref{curve_ConicBase_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve sagitta at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@page

@heading curve::Parabola class full member list
@anchor{curve_Parabola_class_full_member_list}

@subheading Functions

@itemize
@item Parabola(double roc)
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual double derivative(double r) const
@item double fit_roc(const rotational &c@comma{} double radius@comma{} unsigned int count)
@item double get_eccentricity() const
@item double get_roc() const
@item virtual void get_sample(unsigned int index@comma{} double &r@comma{} double &z) const
@item virtual unsigned int get_sample_count() const
@item double get_schwarzschild() const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(const math::vector2 &xy) const
@item virtual double sagitta(double r) const
@item void set_roc(double roc)
@end itemize

@page

@heading curve::Polynomial class reference
@anchor{curve_Polynomial_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/Polynomial>

namespace goptical @{
  namespace curve @{
    class Polynomial;
  @};
@};

@end example

 This class is a member of the curve namespace.

@subheading Inheritance

@subheading Description

This class allow definition of rotationally symmetric high order polynomial curves. Unlimited number of terms can be used.

@subheading Members

 See also the full member list (@pxref{curve_Polynomial_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 9 members inherited from rotational (@pxref{curve_rotational_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Polynomial()
@item Polynomial(unsigned int first_term@comma{} unsigned int last_term@comma{} ...)
@item virtual double derivative(double r) const
@item virtual double sagitta(double r) const
@item void set(unsigned int first_term@comma{} unsigned int last_term@comma{} ...)
@item void set_even(unsigned int first_term@comma{} unsigned int last_term@comma{} ...)
@item void set_first_term(unsigned int n)
@item void set_last_term(unsigned int n)
@item void set_odd(unsigned int first_term@comma{} unsigned int last_term@comma{} ...)
@item void set_term_factor(unsigned int n@comma{} double c)
@end itemize

@subheading Members detail

@subsubheading Polynomial()
@anchor{_92}

Create a new zero polynomial

@subsubheading Polynomial(unsigned int first_term@comma{} unsigned int last_term@comma{} ...)
@anchor{_93}

Create a new polynomial with given order and coefficients. Same syntax as set() function.

@subsubheading virtual double derivative(double r) const
@anchor{_94}

This virtual function overrides the @code{derivative (@pxref{_139})} virtual function defined in the @code{rotational (@pxref{curve_rotational_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve derivative at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@subsubheading virtual double sagitta(double r) const
@anchor{_95}

This virtual function implements the @code{sagitta (@pxref{_144})} pure function declared in the @code{rotational (@pxref{curve_rotational_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve sagitta at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@subsubheading void set(unsigned int first_term@comma{} unsigned int last_term@comma{} ...)
@anchor{_96}

Set polynomial order and coefficients. 

@itemize
@item first_term: order of first (lowest) term. 
@item last_term: order of last (highest) term. 
@item ...: list of coefficient starting at lowest term
@end itemize

@subsubheading void set_even(unsigned int first_term@comma{} unsigned int last_term@comma{} ...)
@anchor{_97}

Set even polynomial order and coefficients. 

@itemize
@item first_term: order of first (lowest) term@comma{} must be even. 
@item last_term: order of last (highest) term@comma{} must be even. 
@item ...: list of even coefficient starting at lowest term
@end itemize

@subsubheading void set_first_term(unsigned int n)
@anchor{_98}

Set order of first (lowest) term. Polynomial may be truncated or extended with 0 coefficients.

@subsubheading void set_last_term(unsigned int n)
@anchor{_99}

Set order of last (highest) term. Polynomial may be truncated or extended with 0 coefficients.

@subsubheading void set_odd(unsigned int first_term@comma{} unsigned int last_term@comma{} ...)
@anchor{_100}

Set odd polynomial order and coefficients. 

@itemize
@item first_term: order of first (lowest) term@comma{} must be odd. 
@item last_term: order of last (highest) term@comma{} must be odd. 
@item ...: list of odd coefficient starting at lowest term
@end itemize

@subsubheading void set_term_factor(unsigned int n@comma{} double c)
@anchor{_101}

Adjust coefficient of a single term. Adujst polynomial length as needed@comma{} setting additional coefficients to 0.

@page

@heading curve::Polynomial class full member list
@anchor{curve_Polynomial_class_full_member_list}

@subheading Functions

@itemize
@item Polynomial()
@item Polynomial(unsigned int first_term@comma{} unsigned int last_term@comma{} ...)
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual double derivative(double r) const
@item virtual void get_sample(unsigned int index@comma{} double &r@comma{} double &z) const
@item virtual unsigned int get_sample_count() const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(const math::vector2 &xy) const
@item virtual double sagitta(double r) const
@item void set(unsigned int first_term@comma{} unsigned int last_term@comma{} ...)
@item void set_even(unsigned int first_term@comma{} unsigned int last_term@comma{} ...)
@item void set_first_term(unsigned int n)
@item void set_last_term(unsigned int n)
@item void set_odd(unsigned int first_term@comma{} unsigned int last_term@comma{} ...)
@item void set_term_factor(unsigned int n@comma{} double c)
@end itemize

@page

@heading curve::Sphere class reference
@anchor{curve_Sphere_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/Sphere>

namespace goptical @{
  namespace curve @{
    class Sphere;
  @};
@};

@end example

 This class is a member of the curve namespace.

@subheading Inheritance

@subheading Description

This class provides an efficient spherical curve implementation.

@subheading Members

 See also the full member list (@pxref{curve_Sphere_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 13 members inherited from ConicBase (@pxref{curve_ConicBase_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Sphere(double roc)
@item virtual double derivative(double r) const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(double r) const
@end itemize

@subheading Members detail

@subsubheading Sphere(double roc)
@anchor{_102}

Creates a spherical curve with given radius of curvature

@subsubheading virtual double derivative(double r) const
@anchor{_103}

This virtual function implements the @code{derivative (@pxref{_130})} pure function declared in the @code{ConicBase (@pxref{curve_ConicBase_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve derivative at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@subsubheading virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@anchor{_104}

This virtual function implements the @code{intersect (@pxref{_134})} pure function declared in the @code{ConicBase (@pxref{curve_ConicBase_class_reference})} base abstract class.

Documentation inherited from base class:

Get intersection point between curve and 3d ray. Return false if no intersection occurred

@subsubheading virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@anchor{_105}

This virtual function overrides the @code{normal (@pxref{_143})} virtual function defined in the @code{rotational (@pxref{curve_rotational_class_reference})} base abstract class.

Documentation inherited from base class:

Get normal to curve surface at specified point

@subsubheading virtual double sagitta(double r) const
@anchor{_106}

This virtual function implements the @code{sagitta (@pxref{_135})} pure function declared in the @code{ConicBase (@pxref{curve_ConicBase_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve sagitta at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@page

@heading curve::Sphere class full member list
@anchor{curve_Sphere_class_full_member_list}

@subheading Functions

@itemize
@item Sphere(double roc)
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual double derivative(double r) const
@item double fit_roc(const rotational &c@comma{} double radius@comma{} unsigned int count)
@item double get_eccentricity() const
@item double get_roc() const
@item virtual void get_sample(unsigned int index@comma{} double &r@comma{} double &z) const
@item virtual unsigned int get_sample_count() const
@item double get_schwarzschild() const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(const math::vector2 &xy) const
@item virtual double sagitta(double r) const
@item void set_roc(double roc)
@end itemize

@page

@heading curve::Spline class reference
@anchor{curve_Spline_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/Spline>

namespace goptical @{
  namespace curve @{
    class Spline;
  @};
@};

@end example

 This class is a member of the curve namespace.

@subheading Inheritance

@subheading Description

This class uses a 1d discrete data set to define a rotationally symmetric sagitta/gradient curve. Several data interpolations algorithm are available allowing use of Smooth Cubic spline interpolation with or without prescribed derivative/gradient data.

See also data::DiscreteSet (@pxref{data_DiscreteSet_class_reference}) class.

@subheading Members

 See also the full member list (@pxref{curve_Spline_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 9 members inherited from rotational (@pxref{curve_rotational_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Spline()
@item ~Spline()
@item virtual double derivative(double r) const
@item void fit(const rotational &c@comma{} double radius@comma{} unsigned int points)
@item const data::DiscreteSet & get_data() const
@item data::DiscreteSet & get_data()
@item virtual double sagitta(double r) const
@end itemize

@subheading Members detail

@subsubheading Spline()
@anchor{_107}

Create an empty spline curve with no defined point

@subsubheading ~Spline()
@anchor{_108}

No documentation available

@subsubheading virtual double derivative(double r) const
@anchor{_109}

This virtual function overrides the @code{derivative (@pxref{_139})} virtual function defined in the @code{rotational (@pxref{curve_rotational_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve derivative at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@subsubheading void fit(const rotational &c@comma{} double radius@comma{} unsigned int points)
@anchor{_110}

Clear all points and fit to an other rotationally symmetric curve. 

@itemize
@item c: curve to fit 
@item radius: Maximum radius where curve is defined 
@item points: Number of sample points
@end itemize

@subsubheading const data::DiscreteSet & get_data() const
@anchor{_111}

Get sagitta/derivative data container

@subsubheading data::DiscreteSet & get_data()
@anchor{_112}

get sagitta/derivative data container

@subsubheading virtual double sagitta(double r) const
@anchor{_113}

This virtual function implements the @code{sagitta (@pxref{_144})} pure function declared in the @code{rotational (@pxref{curve_rotational_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve sagitta at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@page

@heading curve::Spline class full member list
@anchor{curve_Spline_class_full_member_list}

@subheading Functions

@itemize
@item Spline()
@item ~Spline()
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual double derivative(double r) const
@item void fit(const rotational &c@comma{} double radius@comma{} unsigned int points)
@item const data::DiscreteSet & get_data() const
@item data::DiscreteSet & get_data()
@item virtual void get_sample(unsigned int index@comma{} double &r@comma{} double &z) const
@item virtual unsigned int get_sample_count() const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(const math::vector2 &xy) const
@item virtual double sagitta(double r) const
@end itemize

@page

@heading curve::Zernike class reference
@anchor{curve_Zernike_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/Zernike>

namespace goptical @{
  namespace curve @{
    class Zernike;
  @};
@};

@end example

 This class is a member of the curve namespace.

@subheading Inheritance

@subheading Description

This class enables use of zernikes polynomials to define a surface curve. Zernikes terms can be enabled and disabled individually.

Fitting can be used to get best fit Zernike polynomials coefficients of an other curve.

This implementation uses Zernike polynomials set as described in ISO standard 10110-5.

Based on Zernikes pages by James C Wyant and Michael Koch.  @uref{http://www.optics.arizona.edu/jcwyant/Zernikes/ZernikePolynomials.htm,,http://www.optics.arizona.edu/jcwyant/Zernikes/ZernikePolynomials.htm}  and  @uref{http://www.astro-electronic.de/faq2.htm,,http://www.astro-electronic.de/faq2.htm} 

@subheading Members

 See also the full member list (@pxref{curve_Zernike_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 5 members inherited from Base (@pxref{curve_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Zernike(double radius@comma{} double unit_scale = @emph{[...]})
@item Zernike(double radius@comma{} double coefs[]@comma{} unsigned int coefs_count@comma{} double unit_scale = @emph{[...]})
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item double fit(const Base &c@comma{} const trace::distribution &d = @emph{[...]})
@item double get_coefficient(unsigned int n) const
@item double get_radius() const
@item bool get_term_state(unsigned int n)
@item virtual double sagitta(const math::vector2 &xy) const
@item void set_coefficient(unsigned int n@comma{} double c)
@item void set_coefficients_scale(double s)
@item void set_coefficients_threshold(double t)
@item void set_radius(double radius)
@item void set_term_state(unsigned int n@comma{} bool enabled)
@end itemize

@subsubheading Static functions

@itemize
@item static double zernike_poly(unsigned int n@comma{} const math::vector2 &xy)
@item static void zernike_poly_d(unsigned int n@comma{} const math::vector2 &xy@comma{} math::vector2 &dxdy)
@end itemize

@subsubheading Constant

@itemize
@item static const unsigned int term_count
@end itemize

@subheading Members detail

@subsubheading Zernike(double radius@comma{} double unit_scale = 1.0)
@anchor{_114}

Create a Zernike curve defined over the given circle radius. 

@itemize
@item radius: Zernike circle radius 
@item unit_scale: Sagitta scale factor used to change units globally
@end itemize

@subsubheading Zernike(double radius@comma{} double coefs[]@comma{} unsigned int coefs_count@comma{} double unit_scale = 1.0)
@anchor{_115}

Create a Zernike curve defined over the given circle radius and initialize coefficients from table. 

@itemize
@item radius: Zernike circle radius 
@item coefs: Table of Zernike coefficients starting with z0 (piston) 
@item coefs_count: Number of coefficients available in the table 
@item unit_scale: Sagitta scale factor used to change units globally
@end itemize

@subsubheading virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@anchor{_116}

This virtual function overrides the @code{derivative (@pxref{_39})} virtual function defined in the @code{Base (@pxref{curve_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve x and y derivative (gradient) at specified point

@subsubheading double fit(const Base &c@comma{} const trace::distribution &d = default_dist)
@anchor{_117}

Compute all zernike coefficient to best fit the given curve. RMS difference is returned. The specified distribution is used to choose sampling points on curve. Terms state is adjusted according to current threshold

@subsubheading double get_coefficient(unsigned int n) const
@anchor{_118}

Get coefficient associated with zernike term n

@subsubheading double get_radius() const
@anchor{_119}

Get Zernike circle radius

@subsubheading bool get_term_state(unsigned int n)
@anchor{_120}

Get current term enable state

@subsubheading virtual double sagitta(const math::vector2 &xy) const
@anchor{_121}

This virtual function implements the @code{sagitta (@pxref{_42})} pure function declared in the @code{Base (@pxref{curve_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve sagitta at specified point

@subsubheading void set_coefficient(unsigned int n@comma{} double c)
@anchor{_122}

Set coefficient associated with zernike term n and enable term according to current threshold. See set_coefficients_threshold()

@subsubheading void set_coefficients_scale(double s)
@anchor{_123}

Set coefficients unit scale factor. default is 1 (1 mm).

@subsubheading void set_coefficients_threshold(double t)
@anchor{_124}

Set new coefficient threshold and adjust all term states (enabled/disabled) depending on new threshold. Term with coefficient absolute value below the specified threshold will be disabled. Disabling useless terms improve performance. Default threshold is 10^-10.

@subsubheading void set_radius(double radius)
@anchor{_125}

Set Zernike circle radius

@subsubheading void set_term_state(unsigned int n@comma{} bool enabled)
@anchor{_126}

This functions must be used to enable/disable a zernike term without changing its coefficient

@subsubheading static const unsigned int term_count
@anchor{_127}

Number of implemented zernike polynomials

@subsubheading static double zernike_poly(unsigned int n@comma{} const math::vector2 &xy)
@anchor{_128}

Evaluate zernike polynomial n

@subsubheading static void zernike_poly_d(unsigned int n@comma{} const math::vector2 &xy@comma{} math::vector2 &dxdy)
@anchor{_129}

Evaluate x and y derivatives of zernike polynomial n

@page

@heading curve::Zernike class full member list
@anchor{curve_Zernike_class_full_member_list}

@subheading Functions

@itemize
@item Zernike(double radius@comma{} double unit_scale = @emph{[...]})
@item Zernike(double radius@comma{} double coefs[]@comma{} unsigned int coefs_count@comma{} double unit_scale = @emph{[...]})
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item double fit(const Base &c@comma{} const trace::distribution &d = @emph{[...]})
@item double get_coefficient(unsigned int n) const
@item double get_radius() const
@item bool get_term_state(unsigned int n)
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(const math::vector2 &xy) const
@item void set_coefficient(unsigned int n@comma{} double c)
@item void set_coefficients_scale(double s)
@item void set_coefficients_threshold(double t)
@item void set_radius(double radius)
@item void set_term_state(unsigned int n@comma{} bool enabled)
@end itemize

@subheading Static functions

@itemize
@item static double zernike_poly(unsigned int n@comma{} const math::vector2 &xy)
@item static void zernike_poly_d(unsigned int n@comma{} const math::vector2 &xy@comma{} math::vector2 &dxdy)
@end itemize

@subheading Constant

@itemize
@item static const unsigned int term_count
@end itemize

@page

@heading curve::ConicBase class reference
@anchor{curve_ConicBase_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/ConicBase>

namespace goptical @{
  namespace curve @{
    class ConicBase;
  @};
@};

@end example

 This class is a member of the curve namespace.

This abstract class contains pure virtuals.

@subheading Inheritance

@subheading Description

This base class defines common properties of rotationally symmetric conic curves. These curves are all defined by a radius of curvature and deformation coefficient.

Fitting can be used to find best fit conic of an other rotationally symmetric curve either with fixed or free deformation parameter.

@subheading Members

 See also the full member list (@pxref{curve_ConicBase_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 2 members inherited from curveRoc (@pxref{curve_curveRoc_class_reference})
@item 9 members inherited from rotational (@pxref{curve_rotational_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item virtual double derivative(double r) const = 0;
@item double fit_roc(const rotational &c@comma{} double radius@comma{} unsigned int count)
@item double get_eccentricity() const
@item double get_schwarzschild() const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const = 0;
@item virtual double sagitta(double r) const = 0;
@end itemize

@subheading Members detail

@subsubheading virtual double derivative(double r) const = 0;
@anchor{_130}

This pure virtual function shadows the @code{derivative (@pxref{_139})} virtual function defined in the @code{rotational (@pxref{curve_rotational_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve derivative at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@subsubheading double fit_roc(const rotational &c@comma{} double radius@comma{} unsigned int count)
@anchor{_131}

Adjust radius of curvature to best fit given curve. Deformation Won't be changed by this function. See Conic::fit() to adjust deformation too.

Parameters list:

@itemize
@item curve: curve to fit 
@item radius: Maximum radius used to get sample points 
@item count: Number of sample points to use
@end itemize

@subsubheading double get_eccentricity() const
@anchor{_132}

get eccentricity

@subsubheading double get_schwarzschild() const
@anchor{_133}

get Schwarzschild constant

@subsubheading virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const = 0;
@anchor{_134}

This pure virtual function shadows the @code{intersect (@pxref{_40})} virtual function defined in the @code{Base (@pxref{curve_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get intersection point between curve and 3d ray. Return false if no intersection occurred

@subsubheading virtual double sagitta(double r) const = 0;
@anchor{_135}

This pure virtual function shadows the @code{sagitta (@pxref{_144})} pure virtual function defined in the @code{rotational (@pxref{curve_rotational_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve sagitta at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@page

@heading curve::ConicBase class full member list
@anchor{curve_ConicBase_class_full_member_list}

@subheading Functions

@itemize
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual double derivative(double r) const = 0;
@item double fit_roc(const rotational &c@comma{} double radius@comma{} unsigned int count)
@item double get_eccentricity() const
@item double get_roc() const
@item virtual void get_sample(unsigned int index@comma{} double &r@comma{} double &z) const
@item virtual unsigned int get_sample_count() const
@item double get_schwarzschild() const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const = 0;
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(const math::vector2 &xy) const
@item virtual double sagitta(double r) const = 0;
@item void set_roc(double roc)
@end itemize

@page

@heading curve::curveRoc class reference
@anchor{curve_curveRoc_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/curveRoc>

namespace goptical @{
  namespace curve @{
    class curveRoc;
  @};
@};

@end example

 This class is a member of the curve namespace.

@subheading Inheritance

@subheading Description
Base class for curves with a radius of curvature
@subheading Members

 See also the full member list (@pxref{curve_curveRoc_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item double get_roc() const
@item void set_roc(double roc)
@end itemize

@subheading Members detail

@subsubheading double get_roc() const
@anchor{_136}

Get the radius of curvature

@subsubheading void set_roc(double roc)
@anchor{_137}

Set the radius of curvature

@page

@heading curve::curveRoc class full member list
@anchor{curve_curveRoc_class_full_member_list}

@subheading Functions

@itemize
@item double get_roc() const
@item void set_roc(double roc)
@end itemize

@page

@heading curve::rotational class reference
@anchor{curve_rotational_class_reference}

@subheading Declaration

@example
#include <goptical/core/curve/rotational>

namespace goptical @{
  namespace curve @{
    class rotational;
  @};
@};

@end example

 This class is a member of the curve namespace.

This abstract class contains pure virtuals.

@subheading Inheritance

@subheading Description

This class defines rotationally symmetric curve interface and provide default implementation as generic non symmetric curve.

@subheading Members

 See also the full member list (@pxref{curve_rotational_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 5 members inherited from Base (@pxref{curve_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item rotational()
@item virtual double derivative(double r) const
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual void get_sample(unsigned int index@comma{} double &r@comma{} double &z) const
@item virtual unsigned int get_sample_count() const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(double r) const = 0;
@item virtual double sagitta(const math::vector2 &xy) const
@end itemize

@subheading Members detail

@subsubheading rotational()
@anchor{_138}

No documentation available

@subsubheading virtual double derivative(double r) const
@anchor{_139}

Get curve derivative at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@subsubheading virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@anchor{_140}

This virtual function overrides the @code{derivative (@pxref{_39})} virtual function defined in the @code{Base (@pxref{curve_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve x and y derivative (gradient) at specified point

@subsubheading virtual void get_sample(unsigned int index@comma{} double &r@comma{} double &z) const
@anchor{_141}

Get a sample point on curve. (0@comma{}0) is not included.

@subsubheading virtual unsigned int get_sample_count() const
@anchor{_142}

Get number of available sample points. Samples points may be used by curve fitting algorithms and are choosen to avoid using interpolated points. return 0 when not applicable.

@subsubheading virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@anchor{_143}

This virtual function overrides the @code{normal (@pxref{_41})} virtual function defined in the @code{Base (@pxref{curve_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get normal to curve surface at specified point

@subsubheading virtual double sagitta(double r) const = 0;
@anchor{_144}

Get curve sagitta at specified distance from origin. 

@itemize
@item r: distance from curve origin (0@comma{} 0)
@end itemize

@subsubheading virtual double sagitta(const math::vector2 &xy) const
@anchor{_145}

This virtual function implements the @code{sagitta (@pxref{_42})} pure function declared in the @code{Base (@pxref{curve_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get curve sagitta at specified point

@page

@heading curve::rotational class full member list
@anchor{curve_rotational_class_full_member_list}

@subheading Functions

@itemize
@item rotational()
@item virtual double derivative(double r) const
@item virtual void derivative(const math::vector2 &xy@comma{} math::vector2 &dxdy) const
@item virtual void get_sample(unsigned int index@comma{} double &r@comma{} double &z) const
@item virtual unsigned int get_sample_count() const
@item virtual bool intersect(math::vector3 &point@comma{} const math::vectorPair3 &ray) const
@item virtual void normal(math::vector3 &normal@comma{} const math::vector3 &point) const
@item virtual double sagitta(double r) const = 0;
@item virtual double sagitta(const math::vector2 &xy) const
@end itemize

@page

@heading data namespace reference
@anchor{data_namespace_reference}

@subheading Description
Numerical data interpolation and plotting
@subheading Members

@subsubheading Types

@itemize
@item class DiscreteSet
@item class Grid
@item class Plot
@item class Plotdata
@item class SampleSet
@item enum Interpolation
@item enum PlotStyleMask
@item class Set
@item class Set1d
@end itemize

@subsubheading Functions

@itemize
@item PlotStyleMask operator&(PlotStyleMask a@comma{} PlotStyleMask b)
@item std::ostream & operator<<(std::ostream &o@comma{} const Set &s)
@item PlotStyleMask operator|(PlotStyleMask a@comma{} PlotStyleMask b)
@item PlotStyleMask operator~(PlotStyleMask a)
@end itemize

@subheading Members detail

@subsubheading enum Interpolation
@anchor{_146}

Specifies data interpolation methods. Availability depends on data container used.

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item Nearest @tab 
1d and 2d nearest interpolation

@item Linear @tab 
1d linear and 2d bilinear interpolations

@item Quadratic @tab 
1d quadratic interpolation

@item CubicSimple @tab 
1d cubic piecewise interpolation. It has continuous piecewise first derivative@comma{} non-continuous piecewise linear second derivative. Use segments slope as first derivative. Less accurate than other cubic interpolants but requires less computation on data set change.

@item Cubic @tab 
1d cubic piecewise interpolation. It has smooth first derivative and continuous piecewise linear second derivative. Derivatives for first and last entries are based on first and last segments slope. It uses linear extrapolation (continuous but non-smooth first derivative on both ends).

@item Cubic2 @tab 
Same interpolation as Cubic@comma{} with quadratic extrapolation (continous and smooth first derivative on both ends).

@item CubicDerivInit @tab 
Same as Cubic with first derivative prescribed for first and last entries only.

@item Cubic2DerivInit @tab 
Same as Cubic2 with first derivative prescribed for first and last entries only.

@item CubicDeriv @tab 
1d cubic piecewise interpolation. First derivatives must be provided for all entries. It uses linear extrapolation.

@item Cubic2Deriv @tab 
1d cubic piecewise interpolation. First derivatives must be provided for all entries. It uses quadratic extrapolation.

@item Bicubic @tab 
2d bicubic interpolation. Use smooth first derivative and continuous piecewise linear second derivative. Use 1d cubic curve to extract gradients (smooth first derivative and continuous piecewise linear second derivative). This is the best 2d interpolation when derivatives are non-prescribed.

@item BicubicDiff @tab 
2d bicubic interpolation. Use numerical differencing to extract gradients. Less accurate than Bicubic (@pxref{_146}) but requires less computation on data set change.

@item BicubicDeriv @tab 
2d bicubic interpolation. x and y gradients must be provided. This is the best 2d interpolation when derivatives values are available.

@end multitable

@subsubheading enum PlotStyleMask
@anchor{_147}

Specifies available styles for 2d and 3d plot data rendering

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item LinePlot @tab 
Draw lines between knots

@item PointPlot @tab 
Draw points for each knot

@item InterpolatePlot @tab 
Draw a smooth curve

@item ValuePlot @tab 
Print ploted values near knots

@item Filled @tab 
Draw filled 3d surface

@end multitable

@subsubheading PlotStyleMask operator&(PlotStyleMask a@comma{} PlotStyleMask b)
@anchor{_148}

Bitwise and operation for use on PlotStyleMask (@pxref{_147}) enum.

@subsubheading std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  & operator<<(std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  &o@comma{} const Set &s)
@anchor{_149}

No documentation available

@subsubheading PlotStyleMask operator|(PlotStyleMask a@comma{} PlotStyleMask b)
@anchor{_150}

Bitwise or operation for use on PlotStyleMask (@pxref{_147}) enum.

@subsubheading PlotStyleMask operator~(PlotStyleMask a)
@anchor{_151}

Bitwise not operation for use on PlotStyleMask (@pxref{_147}) enum.

@page

@heading data::DiscreteSet class reference
@anchor{data_DiscreteSet_class_reference}

@subheading Declaration

@example
#include <goptical/core/data/DiscreteSet>

namespace goptical @{
  namespace data @{
    class DiscreteSet;
  @};
@};

@end example

 This class is a member of the data namespace.

@subheading Inheritance

@subheading Description

This class provides a numerical data container where value pairs can be defined at arbitrary positions (x@comma{} y).

Severals interpolation algorithms are available to guess values between defined knots@comma{} see Interpolation (@pxref{_146}).

See also SampleSet (@pxref{data_SampleSet_class_reference}) class.

@subheading Members

 See also the full member list (@pxref{data_DiscreteSet_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 19 members inherited from Set1d (@pxref{data_Set1d_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item DiscreteSet()
@item void add_data(double x@comma{} double y@comma{} double yp = @emph{[...]})
@item void clear()
@item virtual unsigned int get_count() const
@item double get_d_value(unsigned int x) const
@item double & get_d_value(unsigned int x)
@item virtual math::range_t get_x_range() const
@item virtual double get_x_value(unsigned int x) const
@item virtual double get_y_value(unsigned int x) const
@item virtual double & get_y_value(unsigned int x)
@item virtual double interpolate(const double x) const
@item virtual double interpolate(const double x@comma{} unsigned int deriv) const
@item void reserve(size_t n)
@item virtual void set_interpolation(Interpolation i)
@end itemize

@subheading Members detail

@subsubheading DiscreteSet()
@anchor{_152}

No documentation available

@page

@heading data::DiscreteSet class full member list
@anchor{data_DiscreteSet_class_full_member_list}

@subheading Functions

@itemize
@item DiscreteSet()
@item void add_data(double x@comma{} double y@comma{} double yp = @emph{[...]})
@item void clear()
@item virtual unsigned int get_count(unsigned int dim) const
@item virtual unsigned int get_count() const
@item double get_d_value(unsigned int x) const
@item double & get_d_value(unsigned int x)
@item virtual unsigned int get_dimensions() const
@item Interpolation get_interpolation()
@item unsigned int get_version() const
@item virtual math::range_t get_x_range(unsigned int dimension) const
@item virtual math::range_t get_x_range() const
@item virtual double get_x_value(unsigned int n@comma{} unsigned int dim) const
@item virtual double get_x_value(unsigned int x) const
@item virtual math::range_t get_y_range() const
@item virtual double get_y_value(const unsigned int x[]) const
@item virtual double get_y_value(unsigned int x) const
@item virtual double & get_y_value(unsigned int x)
@item virtual double interpolate(const double x[]) const
@item virtual double interpolate(const double x[]@comma{} unsigned int deriv@comma{} unsigned int dimension) const
@item virtual double interpolate(const double x) const
@item virtual double interpolate(const double x@comma{} unsigned int deriv) const
@item void reserve(size_t n)
@item virtual void set_interpolation(Interpolation i)
@end itemize

@page

@heading data::Grid class reference
@anchor{data_Grid_class_reference}

@subheading Declaration

@example
#include <goptical/core/data/Grid>

namespace goptical @{
  namespace data @{
    class Grid;
  @};
@};

@end example

 This class is a member of the data namespace.

@subheading Inheritance

@subheading Description

This class provides a numerical data container where data value can be defined for each point of a 2d rectangular grid. The grid is defined by grid samples count (n1@comma{} n2)@comma{} a 2d origin vector and 2 steps values.

Severals interpolation algorithms are available to guess values between grid defined knots@comma{} see Interpolation (@pxref{_146}).

@subheading Members

 See also the full member list (@pxref{data_Grid_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 12 members inherited from Set (@pxref{data_Set_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Grid(unsigned int n1@comma{} unsigned int n2@comma{} const math::vector2 &origin = @emph{[...]}@comma{} const math::vector2 &step = @emph{[...]})
@item ~Grid()
@item virtual unsigned int get_count(unsigned int dimension) const
@item const math::vector2 & get_d_value(unsigned int n1@comma{} unsigned int n2) const
@item math::vector2 & get_d_value(unsigned int n1@comma{} unsigned int n2)
@item virtual unsigned int get_dimensions() const
@item const math::vector2 & get_nearest_d(const math::vector2 &v) const
@item math::vector2 & get_nearest_d(const math::vector2 &v)
@item double get_nearest_y(const math::vector2 &v) const
@item double & get_nearest_y(const math::vector2 &v)
@item const math::vector2 & get_origin() const
@item const math::vector2 & get_step() const
@item virtual math::range_t get_x_range(unsigned int dimension) const
@item virtual double get_x_value(unsigned int x@comma{} unsigned int dimension) const
@item math::vector2 get_x_value_i(unsigned int n1@comma{} unsigned int n2) const
@item double get_y_value(unsigned int n1@comma{} unsigned int n2) const
@item double & get_y_value(unsigned int n1@comma{} unsigned int n2)
@item virtual double get_y_value(const unsigned int n[]) const
@item double interpolate(const math::vector2 &v) const
@item virtual double interpolate(const double x[]) const
@item virtual double interpolate(const double x[]@comma{} unsigned int deriv@comma{} unsigned int dimension) const
@item math::vector2 interpolate_deriv(const math::vector2 &v) const
@item void resize(unsigned int n1@comma{} unsigned int n2)
@item void set_all_d(const math::vector2 &deriv = @emph{[...]})
@item void set_all_y(double y = @emph{[...]})
@item virtual void set_interpolation(Interpolation i)
@item void set_metrics(const math::vector2 &origin@comma{} const math::vector2 &step)
@end itemize

@subheading Members detail

@subsubheading Grid(unsigned int n1@comma{} unsigned int n2@comma{} const math::vector2 &origin = math::vector2(0@comma{}0)@comma{} const math::vector2 &step = math::vector2(1@comma{}1))
@anchor{_153}

Create a Grid object with given sample counts and metrics. 

@itemize
@item n1: Number of samples along the first dimension axis. 
@item n2: Number of samples along the second dimension axis. 
@item origin: Grid origin point 
@item step: Step values for each grid dimensions
@end itemize

@subsubheading ~Grid()
@anchor{_154}

No documentation available

@subsubheading virtual unsigned int get_count(unsigned int dimension) const
@anchor{_155}

This virtual function implements the @code{get_count (@pxref{_223})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Get total number of data stored for dimension n in data set

@subsubheading const math::vector2 & get_d_value(unsigned int n1@comma{} unsigned int n2) const
@anchor{_156}

Get 1st derivative/gradient vector at sample point index (n1@comma{} n2). Only available when data::BicubicDeriv interpolation is selected.

@subsubheading math::vector2 & get_d_value(unsigned int n1@comma{} unsigned int n2)
@anchor{_157}

Get modifiable reference to 1st derivative/gradient vector at sample point index (n1@comma{} n2). Only available when data::BicubicDeriv interpolation is selected.

@subsubheading virtual unsigned int get_dimensions() const
@anchor{_158}

This virtual function implements the @code{get_dimensions (@pxref{_224})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Get total number of dimensions

@subsubheading const math::vector2 & get_nearest_d(const math::vector2 &v) const
@anchor{_159}

Get 1st derivative/gradient vector stored at nearest sample point from 2d vector on grid. Only available when data::BicubicDeriv interpolation is selected.

@subsubheading math::vector2 & get_nearest_d(const math::vector2 &v)
@anchor{_160}

Get modifiable reference to 1st derivative/gradient vector stored at nearest sample point from 2d vector on grid. Only available when data::BicubicDeriv interpolation is selected.

@subsubheading double get_nearest_y(const math::vector2 &v) const
@anchor{_161}

Get value stored at nearest sample point from 2d vector on grid

@subsubheading double & get_nearest_y(const math::vector2 &v)
@anchor{_162}

Get modifiable reference to value stored at nearest sample point from 2d vector on grid

@subsubheading const math::vector2 & get_origin() const
@anchor{_163}

Get origin vector

@subsubheading const math::vector2 & get_step() const
@anchor{_164}

Get step values vector

@subsubheading virtual math::range_t get_x_range(unsigned int dimension) const
@anchor{_165}

This virtual function implements the @code{get_x_range (@pxref{_227})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Get minimal and maximal x values on dimension n found in data set

@subsubheading virtual double get_x_value(unsigned int x@comma{} unsigned int dimension) const
@anchor{_166}

This virtual function implements the @code{get_x_value (@pxref{_228})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Get data stored at position n on dimension dim in data set

@subsubheading math::vector2 get_x_value_i(unsigned int n1@comma{} unsigned int n2) const
@anchor{_167}

Get 2d vector on grid of the sample point at index (n1@comma{} n2)

@subsubheading double get_y_value(unsigned int n1@comma{} unsigned int n2) const
@anchor{_168}

Get value stored at sample point index (n1@comma{} n2)

@subsubheading double & get_y_value(unsigned int n1@comma{} unsigned int n2)
@anchor{_169}

Get modifiable reference to value stored at sample point index (n1@comma{} n2)

@subsubheading virtual double get_y_value(const unsigned int n[]) const
@anchor{_170}

This virtual function implements the @code{get_y_value (@pxref{_230})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Get y data stored at position (x0@comma{} x1@comma{} ...) in data set

@subsubheading double interpolate(const math::vector2 &v) const
@anchor{_171}

Interpolate data at given 2d vector point on grid using currently selected interpolation algorithm

@subsubheading virtual double interpolate(const double x[]) const
@anchor{_172}

This virtual function implements the @code{interpolate (@pxref{_231})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Interpolate y value corresponding to given x value(s) in data set.

@subsubheading virtual double interpolate(const double x[]@comma{} unsigned int deriv@comma{} unsigned int dimension) const
@anchor{_173}

This virtual function implements the @code{interpolate (@pxref{_232})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Interpolate y value corresponding to given x value in data set. data may be differentiated several times along the requested dimension. 

@itemize
@item deriv: Differentiation count@comma{} 0 means y value@comma{} 1 means 1st derivative... 
@item dim: Differentiation dimension
@end itemize

@subsubheading math::vector2 interpolate_deriv(const math::vector2 &v) const
@anchor{_174}

Interpolate gradient at given 2d vector point on grid using currently selected interpolation algorithm

@subsubheading void resize(unsigned int n1@comma{} unsigned int n2)
@anchor{_175}

Change grid size by defining new sample counts for each dimensions

@subsubheading void set_all_d(const math::vector2 &deriv = math::vector2(0@comma{}0))
@anchor{_176}

Change all grid points stored gradient. Only available when data::BicubicDeriv interpolation is selected.

@subsubheading void set_all_y(double y = 0.0)
@anchor{_177}

Change all grid points stored values

@subsubheading virtual void set_interpolation(Interpolation i)
@anchor{_178}

This virtual function implements the @code{set_interpolation (@pxref{_233})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Select interpolation method

@subsubheading void set_metrics(const math::vector2 &origin@comma{} const math::vector2 &step)
@anchor{_179}

Set grid origin 2d vector and step values

@page

@heading data::Grid class full member list
@anchor{data_Grid_class_full_member_list}

@subheading Functions

@itemize
@item Grid(unsigned int n1@comma{} unsigned int n2@comma{} const math::vector2 &origin = @emph{[...]}@comma{} const math::vector2 &step = @emph{[...]})
@item ~Grid()
@item virtual unsigned int get_count(unsigned int dimension) const
@item const math::vector2 & get_d_value(unsigned int n1@comma{} unsigned int n2) const
@item math::vector2 & get_d_value(unsigned int n1@comma{} unsigned int n2)
@item virtual unsigned int get_dimensions() const
@item Interpolation get_interpolation()
@item const math::vector2 & get_nearest_d(const math::vector2 &v) const
@item math::vector2 & get_nearest_d(const math::vector2 &v)
@item double get_nearest_y(const math::vector2 &v) const
@item double & get_nearest_y(const math::vector2 &v)
@item const math::vector2 & get_origin() const
@item const math::vector2 & get_step() const
@item unsigned int get_version() const
@item virtual math::range_t get_x_range(unsigned int dimension) const
@item virtual double get_x_value(unsigned int x@comma{} unsigned int dimension) const
@item math::vector2 get_x_value_i(unsigned int n1@comma{} unsigned int n2) const
@item virtual math::range_t get_y_range() const
@item double get_y_value(unsigned int n1@comma{} unsigned int n2) const
@item double & get_y_value(unsigned int n1@comma{} unsigned int n2)
@item virtual double get_y_value(const unsigned int n[]) const
@item double interpolate(const math::vector2 &v) const
@item virtual double interpolate(const double x[]) const
@item virtual double interpolate(const double x[]@comma{} unsigned int deriv@comma{} unsigned int dimension) const
@item math::vector2 interpolate_deriv(const math::vector2 &v) const
@item void resize(unsigned int n1@comma{} unsigned int n2)
@item void set_all_d(const math::vector2 &deriv = @emph{[...]})
@item void set_all_y(double y = @emph{[...]})
@item virtual void set_interpolation(Interpolation i)
@item void set_metrics(const math::vector2 &origin@comma{} const math::vector2 &step)
@end itemize

@page

@heading data::Plot class reference
@anchor{data_Plot_class_reference}

@subheading Declaration

@example
#include <goptical/core/data/Plot>

namespace goptical @{
  namespace data @{
    class Plot;
  @};
@};

@end example

 This class is a member of the data namespace.

@subheading Inheritance

@subheading Description

This class is used to describe a data plot. It contains a list of Plotdata (@pxref{data_Plotdata_class_reference}) objects and describes some plot properties (title@comma{} range@comma{} ...).

Plots can be built from data sets or obtained directly from various analysis functions. They can be rendered on a io::renderer_viewport (@pxref{io_renderer_viewport_class_reference}) object with the draw (@pxref{_183}) function.

@subheading Members

 See also the full member list (@pxref{data_Plot_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item Plot()
@item Plotdata & add_plot_data(const Set &data@comma{} const io::rgb &color = @emph{[...]}@comma{} const std::string &label = @emph{[...]}@comma{} PlotStyleMask style = @emph{[...]})
@item void add_plot_data(Plotdata &data)
@item void draw(io::renderer_viewport &r)
@item void erase_plot_data()
@item void fit_axes_range()
@item io::RendererAxes & get_axes()
@item const io::RendererAxes & get_axes() const
@item unsigned int get_dimensions() const
@item unsigned int get_plot_count() const
@item Plotdata & get_plot_data(unsigned int index)
@item const Plotdata & get_plot_data(unsigned int index) const
@item const std::string & get_title() const
@item math::range_t get_x_data_range(unsigned int dimension = @emph{[...]}) const
@item bool get_xy_swap() const
@item math::range_t get_y_data_range() const
@item void set_color(const io::rgb &color)
@item void set_different_colors()
@item void set_style(PlotStyleMask style)
@item void set_title(const std::string &title)
@item void set_xy_swap(bool doswap)
@end itemize

@subheading Members detail

@subsubheading Plot()
@anchor{_180}

Create a new empty plot

@subsubheading Plotdata & add_plot_data(const Set &data@comma{} const io::rgb &color = io::rgb_red@comma{} const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &label = "data"@comma{} PlotStyleMask style = InterpolatePlot|PointPlot)
@anchor{_181}

Create and add plot data from specified data set.

@subsubheading void add_plot_data(Plotdata &data)
@anchor{_182}

Add plot data

@subsubheading void draw(io::renderer_viewport &r)
@anchor{_183}

draw

@subsubheading void erase_plot_data()
@anchor{_184}

Discard all plot data set

@subsubheading void fit_axes_range()
@anchor{_185}

Set axis position to dataset range

@subsubheading io::RendererAxes & get_axes()
@anchor{_186}

Get plot axes object

@subsubheading const io::RendererAxes & get_axes() const
@anchor{_187}

Get plot axes object

@subsubheading unsigned int get_dimensions() const
@anchor{_188}

Get data sets dimensions@comma{} return 0 if inconsistent

@subsubheading unsigned int get_plot_count() const
@anchor{_189}

Get plot data set count

@subsubheading Plotdata & get_plot_data(unsigned int index)
@anchor{_190}

Get plot data set at given index

@subsubheading const Plotdata & get_plot_data(unsigned int index) const
@anchor{_191}

Get plot data set at given index

@subsubheading const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  & get_title() const
@anchor{_192}

Get plot main title

@subsubheading math::range_t get_x_data_range(unsigned int dimension = 0) const
@anchor{_193}

Get range of x data in sets

@subsubheading bool get_xy_swap() const
@anchor{_194}

Get x and y axis swap state for 2d plots

@subsubheading math::range_t get_y_data_range() const
@anchor{_195}

Get range of y data in sets

@subsubheading void set_color(const io::rgb &color)
@anchor{_196}

Set color for all plots

@subsubheading void set_different_colors()
@anchor{_197}

Automatically choose different colors for each plot

@subsubheading void set_style(PlotStyleMask style)
@anchor{_198}

Set plot style for all plot

@subsubheading void set_title(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &title)
@anchor{_199}

Set plot main title

@subsubheading void set_xy_swap(bool doswap)
@anchor{_200}

Swap x and y axis for 2d plots

@page

@heading data::Plot class full member list
@anchor{data_Plot_class_full_member_list}

@subheading Functions

@itemize
@item Plot()
@item Plotdata & add_plot_data(const Set &data@comma{} const io::rgb &color = @emph{[...]}@comma{} const std::string &label = @emph{[...]}@comma{} PlotStyleMask style = @emph{[...]})
@item void add_plot_data(Plotdata &data)
@item void draw(io::renderer_viewport &r)
@item void erase_plot_data()
@item void fit_axes_range()
@item io::RendererAxes & get_axes()
@item const io::RendererAxes & get_axes() const
@item unsigned int get_dimensions() const
@item unsigned int get_plot_count() const
@item Plotdata & get_plot_data(unsigned int index)
@item const Plotdata & get_plot_data(unsigned int index) const
@item const std::string & get_title() const
@item math::range_t get_x_data_range(unsigned int dimension = @emph{[...]}) const
@item bool get_xy_swap() const
@item math::range_t get_y_data_range() const
@item void set_color(const io::rgb &color)
@item void set_different_colors()
@item void set_style(PlotStyleMask style)
@item void set_title(const std::string &title)
@item void set_xy_swap(bool doswap)
@end itemize

@page

@heading data::Plotdata class reference
@anchor{data_Plotdata_class_reference}

@subheading Declaration

@example
#include <goptical/core/data/Plotdata>

namespace goptical @{
  namespace data @{
    class Plotdata;
  @};
@};

@end example

 This class is a member of the data namespace.

@subheading Description

This class is used to describe a data set as part of a data plot. It contains a pointer to the data set and plotting informations (title@comma{} color@comma{} ...)

@subheading Members

 See also the full member list (@pxref{data_Plotdata_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item Plotdata(const const_ref<Set> &s)
@item void disable_style(PlotStyleMask style)
@item void enable_style(PlotStyleMask style)
@item const io::rgb & get_color() const
@item const std::string & get_label() const
@item const Set & get_set() const
@item PlotStyleMask get_style() const
@item void set_color(const io::rgb &color)
@item void set_label(const std::string &title)
@item void set_style(PlotStyleMask style)
@end itemize

@subheading Members detail

@subsubheading Plotdata(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <Set> &s)
@anchor{_201}

Create a new data plot descriptor which describe the specified dataset.

@subsubheading void disable_style(PlotStyleMask style)
@anchor{_202}

Disable a plotting style

@subsubheading void enable_style(PlotStyleMask style)
@anchor{_203}

Enable a plotting style

@subsubheading const io::rgb & get_color() const
@anchor{_204}

Set data set plotting color

@subsubheading const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  & get_label() const
@anchor{_205}

Get data set plotting label

@subsubheading const Set & get_set() const
@anchor{_206}

Get the described data set

@subsubheading PlotStyleMask get_style() const
@anchor{_207}

Get the plotting style mask

@subsubheading void set_color(const io::rgb &color)
@anchor{_208}

Set data set plotting color

@subsubheading void set_label(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &title)
@anchor{_209}

Set data set plotting label

@subsubheading void set_style(PlotStyleMask style)
@anchor{_210}

Set the plotting style mask

@page

@heading data::Plotdata class full member list
@anchor{data_Plotdata_class_full_member_list}

@subheading Functions

@itemize
@item Plotdata(const const_ref<Set> &s)
@item void disable_style(PlotStyleMask style)
@item void enable_style(PlotStyleMask style)
@item const io::rgb & get_color() const
@item const std::string & get_label() const
@item const Set & get_set() const
@item PlotStyleMask get_style() const
@item void set_color(const io::rgb &color)
@item void set_label(const std::string &title)
@item void set_style(PlotStyleMask style)
@end itemize

@page

@heading data::SampleSet class reference
@anchor{data_SampleSet_class_reference}

@subheading Declaration

@example
#include <goptical/core/data/SampleSet>

namespace goptical @{
  namespace data @{
    class SampleSet;
  @};
@};

@end example

 This class is a member of the data namespace.

@subheading Inheritance

@subheading Description

This class provides a numerical data container where sample values (y) are defined for uniformly distributed (x) values.

Severals interpolation algorithms are available to guess values between defined knots@comma{} see Interpolation (@pxref{_146}).

See also DiscreteSet (@pxref{data_DiscreteSet_class_reference}) class.

@subheading Members

 See also the full member list (@pxref{data_SampleSet_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 19 members inherited from Set1d (@pxref{data_Set1d_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item SampleSet()
@item void clear()
@item virtual unsigned int get_count() const
@item double get_d_value(unsigned int x) const
@item double & get_d_value(unsigned int x)
@item double get_origin() const
@item double get_step() const
@item virtual math::range_t get_x_range() const
@item virtual double get_x_value(unsigned int x) const
@item virtual double get_y_value(unsigned int x) const
@item virtual double & get_y_value(unsigned int x)
@item virtual double interpolate(const double x) const
@item virtual double interpolate(const double x@comma{} unsigned int deriv) const
@item void resize(unsigned int n)
@item virtual void set_interpolation(Interpolation i)
@item void set_metrics(double origin@comma{} double step)
@item void set_value(unsigned int x@comma{} double y@comma{} double d = @emph{[...]})
@item void set_value_near(double x@comma{} double y@comma{} double d = @emph{[...]})
@end itemize

@subheading Members detail

@subsubheading SampleSet()
@anchor{_211}

No documentation available

@page

@heading data::SampleSet class full member list
@anchor{data_SampleSet_class_full_member_list}

@subheading Functions

@itemize
@item SampleSet()
@item void clear()
@item virtual unsigned int get_count(unsigned int dim) const
@item virtual unsigned int get_count() const
@item double get_d_value(unsigned int x) const
@item double & get_d_value(unsigned int x)
@item virtual unsigned int get_dimensions() const
@item Interpolation get_interpolation()
@item double get_origin() const
@item double get_step() const
@item unsigned int get_version() const
@item virtual math::range_t get_x_range(unsigned int dimension) const
@item virtual math::range_t get_x_range() const
@item virtual double get_x_value(unsigned int n@comma{} unsigned int dim) const
@item virtual double get_x_value(unsigned int x) const
@item virtual math::range_t get_y_range() const
@item virtual double get_y_value(const unsigned int x[]) const
@item virtual double get_y_value(unsigned int x) const
@item virtual double & get_y_value(unsigned int x)
@item virtual double interpolate(const double x[]) const
@item virtual double interpolate(const double x[]@comma{} unsigned int deriv@comma{} unsigned int dimension) const
@item virtual double interpolate(const double x) const
@item virtual double interpolate(const double x@comma{} unsigned int deriv) const
@item void resize(unsigned int n)
@item virtual void set_interpolation(Interpolation i)
@item void set_metrics(double origin@comma{} double step)
@item void set_value(unsigned int x@comma{} double y@comma{} double d = @emph{[...]})
@item void set_value_near(double x@comma{} double y@comma{} double d = @emph{[...]})
@end itemize

@page

@heading data::Interpolate1d<data::DiscreteSetBase> internal class members

@subheading Interpolate1d()

No documentation available

@subheading virtual double interpolate(const double x) const
@anchor{_213}

This virtual function implements the @code{interpolate (@pxref{_245})} pure function declared in the @code{Set1d (@pxref{data_Set1d_class_reference})} base abstract class.

@subheading virtual double interpolate(const double x@comma{} unsigned int deriv) const
@anchor{_214}

This virtual function implements the @code{interpolate (@pxref{_246})} pure function declared in the @code{Set1d (@pxref{data_Set1d_class_reference})} base abstract class.

@subheading virtual void set_interpolation(Interpolation i)
@anchor{_215}

This virtual function implements the @code{set_interpolation (@pxref{_233})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

@subheading ~Interpolate1d()

No documentation available

@page

@heading data::Interpolate1d<data::SampleSetBase> internal class members

@subheading Interpolate1d()

No documentation available

@subheading virtual double interpolate(const double x) const
@anchor{_218}

This virtual function implements the @code{interpolate (@pxref{_245})} pure function declared in the @code{Set1d (@pxref{data_Set1d_class_reference})} base abstract class.

@subheading virtual double interpolate(const double x@comma{} unsigned int deriv) const
@anchor{_219}

This virtual function implements the @code{interpolate (@pxref{_246})} pure function declared in the @code{Set1d (@pxref{data_Set1d_class_reference})} base abstract class.

@subheading virtual void set_interpolation(Interpolation i)
@anchor{_220}

This virtual function implements the @code{set_interpolation (@pxref{_233})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

@subheading ~Interpolate1d()

No documentation available

@page

@heading data::Set class reference
@anchor{data_Set_class_reference}

@subheading Declaration

@example
#include <goptical/core/data/Set>

namespace goptical @{
  namespace data @{
    class Set;
  @};
@};

@end example

 This class is a member of the data namespace.

This abstract class contains pure virtuals.

@subheading Inheritance

@subheading Description

This class is a base class for all numerical data sets implementations. It defines an interface to access data in a way independent from data storage and dimensions count.

Each data set implementation may define a alternative specific interface to access their data.

Here x is seen as value used to access the container. Containers with more than one dimension will require x0@comma{} x1@comma{} ...@comma{} xn known parameters to access the stored y value.

@subheading Members

 See also the full member list (@pxref{data_Set_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item virtual ~Set()
@item virtual unsigned int get_count(unsigned int dim = @emph{[...]}) const = 0;
@item virtual unsigned int get_dimensions() const = 0;
@item Interpolation get_interpolation()
@item unsigned int get_version() const
@item virtual math::range_t get_x_range(unsigned int dim = @emph{[...]}) const = 0;
@item virtual double get_x_value(unsigned int n@comma{} unsigned int dim = @emph{[...]}) const = 0;
@item virtual math::range_t get_y_range() const
@item virtual double get_y_value(const unsigned int x[]) const = 0;
@item virtual double interpolate(const double x[]) const = 0;
@item virtual double interpolate(const double x[]@comma{} unsigned int deriv@comma{} unsigned int dim) const = 0;
@item virtual void set_interpolation(Interpolation i) = 0;
@end itemize

@subheading Members detail

@subsubheading virtual ~Set()
@anchor{_222}

No documentation available

@subsubheading virtual unsigned int get_count(unsigned int dim = 0) const = 0;
@anchor{_223}

Get total number of data stored for dimension n in data set

@subsubheading virtual unsigned int get_dimensions() const = 0;
@anchor{_224}

Get total number of dimensions

@subsubheading Interpolation get_interpolation()
@anchor{_225}

Get current interpolation method

@subsubheading unsigned int get_version() const
@anchor{_226}

Return version number which is incremented on each data set change/clear

@subsubheading virtual math::range_t get_x_range(unsigned int dim = 0) const = 0;
@anchor{_227}

Get minimal and maximal x values on dimension n found in data set

@subsubheading virtual double get_x_value(unsigned int n@comma{} unsigned int dim = 0) const = 0;
@anchor{_228}

Get data stored at position n on dimension dim in data set

@subsubheading virtual math::range_t get_y_range() const
@anchor{_229}

Get minimal and maximal y values found in data set

@subsubheading virtual double get_y_value(const unsigned int x[]) const = 0;
@anchor{_230}

Get y data stored at position (x0@comma{} x1@comma{} ...) in data set

@subsubheading virtual double interpolate(const double x[]) const = 0;
@anchor{_231}

Interpolate y value corresponding to given x value(s) in data set.

@subsubheading virtual double interpolate(const double x[]@comma{} unsigned int deriv@comma{} unsigned int dim) const = 0;
@anchor{_232}

Interpolate y value corresponding to given x value in data set. data may be differentiated several times along the requested dimension. 

@itemize
@item deriv: Differentiation count@comma{} 0 means y value@comma{} 1 means 1st derivative... 
@item dim: Differentiation dimension
@end itemize

@subsubheading virtual void set_interpolation(Interpolation i) = 0;
@anchor{_233}

Select interpolation method

@page

@heading data::Set class full member list
@anchor{data_Set_class_full_member_list}

@subheading Functions

@itemize
@item virtual ~Set()
@item virtual unsigned int get_count(unsigned int dim = @emph{[...]}) const = 0;
@item virtual unsigned int get_dimensions() const = 0;
@item Interpolation get_interpolation()
@item unsigned int get_version() const
@item virtual math::range_t get_x_range(unsigned int dim = @emph{[...]}) const = 0;
@item virtual double get_x_value(unsigned int n@comma{} unsigned int dim = @emph{[...]}) const = 0;
@item virtual math::range_t get_y_range() const
@item virtual double get_y_value(const unsigned int x[]) const = 0;
@item virtual double interpolate(const double x[]) const = 0;
@item virtual double interpolate(const double x[]@comma{} unsigned int deriv@comma{} unsigned int dim) const = 0;
@item virtual void set_interpolation(Interpolation i) = 0;
@end itemize

@page

@heading data::Set1d class reference
@anchor{data_Set1d_class_reference}

@subheading Declaration

@example
#include <goptical/core/data/Set1d>

namespace goptical @{
  namespace data @{
    class Set1d;
  @};
@};

@end example

 This class is a member of the data namespace.

This abstract class contains pure virtuals.

@subheading Inheritance

@subheading Description
Base class for 1d y = f(x) numerical data set
@subheading Members

 See also the full member list (@pxref{data_Set1d_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 12 members inherited from Set (@pxref{data_Set_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item virtual ~Set1d()
@item virtual unsigned int get_count() const = 0;
@item virtual unsigned int get_count(unsigned int dim) const
@item virtual unsigned int get_dimensions() const
@item virtual math::range_t get_x_range() const = 0;
@item virtual math::range_t get_x_range(unsigned int dimension) const
@item virtual double get_x_value(unsigned int n) const = 0;
@item virtual double get_x_value(unsigned int n@comma{} unsigned int dim) const
@item virtual double get_y_value(unsigned int n) const = 0;
@item virtual double & get_y_value(unsigned int n) = 0;
@item virtual double get_y_value(const unsigned int x[]) const
@item virtual double interpolate(const double x) const = 0;
@item virtual double interpolate(const double x@comma{} unsigned int deriv) const = 0;
@item virtual double interpolate(const double x[]) const
@item virtual double interpolate(const double x[]@comma{} unsigned int deriv@comma{} unsigned int dimension) const
@end itemize

@subheading Members detail

@subsubheading virtual ~Set1d()
@anchor{_234}

No documentation available

@subsubheading virtual unsigned int get_count() const = 0;
@anchor{_235}

Get total number of data stored in data set

@subsubheading virtual unsigned int get_count(unsigned int dim) const
@anchor{_236}

This virtual function implements the @code{get_count (@pxref{_223})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Get total number of data stored for dimension n in data set

@subsubheading virtual unsigned int get_dimensions() const
@anchor{_237}

This virtual function implements the @code{get_dimensions (@pxref{_224})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Get total number of dimensions

@subsubheading virtual math::range_t get_x_range() const = 0;
@anchor{_238}

Get minimal and maximal x values on found in data set

@subsubheading virtual math::range_t get_x_range(unsigned int dimension) const
@anchor{_239}

This virtual function implements the @code{get_x_range (@pxref{_227})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Get minimal and maximal x values on dimension n found in data set

@subsubheading virtual double get_x_value(unsigned int n) const = 0;
@anchor{_240}

Get x data at index n in data set

@subsubheading virtual double get_x_value(unsigned int n@comma{} unsigned int dim) const
@anchor{_241}

This virtual function implements the @code{get_x_value (@pxref{_228})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Get data stored at position n on dimension dim in data set

@subsubheading virtual double get_y_value(unsigned int n) const = 0;
@anchor{_242}

Get y data stored at index n in data set

@subsubheading virtual double & get_y_value(unsigned int n) = 0;
@anchor{_243}

Get modifiable reference to y data stored at index n in data set

@subsubheading virtual double get_y_value(const unsigned int x[]) const
@anchor{_244}

This virtual function implements the @code{get_y_value (@pxref{_230})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Get y data stored at position (x0@comma{} x1@comma{} ...) in data set

@subsubheading virtual double interpolate(const double x) const = 0;
@anchor{_245}

Interpolate y value corresponding to given x value in data set.

@subsubheading virtual double interpolate(const double x@comma{} unsigned int deriv) const = 0;
@anchor{_246}

Interpolate y value corresponding to given x value in data set. data may be differentiated several times. 

@itemize
@item deriv: Differentiation count@comma{} 0 means y value@comma{} 1 means 1st derivative...
@end itemize

@subsubheading virtual double interpolate(const double x[]) const
@anchor{_247}

This virtual function implements the @code{interpolate (@pxref{_231})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Interpolate y value corresponding to given x value(s) in data set.

@subsubheading virtual double interpolate(const double x[]@comma{} unsigned int deriv@comma{} unsigned int dimension) const
@anchor{_248}

This virtual function implements the @code{interpolate (@pxref{_232})} pure function declared in the @code{Set (@pxref{data_Set_class_reference})} base abstract class.

Documentation inherited from base class:

Interpolate y value corresponding to given x value in data set. data may be differentiated several times along the requested dimension. 

@itemize
@item deriv: Differentiation count@comma{} 0 means y value@comma{} 1 means 1st derivative... 
@item dim: Differentiation dimension
@end itemize

@page

@heading data::Set1d class full member list
@anchor{data_Set1d_class_full_member_list}

@subheading Functions

@itemize
@item virtual ~Set1d()
@item virtual unsigned int get_count() const = 0;
@item virtual unsigned int get_count(unsigned int dim) const
@item virtual unsigned int get_dimensions() const
@item Interpolation get_interpolation()
@item unsigned int get_version() const
@item virtual math::range_t get_x_range() const = 0;
@item virtual math::range_t get_x_range(unsigned int dimension) const
@item virtual double get_x_value(unsigned int n) const = 0;
@item virtual double get_x_value(unsigned int n@comma{} unsigned int dim) const
@item virtual math::range_t get_y_range() const
@item virtual double get_y_value(unsigned int n) const = 0;
@item virtual double & get_y_value(unsigned int n) = 0;
@item virtual double get_y_value(const unsigned int x[]) const
@item virtual double interpolate(const double x) const = 0;
@item virtual double interpolate(const double x@comma{} unsigned int deriv) const = 0;
@item virtual double interpolate(const double x[]) const
@item virtual double interpolate(const double x[]@comma{} unsigned int deriv@comma{} unsigned int dimension) const
@item virtual void set_interpolation(Interpolation i) = 0;
@end itemize

@page

@heading data::DiscreteSetBase internal class members

@subheading DiscreteSetBase()

No documentation available

@subheading ~DiscreteSetBase()

No documentation available

@subheading void add_data(double x@comma{} double y@comma{} double yp = 0.0)
@anchor{_251}

Insert data pair in data set. If a pair with the same x value exists@comma{} it will be replaced by the new value. Derivative value may be provided as well.

@subheading void clear()
@anchor{_252}

Clear all data

@subheading virtual unsigned int get_count() const
@anchor{_253}

This virtual function implements the @code{get_count (@pxref{_235})} pure function declared in the @code{Set1d (@pxref{data_Set1d_class_reference})} base abstract class.

Documentation inherited from base class:

Get total number of data stored in data set

@subheading double get_d_value(unsigned int x) const
@anchor{_254}

Get stored derivative value at index x

@subheading double & get_d_value(unsigned int x)
@anchor{_255}

Get modifiable reference to stored derivative value at index x

@subheading virtual math::range_t get_x_range() const
@anchor{_256}

This virtual function implements the @code{get_x_range (@pxref{_238})} pure function declared in the @code{Set1d (@pxref{data_Set1d_class_reference})} base abstract class.

Documentation inherited from base class:

Get minimal and maximal x values on found in data set

@subheading virtual double get_x_value(unsigned int x) const
@anchor{_257}

This virtual function implements the @code{get_x_value (@pxref{_240})} pure function declared in the @code{Set1d (@pxref{data_Set1d_class_reference})} base abstract class.

Documentation inherited from base class:

Get x data at index n in data set

@subheading virtual double get_y_value(unsigned int x) const
@anchor{_258}

This virtual function implements the @code{get_y_value (@pxref{_242})} pure function declared in the @code{Set1d (@pxref{data_Set1d_class_reference})} base abstract class.

Documentation inherited from base class:

Get y data stored at index n in data set

@subheading virtual double & get_y_value(unsigned int x)
@anchor{_259}

This virtual function implements the @code{get_y_value (@pxref{_243})} pure function declared in the @code{Set1d (@pxref{data_Set1d_class_reference})} base abstract class.

Documentation inherited from base class:

Get modifiable reference to y data stored at index n in data set

@subheading void reserve( @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/,,size_t}  n)
@anchor{_260}

Reserve data entries

@page

@heading data::Interpolate1d internal class members

@subheading Interpolate1d()

No documentation available

@subheading ~Interpolate1d()

No documentation available

@subheading double interpolate(const double x) const

No documentation available

@subheading double interpolate(const double x@comma{} unsigned int deriv) const

No documentation available

@subheading void set_interpolation(Interpolation i)

No documentation available

@page

@heading data::SampleSetBase internal class members

@subheading SampleSetBase()

No documentation available

@subheading ~SampleSetBase()

No documentation available

@subheading void clear()
@anchor{_268}

Clear all data

@subheading virtual unsigned int get_count() const
@anchor{_269}

This virtual function implements the @code{get_count (@pxref{_235})} pure function declared in the @code{Set1d (@pxref{data_Set1d_class_reference})} base abstract class.

Documentation inherited from base class:

Get total number of data stored in data set

@subheading double get_d_value(unsigned int x) const
@anchor{_270}

Get stored derivative value at index x

@subheading double & get_d_value(unsigned int x)
@anchor{_271}

Get modifiable reference to stored derivative value at index x

@subheading double get_origin() const
@anchor{_272}

Get x value of first sample

@subheading double get_step() const
@anchor{_273}

Get step size between consecutive x values

@subheading virtual math::range_t get_x_range() const
@anchor{_274}

This virtual function implements the @code{get_x_range (@pxref{_238})} pure function declared in the @code{Set1d (@pxref{data_Set1d_class_reference})} base abstract class.

Documentation inherited from base class:

Get minimal and maximal x values on found in data set

@subheading virtual double get_x_value(unsigned int x) const
@anchor{_275}

This virtual function implements the @code{get_x_value (@pxref{_240})} pure function declared in the @code{Set1d (@pxref{data_Set1d_class_reference})} base abstract class.

Documentation inherited from base class:

Get x data at index n in data set

@subheading virtual double get_y_value(unsigned int x) const
@anchor{_276}

This virtual function implements the @code{get_y_value (@pxref{_242})} pure function declared in the @code{Set1d (@pxref{data_Set1d_class_reference})} base abstract class.

Documentation inherited from base class:

Get y data stored at index n in data set

@subheading virtual double & get_y_value(unsigned int x)
@anchor{_277}

This virtual function implements the @code{get_y_value (@pxref{_243})} pure function declared in the @code{Set1d (@pxref{data_Set1d_class_reference})} base abstract class.

Documentation inherited from base class:

Get modifiable reference to y data stored at index n in data set

@subheading void resize(unsigned int n)
@anchor{_278}

Set number of samples

@subheading void set_metrics(double origin@comma{} double step)
@anchor{_279}

Set x origin and step values

@subheading void set_value(unsigned int x@comma{} double y@comma{} double d = 0.0)
@anchor{_280}

Set y value and its derivative at index x

@subheading void set_value_near(double x@comma{} double y@comma{} double d = 0.0)
@anchor{_281}

Set y value and its derivative at nearest x value

@page

@heading Design namespace reference
@anchor{Design_namespace_reference}

@subheading Description
Design module classes
@subheading Members

@subsubheading Namespace

@itemize
@item telescope
@end itemize

@page

@heading Design::telescope namespace reference
@anchor{Design_telescope_namespace_reference}

@subheading Description
telescope designs
@subheading Members

@subsubheading Types

@itemize
@item template class Cassegrain
@item enum CassegrainType
@item class Newton
@item class telescope
@end itemize

@subheading Members detail

@subsubheading enum CassegrainType
@anchor{_282}

Specify Cassegrain telescope type

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item ClassicalCassegrain @tab 
@item RitcheyChretien @tab 
@item DallKirkham @tab 
@item PressmannCamichel @tab 
@end multitable

@page

@heading Design::telescope::Cassegrain class reference
@anchor{Design_telescope_Cassegrain_class_reference}

@subheading Declaration

@example
#include <goptical/core/Design/telescope/Cassegrain>

namespace goptical @{
  namespace Design @{
    namespace telescope @{
      template <CassegrainType type> class Cassegrain;
    @};
  @};
@};

@end example

 This class is a member of the telescope namespace.

@subheading Inheritance

@subheading Description

This class is a group of optical elements forming a Cassegrain telescope. Optical elements are adjusted as needed from prescribed telescope parameters.

The CassegrainType (@pxref{_282}) enum specifies type of Cassegrain telescope.

@subheading Members

 See also the full member list (@pxref{Design_telescope_Cassegrain_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 60 members inherited from telescope (@pxref{Design_telescope_telescope_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Cassegrain(const math::vectorPair3 &p@comma{} double focal@comma{} double diameter@comma{} double magnification = @emph{[...]}@comma{} double bwd = @emph{[...]}@comma{} double field_angle = @emph{[...]})
@item virtual double get_bwd() const
@item virtual double get_diameter() const
@item virtual double get_field_angle() const
@item virtual double get_focal() const
@item virtual math::vectorPair3 get_focal_plane() const
@item double get_magnification() const
@item double get_mirrors_separation() const
@item const sys::mirror & get_primary() const
@item sys::mirror & get_primary()
@item double get_primary_conic() const
@item const sys::mirror & get_secondary() const
@item sys::mirror & get_secondary()
@item double get_secondary_conic() const
@item double get_secondary_diameter() const
@item virtual double get_unvignetted_image_diameter() const
@item virtual void set_bwd(double e)
@item virtual void set_diameter(double d1)
@item virtual void set_field_angle(double fa)
@item virtual void set_focal(double f)
@item void set_magnification(double m)
@item void set_secondary_diameter(double d2)
@end itemize

@subheading Members detail

@subsubheading Cassegrain(const math::vectorPair3 &p@comma{} double focal@comma{} double diameter@comma{} double magnification = 3.@comma{} double bwd = 100@comma{} double field_angle = 1.)
@anchor{_283}

No documentation available

@subsubheading virtual double get_bwd() const
@anchor{_284}

This virtual function implements the @code{get_bwd (@pxref{_325})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Get telescope back working distance

@subsubheading virtual double get_diameter() const
@anchor{_285}

This virtual function implements the @code{get_diameter (@pxref{_326})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Get telescope primary mirror diameter

@subsubheading virtual double get_field_angle() const
@anchor{_286}

This virtual function implements the @code{get_field_angle (@pxref{_327})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Get telescope field angle

@subsubheading virtual double get_focal() const
@anchor{_287}

This virtual function implements the @code{get_focal (@pxref{_328})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Get telescope focal length

@subsubheading virtual math::vectorPair3 get_focal_plane() const
@anchor{_288}

This virtual function implements the @code{get_focal_plane (@pxref{_329})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Get telescope focal plane in parent coordinate system

@subsubheading double get_magnification() const
@anchor{_289}

Get telescope secondary mirror magnification

@subsubheading double get_mirrors_separation() const
@anchor{_290}

Get distance between mirrors

@subsubheading const sys::mirror & get_primary() const
@anchor{_291}

Get telescope primary mirror component

@subsubheading sys::mirror & get_primary()
@anchor{_292}

Get telescope primary mirror component

@subsubheading double get_primary_conic() const
@anchor{_293}

Get primary mirror schwarzschild constant

@subsubheading const sys::mirror & get_secondary() const
@anchor{_294}

Get telescope secondary mirror component

@subsubheading sys::mirror & get_secondary()
@anchor{_295}

Get telescope secondary mirror component

@subsubheading double get_secondary_conic() const
@anchor{_296}

Get secondary mirror schwarzschild constant

@subsubheading double get_secondary_diameter() const
@anchor{_297}

Get telescope secondary mirror diameter

@subsubheading virtual double get_unvignetted_image_diameter() const
@anchor{_298}

This virtual function implements the @code{get_unvignetted_image_diameter (@pxref{_330})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Get diameter of unvignetted image on focal plane

@subsubheading virtual void set_bwd(double e)
@anchor{_299}

This virtual function implements the @code{set_bwd (@pxref{_331})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Set telescope back working distance

@subsubheading virtual void set_diameter(double d1)
@anchor{_300}

This virtual function implements the @code{set_diameter (@pxref{_332})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Set telescope primary mirror diameter

@subsubheading virtual void set_field_angle(double fa)
@anchor{_301}

This virtual function implements the @code{set_field_angle (@pxref{_333})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Set telescope field angle

@subsubheading virtual void set_focal(double f)
@anchor{_302}

This virtual function implements the @code{set_focal (@pxref{_334})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Set telescope focal length

@subsubheading void set_magnification(double m)
@anchor{_303}

Set telescope secondary mirror magnification

@subsubheading void set_secondary_diameter(double d2)
@anchor{_304}

Set telescope secondary mirror diameter

@page

@heading Design::telescope::Cassegrain class full member list
@anchor{Design_telescope_Cassegrain_class_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } element_list_t
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item Cassegrain(const math::vectorPair3 &p@comma{} double focal@comma{} double diameter@comma{} double magnification = @emph{[...]}@comma{} double bwd = @emph{[...]}@comma{} double field_angle = @emph{[...]})
@item void add(const ref<sys::Element> &e)
@item template bool contains(const X *x) const
@item void draw_2d(io::Renderer &r) const
@item void draw_2d_fit(io::renderer_viewport &r@comma{} bool keep_aspect = @emph{[...]}) const
@item void draw_3d(io::Renderer &r) const
@item void draw_3d_fit(io::renderer_viewport &r@comma{} double z_offset = @emph{[...]}) const
@item template void enable_single(const X &e)
@item template X * find() const
@item virtual math::vectorPair3 get_bounding_box() const
@item virtual double get_bwd() const
@item virtual double get_diameter() const
@item math::vector3 get_direction(const sys::Element &e) const
@item math::vector3 get_direction() const
@item const sys::Container::element_list_t & get_element_list() const
@item template void get_elements(const delegate<void(const X&)> &d) const
@item template void get_elements(const delegate<void(X&)> &d)
@item virtual double get_field_angle() const
@item virtual double get_focal() const
@item virtual math::vectorPair3 get_focal_plane() const
@item const math::Transform<3> & get_global_transform() const
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item double get_magnification() const
@item double get_mirrors_separation() const
@item sys::Group * get_parent() const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const sys::Element &e) const
@item math::vector3 get_position(const sys::Element &e) const
@item math::vector3 get_position() const
@item const sys::mirror & get_primary() const
@item sys::mirror & get_primary()
@item double get_primary_conic() const
@item const sys::mirror & get_secondary() const
@item sys::mirror & get_secondary()
@item double get_secondary_conic() const
@item double get_secondary_diameter() const
@item sys::system * get_system() const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const sys::Element &e) const
@item const math::Transform<3> & get_transform_from(const sys::Element *e) const
@item const math::Transform<3> & get_transform_to(const sys::Element &e) const
@item const math::Transform<3> & get_transform_to(const sys::Element *e) const
@item virtual double get_unvignetted_image_diameter() const
@item unsigned int get_version() const
@item unsigned int id() const
@item bool is_enabled() const
@item virtual void print(std::ostream &o) const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void remove(sys::Element &e)
@item void rotate(double x@comma{} double y@comma{} double z)
@item virtual void set_bwd(double e)
@item virtual void set_diameter(double d1)
@item void set_direction(const math::vector3 &v)
@item void set_enable_state(bool enabled)
@item virtual void set_field_angle(double fa)
@item virtual void set_focal(double f)
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_magnification(double m)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &v)
@item void set_secondary_diameter(double d2)
@item void set_transform(const math::Transform<3> &t)
@item void update_version()
@end itemize

@page

@heading Design::telescope::Newton class reference
@anchor{Design_telescope_Newton_class_reference}

@subheading Declaration

@example
#include <goptical/core/Design/telescope/Newton>

namespace goptical @{
  namespace Design @{
    namespace telescope @{
      class Newton;
    @};
  @};
@};

@end example

 This class is a member of the telescope namespace.

@subheading Inheritance

@subheading Description

This class is a group of optical elements forming a Newton telescope. Optical elements are adjusted as needed from prescribed telescope parameters.

See also A newton telescope with corrector (@pxref{A newton telescope with corrector}) section.

@subheading Members

 See also the full member list (@pxref{Design_telescope_Newton_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 60 members inherited from telescope (@pxref{Design_telescope_telescope_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Newton(const math::vectorPair3 &p@comma{} double focal@comma{} double diameter@comma{} double bwd = @emph{[...]}@comma{} double field_angle = @emph{[...]})
@item virtual double get_bwd() const
@item virtual double get_diameter() const
@item virtual double get_field_angle() const
@item virtual double get_focal() const
@item virtual math::vectorPair3 get_focal_plane() const
@item sys::mirror & get_primary()
@item const sys::mirror & get_primary() const
@item sys::mirror & get_secondary()
@item const sys::mirror & get_secondary() const
@item double get_secondary_major_axis() const
@item double get_secondary_minor_axis() const
@item double get_secondary_offset() const
@item virtual double get_unvignetted_image_diameter() const
@item virtual void set_bwd(double bwd)
@item virtual void set_diameter(double diameter)
@item virtual void set_field_angle(double fa)
@item virtual void set_focal(double focal)
@item void set_secondary_minor_axis(double diameter)
@end itemize

@subheading Members detail

@subsubheading Newton(const math::vectorPair3 &p@comma{} double focal@comma{} double diameter@comma{} double bwd = 100@comma{} double field_angle = 1.)
@anchor{_305}

No documentation available

@subsubheading virtual double get_bwd() const
@anchor{_306}

This virtual function implements the @code{get_bwd (@pxref{_325})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Get telescope back working distance

@subsubheading virtual double get_diameter() const
@anchor{_307}

This virtual function implements the @code{get_diameter (@pxref{_326})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Get telescope primary mirror diameter

@subsubheading virtual double get_field_angle() const
@anchor{_308}

This virtual function implements the @code{get_field_angle (@pxref{_327})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Get telescope field angle

@subsubheading virtual double get_focal() const
@anchor{_309}

This virtual function implements the @code{get_focal (@pxref{_328})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Get telescope focal length

@subsubheading virtual math::vectorPair3 get_focal_plane() const
@anchor{_310}

This virtual function implements the @code{get_focal_plane (@pxref{_329})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Get telescope focal plane in parent coordinate system

@subsubheading sys::mirror & get_primary()
@anchor{_311}

Get telescope primary mirror component

@subsubheading const sys::mirror & get_primary() const
@anchor{_312}

Get telescope primary mirror component

@subsubheading sys::mirror & get_secondary()
@anchor{_313}

Get telescope secondary mirror component

@subsubheading const sys::mirror & get_secondary() const
@anchor{_314}

Get telescope secondary mirror component

@subsubheading double get_secondary_major_axis() const
@anchor{_315}

Get secondary mirror major axis length

@subsubheading double get_secondary_minor_axis() const
@anchor{_316}

Get secondary mirror minor axis length

@subsubheading double get_secondary_offset() const
@anchor{_317}

Get secondary mirror offset

@subsubheading virtual double get_unvignetted_image_diameter() const
@anchor{_318}

This virtual function implements the @code{get_unvignetted_image_diameter (@pxref{_330})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Get diameter of unvignetted image on focal plane

@subsubheading virtual void set_bwd(double bwd)
@anchor{_319}

This virtual function implements the @code{set_bwd (@pxref{_331})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Set telescope back working distance

@subsubheading virtual void set_diameter(double diameter)
@anchor{_320}

This virtual function implements the @code{set_diameter (@pxref{_332})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Set telescope primary mirror diameter

@subsubheading virtual void set_field_angle(double fa)
@anchor{_321}

This virtual function implements the @code{set_field_angle (@pxref{_333})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Set telescope field angle

@subsubheading virtual void set_focal(double focal)
@anchor{_322}

This virtual function implements the @code{set_focal (@pxref{_334})} pure function declared in the @code{telescope (@pxref{Design_telescope_telescope_class_reference})} base abstract class.

Documentation inherited from base class:

Set telescope focal length

@subsubheading void set_secondary_minor_axis(double diameter)
@anchor{_323}

Set telescope secondary mirror diameter

@page

@heading Design::telescope::Newton class full member list
@anchor{Design_telescope_Newton_class_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } element_list_t
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item Newton(const math::vectorPair3 &p@comma{} double focal@comma{} double diameter@comma{} double bwd = @emph{[...]}@comma{} double field_angle = @emph{[...]})
@item void add(const ref<sys::Element> &e)
@item template bool contains(const X *x) const
@item void draw_2d(io::Renderer &r) const
@item void draw_2d_fit(io::renderer_viewport &r@comma{} bool keep_aspect = @emph{[...]}) const
@item void draw_3d(io::Renderer &r) const
@item void draw_3d_fit(io::renderer_viewport &r@comma{} double z_offset = @emph{[...]}) const
@item template void enable_single(const X &e)
@item template X * find() const
@item virtual math::vectorPair3 get_bounding_box() const
@item virtual double get_bwd() const
@item virtual double get_diameter() const
@item math::vector3 get_direction(const sys::Element &e) const
@item math::vector3 get_direction() const
@item const sys::Container::element_list_t & get_element_list() const
@item template void get_elements(const delegate<void(const X&)> &d) const
@item template void get_elements(const delegate<void(X&)> &d)
@item virtual double get_field_angle() const
@item virtual double get_focal() const
@item virtual math::vectorPair3 get_focal_plane() const
@item const math::Transform<3> & get_global_transform() const
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item sys::Group * get_parent() const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const sys::Element &e) const
@item math::vector3 get_position(const sys::Element &e) const
@item math::vector3 get_position() const
@item sys::mirror & get_primary()
@item const sys::mirror & get_primary() const
@item sys::mirror & get_secondary()
@item const sys::mirror & get_secondary() const
@item double get_secondary_major_axis() const
@item double get_secondary_minor_axis() const
@item double get_secondary_offset() const
@item sys::system * get_system() const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const sys::Element &e) const
@item const math::Transform<3> & get_transform_from(const sys::Element *e) const
@item const math::Transform<3> & get_transform_to(const sys::Element &e) const
@item const math::Transform<3> & get_transform_to(const sys::Element *e) const
@item virtual double get_unvignetted_image_diameter() const
@item unsigned int get_version() const
@item unsigned int id() const
@item bool is_enabled() const
@item virtual void print(std::ostream &o) const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void remove(sys::Element &e)
@item void rotate(double x@comma{} double y@comma{} double z)
@item virtual void set_bwd(double bwd)
@item virtual void set_diameter(double diameter)
@item void set_direction(const math::vector3 &v)
@item void set_enable_state(bool enabled)
@item virtual void set_field_angle(double fa)
@item virtual void set_focal(double focal)
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &v)
@item void set_secondary_minor_axis(double diameter)
@item void set_transform(const math::Transform<3> &t)
@item void update_version()
@end itemize

@page

@heading Design::telescope::telescope class reference
@anchor{Design_telescope_telescope_class_reference}

@subheading Declaration

@example
#include <goptical/core/Design/telescope/telescope>

namespace goptical @{
  namespace Design @{
    namespace telescope @{
      class telescope;
    @};
  @};
@};

@end example

 This class is a member of the telescope namespace.

This abstract class contains pure virtuals.

@subheading Inheritance

@subheading Description
Base class for telescope optical designs
@subheading Members

 See also the full member list (@pxref{Design_telescope_telescope_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 51 members inherited from sys::Group (@pxref{sys_Group_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item telescope(const math::vectorPair3 &p)
@item virtual double get_bwd() const = 0;
@item virtual double get_diameter() const = 0;
@item virtual double get_field_angle() const = 0;
@item virtual double get_focal() const = 0;
@item virtual math::vectorPair3 get_focal_plane() const = 0;
@item virtual double get_unvignetted_image_diameter() const = 0;
@item virtual void set_bwd(double bwd) = 0;
@item virtual void set_diameter(double diameter) = 0;
@item virtual void set_field_angle(double bwd) = 0;
@item virtual void set_focal(double focal) = 0;
@end itemize

@subheading Members detail

@subsubheading telescope(const math::vectorPair3 &p)
@anchor{_324}

No documentation available

@subsubheading virtual double get_bwd() const = 0;
@anchor{_325}

Get telescope back working distance

@subsubheading virtual double get_diameter() const = 0;
@anchor{_326}

Get telescope primary mirror diameter

@subsubheading virtual double get_field_angle() const = 0;
@anchor{_327}

Get telescope field angle

@subsubheading virtual double get_focal() const = 0;
@anchor{_328}

Get telescope focal length

@subsubheading virtual math::vectorPair3 get_focal_plane() const = 0;
@anchor{_329}

Get telescope focal plane in parent coordinate system

@subsubheading virtual double get_unvignetted_image_diameter() const = 0;
@anchor{_330}

Get diameter of unvignetted image on focal plane

@subsubheading virtual void set_bwd(double bwd) = 0;
@anchor{_331}

Set telescope back working distance

@subsubheading virtual void set_diameter(double diameter) = 0;
@anchor{_332}

Set telescope primary mirror diameter

@subsubheading virtual void set_field_angle(double bwd) = 0;
@anchor{_333}

Set telescope field angle

@subsubheading virtual void set_focal(double focal) = 0;
@anchor{_334}

Set telescope focal length

@page

@heading Design::telescope::telescope class full member list
@anchor{Design_telescope_telescope_class_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } element_list_t
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item telescope(const math::vectorPair3 &p)
@item void add(const ref<sys::Element> &e)
@item template bool contains(const X *x) const
@item void draw_2d(io::Renderer &r) const
@item void draw_2d_fit(io::renderer_viewport &r@comma{} bool keep_aspect = @emph{[...]}) const
@item void draw_3d(io::Renderer &r) const
@item void draw_3d_fit(io::renderer_viewport &r@comma{} double z_offset = @emph{[...]}) const
@item template void enable_single(const X &e)
@item template X * find() const
@item virtual math::vectorPair3 get_bounding_box() const
@item virtual double get_bwd() const = 0;
@item virtual double get_diameter() const = 0;
@item math::vector3 get_direction(const sys::Element &e) const
@item math::vector3 get_direction() const
@item const sys::Container::element_list_t & get_element_list() const
@item template void get_elements(const delegate<void(const X&)> &d) const
@item template void get_elements(const delegate<void(X&)> &d)
@item virtual double get_field_angle() const = 0;
@item virtual double get_focal() const = 0;
@item virtual math::vectorPair3 get_focal_plane() const = 0;
@item const math::Transform<3> & get_global_transform() const
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item sys::Group * get_parent() const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const sys::Element &e) const
@item math::vector3 get_position(const sys::Element &e) const
@item math::vector3 get_position() const
@item sys::system * get_system() const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const sys::Element &e) const
@item const math::Transform<3> & get_transform_from(const sys::Element *e) const
@item const math::Transform<3> & get_transform_to(const sys::Element &e) const
@item const math::Transform<3> & get_transform_to(const sys::Element *e) const
@item virtual double get_unvignetted_image_diameter() const = 0;
@item unsigned int get_version() const
@item unsigned int id() const
@item bool is_enabled() const
@item virtual void print(std::ostream &o) const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void remove(sys::Element &e)
@item void rotate(double x@comma{} double y@comma{} double z)
@item virtual void set_bwd(double bwd) = 0;
@item virtual void set_diameter(double diameter) = 0;
@item void set_direction(const math::vector3 &v)
@item void set_enable_state(bool enabled)
@item virtual void set_field_angle(double bwd) = 0;
@item virtual void set_focal(double focal) = 0;
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &v)
@item void set_transform(const math::Transform<3> &t)
@item void update_version()
@end itemize

@page

@heading Error class reference
@anchor{Error_class_reference}

@subheading Declaration

@example
#include <goptical/core/Error>

namespace goptical @{
  class Error;
@};

@end example

 This class is a member of the <goptical/core namespace.

@subheading Inheritance

@subheading Description
Base class used for <goptical/core exceptions.
@subheading Members

 See also the full member list (@pxref{Error_class_full_member_list}) section for this class.

@subsubheading Function

@itemize
@item Error(const std::string &msg = @emph{[...]})
@end itemize

@subheading Members detail

@subsubheading Error(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &msg = "")
@anchor{_335}

No documentation available

@page

@heading Error class full member list
@anchor{Error_class_full_member_list}

@subheading Function

@itemize
@item Error(const std::string &msg = @emph{[...]})
@end itemize

@page

@heading io namespace reference
@anchor{io_namespace_reference}

@subheading Description
data input/output and graphical rendering
@subheading Members

@subsubheading Types

@itemize
@item class ImportOslo
@item class ImportZemax
@item class Renderer
@item class RendererDxf
@item class RendererGd
@item class RendererOpengl
@item class renderer_pl_plot
@item class renderer_svg
@item class RendererX11
@item class RendererX3d
@item class Export
@item class Import
@item enum IntensityMode
@item enum PointStyle
@item enum RayColorMode
@item class RendererAxes
@item class renderer_viewport
@item struct rgb
@item enum Style
@item enum TextAlignMask
@end itemize

@subsubheading Functions

@itemize
@item TextAlignMask operator&(TextAlignMask a@comma{} TextAlignMask b)
@item TextAlignMask operator|(TextAlignMask a@comma{} TextAlignMask b)
@item TextAlignMask operator~(TextAlignMask a)
@end itemize

@subsubheading Constants

@itemize
@item const rgb rgb_black
@item const rgb rgb_blue
@item const rgb rgb_cyan
@item const rgb rgb_gray
@item const rgb rgb_green
@item const rgb rgb_magenta
@item const rgb rgb_red
@item const rgb rgb_table[]
@item const size_t rgb_table_size
@item const rgb rgb_white
@item const rgb rgb_yellow
@end itemize

@subheading Members detail

@subsubheading enum IntensityMode
@anchor{_336}

Specifies light ray intensity rendering mode

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item IntensityIgnore @tab 
light ray intensity is ignored@comma{} no blending is performed while rendering ray

@item IntensityShade @tab 
light ray intensity is used to blend rendered ray

@item IntensityLogShade @tab 
light ray intensity logarithm is used to blend rendered ray. This enable faint rays to remain visible.

@end multitable

@subsubheading enum PointStyle
@anchor{_337}

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item PointStyleDot @tab 
@item PointStyleCross @tab 
@item PointStyleRound @tab 
@item PointStyleSquare @tab 
@item PointStyleTriangle @tab 
@end multitable

@subsubheading enum RayColorMode
@anchor{_338}

Specifies light ray color rendering

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item RayColorWavelen @tab 
Compute ray color from its wavelength

@item RayColorFixed @tab 
Use fixed ray color

@end multitable

@subsubheading enum Style
@anchor{_339}

Specifies rendering elements which can have modified colors and style

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item StyleBackground @tab 
@item StyleForeground @tab 
@item StyleRay @tab 
@item StyleSurface @tab 
@item StyleGlass @tab 
@item StyleLast @tab 
@end multitable

@subsubheading enum TextAlignMask
@anchor{_340}

Specifies rendered text alignment

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item TextAlignCenter @tab 
Vertically centered

@item TextAlignLeft @tab 
@item TextAlignRight @tab 
@item TextAlignTop @tab 
@item TextAlignBottom @tab 
@item TextAlignMiddle @tab 
Horizontally centered

@end multitable

@subsubheading TextAlignMask operator&(TextAlignMask a@comma{} TextAlignMask b)
@anchor{_341}

Bitwise and operation for use on TextAlignMask (@pxref{_340}) enum.

@subsubheading TextAlignMask operator|(TextAlignMask a@comma{} TextAlignMask b)
@anchor{_342}

Bitwise or operation for use on TextAlignMask (@pxref{_340}) enum.

@subsubheading TextAlignMask operator~(TextAlignMask a)
@anchor{_343}

Bitwise not operation for use on TextAlignMask (@pxref{_340}) enum.

@subsubheading const rgb rgb_black
@anchor{_344}

No documentation available

@subsubheading const rgb rgb_blue
@anchor{_345}

No documentation available

@subsubheading const rgb rgb_cyan
@anchor{_346}

No documentation available

@subsubheading const rgb rgb_gray
@anchor{_347}

No documentation available

@subsubheading const rgb rgb_green
@anchor{_348}

No documentation available

@subsubheading const rgb rgb_magenta
@anchor{_349}

No documentation available

@subsubheading const rgb rgb_red
@anchor{_350}

No documentation available

@subsubheading const rgb rgb_table[]
@anchor{_351}

This table contains some common colors. 

See also rgb_table_size (@pxref{_352}) variable.

@subsubheading const  @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/,,size_t}  rgb_table_size = 9
@anchor{_352}

This constant specifies the number of entries in rgb_table (@pxref{_351}). 

@subsubheading const rgb rgb_white
@anchor{_353}

No documentation available

@subsubheading const rgb rgb_yellow
@anchor{_354}

No documentation available

@page

@heading io::ImportOslo class reference
@anchor{io_ImportOslo_class_reference}

@subheading Declaration

@example
#include <goptical/core/io/ImportOslo>

namespace goptical @{
  namespace io @{
    class ImportOslo;
  @};
@};

@end example

 This class is a member of the io namespace.

@subheading Description

This class implements an Oslo glass catalog loader.

@subheading Members

 See also the full member list (@pxref{io_ImportOslo_class_full_member_list}) section for this class.

@subsubheading Static function

@itemize
@item static material::Catalog & import_catalog(const std::string &filename)
@end itemize

@subheading Members detail

@subsubheading static material::Catalog & import_catalog(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &filename)
@anchor{_355}

import Oslo glass catalog file (.glc)

@page

@heading io::ImportOslo class full member list
@anchor{io_ImportOslo_class_full_member_list}

@subheading Static function

@itemize
@item static material::Catalog & import_catalog(const std::string &filename)
@end itemize

@page

@heading io::ImportZemax class reference
@anchor{io_ImportZemax_class_reference}

@subheading Declaration

This class is flagged as experimental.

@example
#include <goptical/core/io/ImportZemax>

namespace goptical @{
  namespace io @{
    class ImportZemax;
  @};
@};

@end example

 This class is a member of the io namespace.

@subheading Description

This class implements a zemax optical design file and glass catalog loader.

@subheading Members

 See also the full member list (@pxref{io_ImportZemax_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item ref<material::Catalog> get_catalog(const std::string &name)
@item ref<material::Catalog> import_catalog(const std::string &name)
@item ref<material::Catalog> import_catalog(const std::string &path@comma{} const std::string &name)
@item ref<material::Catalog> import_catalog_file(const std::string &path)
@item ref<sys::system> import_design(const std::string &filename)
@item ref<material::Dielectric> import_table_glass(const std::string &filename)
@item void set_catalog_path(const std::string &path)
@end itemize

@subheading Members detail

@subsubheading  @uref{http://diaxen.ssji.net/dpp/ref_class_reference.html,,ref} <material::Catalog> get_catalog(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &name)
@anchor{_356}

This function is flagged as experimental.

Get already imported catalog

@subsubheading  @uref{http://diaxen.ssji.net/dpp/ref_class_reference.html,,ref} <material::Catalog> import_catalog(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &name)
@anchor{_357}

This function is flagged as experimental.

Import Zemax ascii glass catalog@comma{} guess filename from default path and name

@subsubheading  @uref{http://diaxen.ssji.net/dpp/ref_class_reference.html,,ref} <material::Catalog> import_catalog(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &path@comma{} const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &name)
@anchor{_358}

This function is flagged as experimental.

Import Zemax ascii glass catalog file (@samp{.agf)}

@subsubheading  @uref{http://diaxen.ssji.net/dpp/ref_class_reference.html,,ref} <material::Catalog> import_catalog_file(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &path)
@anchor{_359}

This function is flagged as experimental.

Import Zemax ascii glass catalog file (@samp{.agf).} Guess catalog name from file name

@subsubheading  @uref{http://diaxen.ssji.net/dpp/ref_class_reference.html,,ref} <sys::system> import_design(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &filename)
@anchor{_360}

This function is flagged as experimental.

@subsubheading  @uref{http://diaxen.ssji.net/dpp/ref_class_reference.html,,ref} <material::Dielectric> import_table_glass(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &filename)
@anchor{_361}

This function is flagged as experimental.

Import Zemax table glass material file (@samp{.ztg)}

@subsubheading void set_catalog_path(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &path)
@anchor{_362}

This function is flagged as experimental.

Set glass catalogs default path

@page

@heading io::ImportZemax class full member list
@anchor{io_ImportZemax_class_full_member_list}

@subheading Functions

@itemize
@item ref<material::Catalog> get_catalog(const std::string &name)
@item ref<material::Catalog> import_catalog(const std::string &name)
@item ref<material::Catalog> import_catalog(const std::string &path@comma{} const std::string &name)
@item ref<material::Catalog> import_catalog_file(const std::string &path)
@item ref<sys::system> import_design(const std::string &filename)
@item ref<material::Dielectric> import_table_glass(const std::string &filename)
@item void set_catalog_path(const std::string &path)
@end itemize

@page

@heading io::Renderer class reference
@anchor{io_Renderer_class_reference}

@subheading Declaration

@example
#include <goptical/core/io/Renderer>

namespace goptical @{
  namespace io @{
    class Renderer;
  @};
@};

@end example

 This class is a member of the io namespace.

This abstract class contains pure virtuals.

@subheading Inheritance

@subheading Description

This class define the interface for graphical rendering drivers and provide a default implementation for some functions.

@subheading Members

 See also the full member list (@pxref{io_Renderer_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item Renderer()
@item virtual ~Renderer()
@item double get_feature_size() const
@item const rgb & get_style_color(Style s) const
@item const rgb & rgb_background() const
@item const rgb & rgb_foreground() const
@item void set_feature_size(double feature_size)
@item void set_ray_color_mode(RayColorMode m)
@item void set_ray_intensity_mode(IntensityMode m)
@item void set_style_color(Style s@comma{} const rgb &rgb)
@end itemize

@subheading Members detail

@subsubheading Renderer()
@anchor{_363}

No documentation available

@subsubheading virtual ~Renderer()
@anchor{_364}

No documentation available

@subsubheading double get_feature_size() const
@anchor{_365}

 Get size of lines and triangles used to render curved shapes..

See also set_feature_size (@pxref{_369}) function.

@subsubheading const rgb & get_style_color(Style s) const
@anchor{_366}

Get rgb color from style specifier

@subsubheading const rgb & rgb_background() const
@anchor{_367}

Get foreground rgb color

@subsubheading const rgb & rgb_foreground() const
@anchor{_368}

Get foreground rgb color

@subsubheading void set_feature_size(double feature_size)
@anchor{_369}

 Set size of lines and triangles used to render curved shapes..

See also get_feature_size (@pxref{_365}) function.

@subsubheading void set_ray_color_mode(RayColorMode m)
@anchor{_370}

Set color mode for light ray drawing. Default is RayColorWavelen (@pxref{_338}).

@subsubheading void set_ray_intensity_mode(IntensityMode m)
@anchor{_371}

Set light ray intensity display mode

@subsubheading void set_style_color(Style s@comma{} const rgb &rgb)
@anchor{_372}

Set rgb color for given style specifier. 

Some drivers do not support changing background color after initialization.

@page

@heading io::Renderer class full member list
@anchor{io_Renderer_class_full_member_list}

@subheading Functions

@itemize
@item Renderer()
@item virtual ~Renderer()
@item double get_feature_size() const
@item const rgb & get_style_color(Style s) const
@item const rgb & rgb_background() const
@item const rgb & rgb_foreground() const
@item void set_feature_size(double feature_size)
@item void set_ray_color_mode(RayColorMode m)
@item void set_ray_intensity_mode(IntensityMode m)
@item void set_style_color(Style s@comma{} const rgb &rgb)
@end itemize

@page

@heading io::RendererDxf class reference
@anchor{io_RendererDxf_class_reference}

@subheading Declaration

This class is flagged as experimental.

@example
#include <goptical/core/io/RendererDxf>

namespace goptical @{
  namespace io @{
    class RendererDxf;
  @};
@};

@end example

 This class is a member of the io namespace.

@subheading Inheritance

@subheading Description

This class implements a 2d and 3d Dxf CAD format output driver. It requires the  @uref{http://www.coin3d.org/lib/dime,,Dime}  library to compile.

@subheading Members

 See also the full member list (@pxref{io_RendererDxf_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 10 members inherited from Renderer (@pxref{io_Renderer_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item RendererDxf()
@item RendererDxf(const char *filename)
@item ~RendererDxf()
@item unsigned int add_layer(std::string name)
@item void use_layer(unsigned int id)
@item void write(const std::string &filename)
@end itemize

@subheading Members detail

@subsubheading RendererDxf()
@anchor{_373}

This constructor is flagged as experimental.

Create a DXF renderer

@subsubheading RendererDxf(const char *filename)
@anchor{_374}

This constructor is flagged as experimental.

Create a DXF renderer@comma{} output will be written to given filename when the renderer is destroyed.

@subsubheading ~RendererDxf()
@anchor{_375}

This destructor is flagged as experimental.

@subsubheading unsigned int add_layer(std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  name)
@anchor{_376}

This function is flagged as experimental.

Add a new layer in dxf file and return its index

@subsubheading void use_layer(unsigned int id)
@anchor{_377}

This function is flagged as experimental.

Set current layer

@subsubheading void write(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &filename)
@anchor{_378}

This function is flagged as experimental.

Save output to a DXF file

@page

@heading io::RendererDxf class full member list
@anchor{io_RendererDxf_class_full_member_list}

@subheading Functions

@itemize
@item RendererDxf()
@item RendererDxf(const char *filename)
@item ~RendererDxf()
@item unsigned int add_layer(std::string name)
@item double get_feature_size() const
@item const rgb & get_style_color(Style s) const
@item const rgb & rgb_background() const
@item const rgb & rgb_foreground() const
@item void set_feature_size(double feature_size)
@item void set_ray_color_mode(RayColorMode m)
@item void set_ray_intensity_mode(IntensityMode m)
@item void set_style_color(Style s@comma{} const rgb &rgb)
@item void use_layer(unsigned int id)
@item void write(const std::string &filename)
@end itemize

@page

@heading io::RendererGd class reference
@anchor{io_RendererGd_class_reference}

@subheading Declaration

@example
#include <goptical/core/io/RendererGd>

namespace goptical @{
  namespace io @{
    class RendererGd;
  @};
@};

@end example

 This class is a member of the io namespace.

@subheading Inheritance

@subheading Description

This class implements a Gd graphic output driver. It needs the gd library to compile.

@subheading Members

 See also the full member list (@pxref{io_RendererGd_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 31 members inherited from renderer_viewport (@pxref{io_renderer_viewport_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item RendererGd(gdimagePtr im@comma{} const rgb &background = @emph{[...]}@comma{} gdFontPtr font = @emph{[...]}@comma{} const char *TFfontlist = @emph{[...]})
@item RendererGd(const char *filename@comma{} unsigned int width = @emph{[...]}@comma{} unsigned int height = @emph{[...]}@comma{} const rgb &background = @emph{[...]}@comma{} const char *TFfontlist = @emph{[...]})
@item RendererGd(unsigned int width = @emph{[...]}@comma{} unsigned int height = @emph{[...]}@comma{} const rgb &background = @emph{[...]}@comma{} const char *TFfontlist = @emph{[...]})
@item ~RendererGd()
@item virtual void clear()
@item void set_brush_thickness(unsigned int t)
@item void write(const std::string &filename)
@end itemize

@subheading Members detail

@subsubheading RendererGd(gdimagePtr im@comma{} const rgb &background = rgb_white@comma{} gdFontPtr font = 0@comma{} const char *TFfontlist = 0)
@anchor{_379}

Create a new gd renderer using specified gd resources

@subsubheading RendererGd(const char *filename@comma{} unsigned int width = 800@comma{} unsigned int height = 600@comma{} const rgb &background = rgb_white@comma{} const char *TFfontlist = 0)
@anchor{_380}

Create a new gd renderer with given resolution@comma{} png output will be written to file on renderer destruction.

@subsubheading RendererGd(unsigned int width = 800@comma{} unsigned int height = 600@comma{} const rgb &background = rgb_white@comma{} const char *TFfontlist = 0)
@anchor{_381}

Create a new gd renderer with given resolution

@subsubheading ~RendererGd()
@anchor{_382}

No documentation available

@subsubheading virtual void clear()
@anchor{_383}

This virtual function overrides the @code{clear} virtual function defined in the @code{renderer_viewport (@pxref{io_renderer_viewport_class_reference})} base abstract class for internal purposes.

Clear current image buffer

@subsubheading void set_brush_thickness(unsigned int t)
@anchor{_384}

No documentation available

@subsubheading void write(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &filename)
@anchor{_385}

Write image to file in png format

@page

@heading io::RendererGd class full member list
@anchor{io_RendererGd_class_full_member_list}

@subheading Functions

@itemize
@item RendererGd(gdimagePtr im@comma{} const rgb &background = @emph{[...]}@comma{} gdFontPtr font = @emph{[...]}@comma{} const char *TFfontlist = @emph{[...]})
@item RendererGd(const char *filename@comma{} unsigned int width = @emph{[...]}@comma{} unsigned int height = @emph{[...]}@comma{} const rgb &background = @emph{[...]}@comma{} const char *TFfontlist = @emph{[...]})
@item RendererGd(unsigned int width = @emph{[...]}@comma{} unsigned int height = @emph{[...]}@comma{} const rgb &background = @emph{[...]}@comma{} const char *TFfontlist = @emph{[...]})
@item ~RendererGd()
@item virtual void clear()
@item virtual void draw_pages_grid(const rgb &rgb = @emph{[...]})
@item double get_feature_size() const
@item double get_fov() const
@item const rgb & get_style_color(Style s) const
@item const math::vectorPair2 & get_window() const
@item const rgb & rgb_background() const
@item const rgb & rgb_foreground() const
@item void set_brush_thickness(unsigned int t)
@item void set_camera_direction(const math::vector3 &dir)
@item void set_camera_position(const math::vector3 &pos)
@item void set_feature_size(double feature_size)
@item void set_fov(double fov)
@item void set_margin(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin(double width@comma{} double height)
@item void set_margin_output(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin_output(double width@comma{} double height)
@item void set_margin_ratio(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin_ratio(double width@comma{} double height)
@item void set_numeric_format(std::ios_base::fmtflags format@comma{} unsigned int precision)
@item virtual void set_page(unsigned int page)
@item virtual void set_page_layout(unsigned int cols@comma{} unsigned int rows)
@item void set_ray_color_mode(RayColorMode m)
@item void set_ray_intensity_mode(IntensityMode m)
@item void set_style_color(Style s@comma{} const rgb &rgb)
@item virtual void set_window(const math::vector2 &center@comma{} const math::vector2 &size@comma{} bool keep_aspect = @emph{[...]})
@item void set_window(const math::vectorPair2 &window@comma{} bool keep_aspect = @emph{[...]})
@item void set_window(const math::vector2 &center@comma{} double radius@comma{} bool keep_aspect = @emph{[...]})
@item void write(const std::string &filename)
@end itemize

@page

@heading io::RendererOpengl class reference
@anchor{io_RendererOpengl_class_reference}

@subheading Declaration

@example
#include <goptical/core/io/RendererOpengl>

namespace goptical @{
  namespace io @{
    class RendererOpengl;
  @};
@};

@end example

 This class is a member of the io namespace.

@subheading Inheritance

@subheading Description

This class implements an Opengl graphic output driver. It needs the opengl library to compile.

@subheading Members

 See also the full member list (@pxref{io_RendererOpengl_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 31 members inherited from renderer_viewport (@pxref{io_renderer_viewport_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item RendererOpengl(double near@comma{} double far@comma{} double width = @emph{[...]}@comma{} double height = @emph{[...]}@comma{} const rgb &background = @emph{[...]})
@item void set_z_range(double near@comma{} double far)
@end itemize

@subsubheading Static functions

@itemize
@item static void apply_transform(const math::Transform<3> &t)
@item static void get_transform(GLenum name@comma{} math::Transform<3> &t)
@item static void glColor(const rgb &rgb)
@item static void glNormal(const math::vector3 &v)
@item static void glVertex(const math::vector2 &v)
@item static void glVertex(const math::vector3 &v)
@end itemize

@subheading Members detail

@subsubheading RendererOpengl(double near@comma{} double far@comma{} double width = 800@comma{} double height = 600@comma{} const rgb &background = rgb_black)
@anchor{_386}

No documentation available

@subsubheading static void apply_transform(const math::Transform<3> &t)
@anchor{_387}

No documentation available

@subsubheading static void get_transform(GLenum name@comma{} math::Transform<3> &t)
@anchor{_388}

No documentation available

@subsubheading static void glColor(const rgb &rgb)
@anchor{_389}

No documentation available

@subsubheading static void glNormal(const math::vector3 &v)
@anchor{_390}

No documentation available

@subsubheading static void glVertex(const math::vector2 &v)
@anchor{_391}

No documentation available

@subsubheading static void glVertex(const math::vector3 &v)
@anchor{_392}

No documentation available

@subsubheading void set_z_range(double near@comma{} double far)
@anchor{_393}

No documentation available

@page

@heading io::RendererOpengl class full member list
@anchor{io_RendererOpengl_class_full_member_list}

@subheading Functions

@itemize
@item RendererOpengl(double near@comma{} double far@comma{} double width = @emph{[...]}@comma{} double height = @emph{[...]}@comma{} const rgb &background = @emph{[...]})
@item virtual void draw_pages_grid(const rgb &rgb = @emph{[...]})
@item double get_feature_size() const
@item double get_fov() const
@item const rgb & get_style_color(Style s) const
@item const math::vectorPair2 & get_window() const
@item const rgb & rgb_background() const
@item const rgb & rgb_foreground() const
@item void set_camera_direction(const math::vector3 &dir)
@item void set_camera_position(const math::vector3 &pos)
@item void set_feature_size(double feature_size)
@item void set_fov(double fov)
@item void set_margin(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin(double width@comma{} double height)
@item void set_margin_output(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin_output(double width@comma{} double height)
@item void set_margin_ratio(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin_ratio(double width@comma{} double height)
@item void set_numeric_format(std::ios_base::fmtflags format@comma{} unsigned int precision)
@item virtual void set_page(unsigned int page)
@item virtual void set_page_layout(unsigned int cols@comma{} unsigned int rows)
@item void set_ray_color_mode(RayColorMode m)
@item void set_ray_intensity_mode(IntensityMode m)
@item void set_style_color(Style s@comma{} const rgb &rgb)
@item virtual void set_window(const math::vector2 &center@comma{} const math::vector2 &size@comma{} bool keep_aspect = @emph{[...]})
@item void set_window(const math::vectorPair2 &window@comma{} bool keep_aspect = @emph{[...]})
@item void set_window(const math::vector2 &center@comma{} double radius@comma{} bool keep_aspect = @emph{[...]})
@item void set_z_range(double near@comma{} double far)
@end itemize

@subheading Static functions

@itemize
@item static void apply_transform(const math::Transform<3> &t)
@item static void get_transform(GLenum name@comma{} math::Transform<3> &t)
@item static void glColor(const rgb &rgb)
@item static void glNormal(const math::vector3 &v)
@item static void glVertex(const math::vector2 &v)
@item static void glVertex(const math::vector3 &v)
@end itemize

@page

@heading io::renderer_pl_plot class reference
@anchor{io_renderer_pl_plot_class_reference}

@subheading Declaration

@example
#include <goptical/core/io/renderer_pl_plot>

namespace goptical @{
  namespace io @{
    class renderer_pl_plot;
  @};
@};

@end example

 This class is a member of the io namespace.

@subheading Inheritance

@subheading Description

This class implements a Plplot graphic output driver. It needs the plplot library to compile.

@subheading Members

 See also the full member list (@pxref{io_renderer_pl_plot_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 31 members inherited from renderer_viewport (@pxref{io_renderer_viewport_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item renderer_pl_plot(plstream *pls)
@item renderer_pl_plot(const char *device@comma{} const char *filename@comma{} unsigned int width = @emph{[...]}@comma{} unsigned int height = @emph{[...]}@comma{} const rgb &background = @emph{[...]})
@item ~renderer_pl_plot()
@item plstream * get_pls()
@item virtual void set_page(unsigned int page)
@item virtual void set_page_layout(unsigned int cols@comma{} unsigned int rows)
@end itemize

@subheading Members detail

@subsubheading renderer_pl_plot(plstream *pls)
@anchor{_394}

Initialize renderer from existing plplot context

@subsubheading renderer_pl_plot(const char *device@comma{} const char *filename@comma{} unsigned int width = 800@comma{} unsigned int height = 600@comma{} const rgb &background = rgb_white)
@anchor{_395}

Create a plplot renderer with specified output size

@subsubheading ~renderer_pl_plot()
@anchor{_396}

No documentation available

@subsubheading plstream * get_pls()
@anchor{_397}

get plplot context object

@subsubheading virtual void set_page(unsigned int page)
@anchor{_398}

This virtual function overrides the @code{set_page (@pxref{_475})} virtual function defined in the @code{renderer_viewport (@pxref{io_renderer_viewport_class_reference})} base abstract class.

Documentation inherited from base class:

Select current page when multiple pages layout is in use. 

See also set_page_layout (@pxref{_476}) function.

@subsubheading virtual void set_page_layout(unsigned int cols@comma{} unsigned int rows)
@anchor{_399}

This virtual function overrides the @code{set_page_layout (@pxref{_476})} virtual function defined in the @code{renderer_viewport (@pxref{io_renderer_viewport_class_reference})} base abstract class.

Documentation inherited from base class:

This function can be used to setup a pages grid. Current output page must be selected with set_page (@pxref{_475}).

@page

@heading io::renderer_pl_plot class full member list
@anchor{io_renderer_pl_plot_class_full_member_list}

@subheading Functions

@itemize
@item renderer_pl_plot(plstream *pls)
@item renderer_pl_plot(const char *device@comma{} const char *filename@comma{} unsigned int width = @emph{[...]}@comma{} unsigned int height = @emph{[...]}@comma{} const rgb &background = @emph{[...]})
@item ~renderer_pl_plot()
@item virtual void draw_pages_grid(const rgb &rgb = @emph{[...]})
@item double get_feature_size() const
@item double get_fov() const
@item plstream * get_pls()
@item const rgb & get_style_color(Style s) const
@item const math::vectorPair2 & get_window() const
@item const rgb & rgb_background() const
@item const rgb & rgb_foreground() const
@item void set_camera_direction(const math::vector3 &dir)
@item void set_camera_position(const math::vector3 &pos)
@item void set_feature_size(double feature_size)
@item void set_fov(double fov)
@item void set_margin(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin(double width@comma{} double height)
@item void set_margin_output(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin_output(double width@comma{} double height)
@item void set_margin_ratio(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin_ratio(double width@comma{} double height)
@item void set_numeric_format(std::ios_base::fmtflags format@comma{} unsigned int precision)
@item virtual void set_page(unsigned int page)
@item virtual void set_page_layout(unsigned int cols@comma{} unsigned int rows)
@item void set_ray_color_mode(RayColorMode m)
@item void set_ray_intensity_mode(IntensityMode m)
@item void set_style_color(Style s@comma{} const rgb &rgb)
@item virtual void set_window(const math::vector2 &center@comma{} const math::vector2 &size@comma{} bool keep_aspect = @emph{[...]})
@item void set_window(const math::vectorPair2 &window@comma{} bool keep_aspect = @emph{[...]})
@item void set_window(const math::vector2 &center@comma{} double radius@comma{} bool keep_aspect = @emph{[...]})
@end itemize

@page

@heading io::renderer_svg class reference
@anchor{io_renderer_svg_class_reference}

@subheading Declaration

@example
#include <goptical/core/io/renderer_svg>

namespace goptical @{
  namespace io @{
    class renderer_svg;
  @};
@};

@end example

 This class is a member of the io namespace.

@subheading Inheritance

@subheading Description

This class implements a SVG graphic output driver.

@subheading Members

 See also the full member list (@pxref{io_renderer_svg_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 31 members inherited from renderer_viewport (@pxref{io_renderer_viewport_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item renderer_svg(double width = @emph{[...]}@comma{} double height = @emph{[...]}@comma{} const rgb &background = @emph{[...]})
@item renderer_svg(const char *filename@comma{} double width = @emph{[...]}@comma{} double height = @emph{[...]}@comma{} const rgb &background = @emph{[...]})
@item ~renderer_svg()
@item void write(std::ostream &s)
@end itemize

@subheading Members detail

@subsubheading renderer_svg(double width = 800@comma{} double height = 600@comma{} const rgb &background = rgb_white)
@anchor{_400}

Create a new svg renderer with given resolution. The write (@pxref{_403}) function must be used to write svg to output stream.

@subsubheading renderer_svg(const char *filename@comma{} double width = 800@comma{} double height = 600@comma{} const rgb &background = rgb_white)
@anchor{_401}

Create a new svg renderer with given resolution and viewport window. Svg output will be written to given filename when the renderer object is destroyed.

@subsubheading ~renderer_svg()
@anchor{_402}

No documentation available

@subsubheading void write(std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  &s)
@anchor{_403}

Write svg output to given stream.

@page

@heading io::renderer_svg class full member list
@anchor{io_renderer_svg_class_full_member_list}

@subheading Functions

@itemize
@item renderer_svg(double width = @emph{[...]}@comma{} double height = @emph{[...]}@comma{} const rgb &background = @emph{[...]})
@item renderer_svg(const char *filename@comma{} double width = @emph{[...]}@comma{} double height = @emph{[...]}@comma{} const rgb &background = @emph{[...]})
@item ~renderer_svg()
@item virtual void draw_pages_grid(const rgb &rgb = @emph{[...]})
@item double get_feature_size() const
@item double get_fov() const
@item const rgb & get_style_color(Style s) const
@item const math::vectorPair2 & get_window() const
@item const rgb & rgb_background() const
@item const rgb & rgb_foreground() const
@item virtual void set_2d_size(double width@comma{} double height)
@item void set_camera_direction(const math::vector3 &dir)
@item void set_camera_position(const math::vector3 &pos)
@item void set_feature_size(double feature_size)
@item void set_fov(double fov)
@item void set_margin(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin(double width@comma{} double height)
@item void set_margin_output(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin_output(double width@comma{} double height)
@item void set_margin_ratio(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin_ratio(double width@comma{} double height)
@item void set_numeric_format(std::ios_base::fmtflags format@comma{} unsigned int precision)
@item virtual void set_page(unsigned int page)
@item virtual void set_page_layout(unsigned int cols@comma{} unsigned int rows)
@item void set_ray_color_mode(RayColorMode m)
@item void set_ray_intensity_mode(IntensityMode m)
@item void set_style_color(Style s@comma{} const rgb &rgb)
@item virtual void set_window(const math::vector2 &center@comma{} const math::vector2 &size@comma{} bool keep_aspect = @emph{[...]})
@item void set_window(const math::vectorPair2 &window@comma{} bool keep_aspect = @emph{[...]})
@item void set_window(const math::vector2 &center@comma{} double radius@comma{} bool keep_aspect = @emph{[...]})
@item void write(std::ostream &s)
@end itemize

@page

@heading io::RendererX11 class reference
@anchor{io_RendererX11_class_reference}

@subheading Declaration

@example
#include <goptical/core/io/RendererX11>

namespace goptical @{
  namespace io @{
    class RendererX11;
  @};
@};

@end example

 This class is a member of the io namespace.

@subheading Inheritance

@subheading Description

This class implements a X11 graphic output driver.

@subheading Members

 See also the full member list (@pxref{io_RendererX11_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 31 members inherited from renderer_viewport (@pxref{io_renderer_viewport_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item RendererX11(unsigned int width = @emph{[...]}@comma{} unsigned int height = @emph{[...]}@comma{} const rgb &background = @emph{[...]}@comma{} Display *disp = @emph{[...]}@comma{} int src = @emph{[...]}@comma{} Window win = @emph{[...]}@comma{} GC gc = @emph{[...]})
@item ~RendererX11()
@item Display * get_disp() const
@item GC get_gc() const
@item int get_scr() const
@item Window get_win() const
@end itemize

@subheading Members detail

@subsubheading RendererX11(unsigned int width = 800@comma{} unsigned int height = 600@comma{} const rgb &background = rgb_white@comma{} Display *disp = 0@comma{} int src = -1@comma{} Window win = -1@comma{} GC gc = 0)
@anchor{_404}

No documentation available

@subsubheading ~RendererX11()
@anchor{_405}

No documentation available

@subsubheading Display * get_disp() const
@anchor{_406}

 Get X11 display.

See also set_disp.

@subsubheading GC get_gc() const
@anchor{_407}

 Get X11 graphics context.

See also set_gc.

@subsubheading int get_scr() const
@anchor{_408}

 Get X11 screen.

See also set_scr.

@subsubheading Window get_win() const
@anchor{_409}

 Get X11 window.

See also set_win.

@page

@heading io::RendererX11 class full member list
@anchor{io_RendererX11_class_full_member_list}

@subheading Functions

@itemize
@item RendererX11(unsigned int width = @emph{[...]}@comma{} unsigned int height = @emph{[...]}@comma{} const rgb &background = @emph{[...]}@comma{} Display *disp = @emph{[...]}@comma{} int src = @emph{[...]}@comma{} Window win = @emph{[...]}@comma{} GC gc = @emph{[...]})
@item ~RendererX11()
@item virtual void draw_pages_grid(const rgb &rgb = @emph{[...]})
@item Display * get_disp() const
@item double get_feature_size() const
@item double get_fov() const
@item GC get_gc() const
@item int get_scr() const
@item const rgb & get_style_color(Style s) const
@item Window get_win() const
@item const math::vectorPair2 & get_window() const
@item const rgb & rgb_background() const
@item const rgb & rgb_foreground() const
@item virtual void set_2d_size(double width@comma{} double height)
@item void set_camera_direction(const math::vector3 &dir)
@item void set_camera_position(const math::vector3 &pos)
@item void set_feature_size(double feature_size)
@item void set_fov(double fov)
@item void set_margin(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin(double width@comma{} double height)
@item void set_margin_output(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin_output(double width@comma{} double height)
@item void set_margin_ratio(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin_ratio(double width@comma{} double height)
@item void set_numeric_format(std::ios_base::fmtflags format@comma{} unsigned int precision)
@item virtual void set_page(unsigned int page)
@item virtual void set_page_layout(unsigned int cols@comma{} unsigned int rows)
@item void set_ray_color_mode(RayColorMode m)
@item void set_ray_intensity_mode(IntensityMode m)
@item void set_style_color(Style s@comma{} const rgb &rgb)
@item virtual void set_window(const math::vector2 &center@comma{} const math::vector2 &size@comma{} bool keep_aspect = @emph{[...]})
@item void set_window(const math::vectorPair2 &window@comma{} bool keep_aspect = @emph{[...]})
@item void set_window(const math::vector2 &center@comma{} double radius@comma{} bool keep_aspect = @emph{[...]})
@end itemize

@page

@heading io::RendererX3d class reference
@anchor{io_RendererX3d_class_reference}

@subheading Declaration

This class is flagged as experimental.

@example
#include <goptical/core/io/RendererX3d>

namespace goptical @{
  namespace io @{
    class RendererX3d;
  @};
@};

@end example

 This class is a member of the io namespace.

@subheading Inheritance

@subheading Description

This class implements an  @uref{http://en.wikipedia.org/wiki/X3D,,X3d}  graphic output driver.

@subheading Members

 See also the full member list (@pxref{io_RendererX3d_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 10 members inherited from Renderer (@pxref{io_Renderer_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item RendererX3d(const rgb &background = @emph{[...]})
@item RendererX3d(const char *filename@comma{} const rgb &background = @emph{[...]})
@item ~RendererX3d()
@item void clear()
@item void flush()
@item void write(std::ostream &s)
@end itemize

@subheading Members detail

@subsubheading RendererX3d(const rgb &background = rgb_white)
@anchor{_410}

This constructor is flagged as experimental.

Create a new X3d renderer. The write (@pxref{_415}) function must be used to write x3d to output stream.

@subsubheading RendererX3d(const char *filename@comma{} const rgb &background = rgb_white)
@anchor{_411}

This constructor is flagged as experimental.

Create a new X3d renderer. X3d output will be written to given filename when the renderer object is destroyed.

@subsubheading ~RendererX3d()
@anchor{_412}

This destructor is flagged as experimental.

@subsubheading void clear()
@anchor{_413}

This function is flagged as experimental.

@subsubheading void flush()
@anchor{_414}

This function is flagged as experimental.

@subsubheading void write(std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  &s)
@anchor{_415}

This function is flagged as experimental.

Write svg output to given stream.

@page

@heading io::RendererX3d class full member list
@anchor{io_RendererX3d_class_full_member_list}

@subheading Functions

@itemize
@item RendererX3d(const rgb &background = @emph{[...]})
@item RendererX3d(const char *filename@comma{} const rgb &background = @emph{[...]})
@item ~RendererX3d()
@item void clear()
@item void flush()
@item double get_feature_size() const
@item const rgb & get_style_color(Style s) const
@item const rgb & rgb_background() const
@item const rgb & rgb_foreground() const
@item void set_feature_size(double feature_size)
@item void set_ray_color_mode(RayColorMode m)
@item void set_ray_intensity_mode(IntensityMode m)
@item void set_style_color(Style s@comma{} const rgb &rgb)
@item void write(std::ostream &s)
@end itemize

@page

@heading io::Export class reference
@anchor{io_Export_class_reference}

@subheading Declaration

@example
#include <goptical/core/io/Export>

namespace goptical @{
  namespace io @{
    class Export;
  @};
@};

@end example

 This class is a member of the io namespace.

This abstract class contains pure virtuals.

@subheading Description
File export class interface
@subheading Members

 See also the full member list (@pxref{io_Export_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item virtual void export_catalog(const material::Catalog &catalog@comma{} const std::string &filename) = 0;
@item virtual void export_design(const sys::system &sys@comma{} const std::string &filename) = 0;
@end itemize

@subheading Members detail

@subsubheading virtual void export_catalog(const material::Catalog &catalog@comma{} const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &filename) = 0;
@anchor{_416}

Export material catalog to file

@subsubheading virtual void export_design(const sys::system &sys@comma{} const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &filename) = 0;
@anchor{_417}

Export optical design to file

@page

@heading io::Export class full member list
@anchor{io_Export_class_full_member_list}

@subheading Functions

@itemize
@item virtual void export_catalog(const material::Catalog &catalog@comma{} const std::string &filename) = 0;
@item virtual void export_design(const sys::system &sys@comma{} const std::string &filename) = 0;
@end itemize

@page

@heading io::Import class reference
@anchor{io_Import_class_reference}

@subheading Declaration

@example
#include <goptical/core/io/Import>

namespace goptical @{
  namespace io @{
    class Import;
  @};
@};

@end example

 This class is a member of the io namespace.

This abstract class contains pure virtuals.

@subheading Description
File import class interface
@subheading Members

 See also the full member list (@pxref{io_Import_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item virtual material::Catalog & import_catalog(const std::string &filename) = 0;
@item virtual Set & import_dataset(const std::string &filename) = 0;
@item virtual sys::system & import_design(const std::string &filename) = 0;
@end itemize

@subheading Members detail

@subsubheading virtual material::Catalog & import_catalog(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &filename) = 0;
@anchor{_418}

Import material catalog from file

@subsubheading virtual Set & import_dataset(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &filename) = 0;
@anchor{_419}

Import dataset from file

@subsubheading virtual sys::system & import_design(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &filename) = 0;
@anchor{_420}

Import optical design from file

@page

@heading io::Import class full member list
@anchor{io_Import_class_full_member_list}

@subheading Functions

@itemize
@item virtual material::Catalog & import_catalog(const std::string &filename) = 0;
@item virtual Set & import_dataset(const std::string &filename) = 0;
@item virtual sys::system & import_design(const std::string &filename) = 0;
@end itemize

@page

@heading io::RendererAxes class reference
@anchor{io_RendererAxes_class_reference}

@subheading Declaration

@example
#include <goptical/core/io/RendererAxes>

namespace goptical @{
  namespace io @{
    class RendererAxes;
  @};
@};

@end example

 This class is a member of the io namespace.

@subheading Description

This class describe how axes must be rendered on graphical output.

@subheading Members

 See also the full member list (@pxref{io_RendererAxes_class_full_member_list}) section for this class.

@subsubheading Type

@itemize
@item enum AxisMask
@end itemize

@subsubheading Functions

@itemize
@item RendererAxes()
@item const std::string & get_label(unsigned int axis) const
@item const math::vector3 & get_origin() const
@item const math::vector3 & get_position() const
@item bool get_show_axes(unsigned int axis) const
@item bool get_show_frame() const
@item bool get_show_grid() const
@item bool get_show_tics(unsigned int axis) const
@item bool get_show_values(unsigned int axis) const
@item double get_tics_step(int index@comma{} const math::range_t &r) const
@item void set_label(const std::string &label@comma{} AxisMask a = @emph{[...]})
@item void set_origin(const math::vector3 &origin)
@item void set_position(const math::vector3 &position)
@item void set_range(const math::range_t &r@comma{} AxisMask a = @emph{[...]})
@item void set_show_axes(bool show = @emph{[...]}@comma{} AxisMask a = @emph{[...]})
@item void set_show_frame(bool show = @emph{[...]})
@item void set_show_grid(bool show = @emph{[...]})
@item void set_show_tics(bool show = @emph{[...]}@comma{} AxisMask a = @emph{[...]})
@item void set_show_values(bool show = @emph{[...]}@comma{} AxisMask a = @emph{[...]})
@item void set_tics_base(unsigned int min_count = @emph{[...]}@comma{} double base = @emph{[...]}@comma{} AxisMask a = @emph{[...]})
@item void set_tics_count(unsigned int count@comma{} AxisMask a = @emph{[...]})
@item void set_tics_step(double step@comma{} AxisMask a = @emph{[...]})
@item void set_unit(const std::string &unit@comma{} bool pow10_scale = @emph{[...]}@comma{} bool si_prefix = @emph{[...]}@comma{} int si_pow10 = @emph{[...]}@comma{} AxisMask a = @emph{[...]})
@end itemize

@subheading Members detail

@subsubheading RendererAxes()
@anchor{_421}

No documentation available

@subsubheading enum AxisMask
@anchor{_422}

Specify axes

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item X @tab 
@item Y @tab 
@item Z @tab 
@item XY @tab 
@item YZ @tab 
@item XZ @tab 
@item XYZ @tab 
@end multitable

@subsubheading const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  & get_label(unsigned int axis) const
@anchor{_423}

Get axis label

@subsubheading const math::vector3 & get_origin() const
@anchor{_424}

This function returns axes tics values origin.

@subsubheading const math::vector3 & get_position() const
@anchor{_425}

This function returns axis position

@subsubheading bool get_show_axes(unsigned int axis) const
@anchor{_426}

See set_show_axes (@pxref{_436}) function.

@subsubheading bool get_show_frame() const
@anchor{_427}

See set_show_frame (@pxref{_437}) function.

@subsubheading bool get_show_grid() const
@anchor{_428}

See set_show_grid (@pxref{_438}) function.

@subsubheading bool get_show_tics(unsigned int axis) const
@anchor{_429}

See set_show_tics (@pxref{_439}) function.

@subsubheading bool get_show_values(unsigned int axis) const
@anchor{_430}

See set_show_values (@pxref{_440}) function.

@subsubheading double get_tics_step(int index@comma{} const math::range_t &r) const
@anchor{_431}

get distance between axis tics

@subsubheading void set_label(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &label@comma{} AxisMask a = XYZ)
@anchor{_432}

This function set axis label

@subsubheading void set_origin(const math::vector3 &origin)
@anchor{_433}

This function sets axis tics values origin.

@subsubheading void set_position(const math::vector3 &position)
@anchor{_434}

This function returns axis position

@subsubheading void set_range(const math::range_t &r@comma{} AxisMask a = XYZ)
@anchor{_435}

Set value range for given axis. Default range is [0@comma{}0] which means automatic range.

@subsubheading void set_show_axes(bool show = true@comma{} AxisMask a = XYZ)
@anchor{_436}

This function sets axes visibility.

@subsubheading void set_show_frame(bool show = true)
@anchor{_437}

This function sets frame visibility.

@subsubheading void set_show_grid(bool show = true)
@anchor{_438}

This function sets grid visibility. Grid points use tic step.

@subsubheading void set_show_tics(bool show = true@comma{} AxisMask a = XYZ)
@anchor{_439}

This function sets tics visibility. Tics are located on axes and frame. 

See also set_show_axes (@pxref{_436}) function and set_show_frame (@pxref{_437}) function.

@subsubheading void set_show_values(bool show = true@comma{} AxisMask a = XYZ)
@anchor{_440}

This function sets tics value visibility. When frame is visible@comma{} tics value is located on frame tics instead of axes tics.

See also set_show_axes (@pxref{_436}) function and set_show_frame (@pxref{_437}) function.

@subsubheading void set_tics_base(unsigned int min_count = 5@comma{} double base = 10.0@comma{} AxisMask a = XYZ)
@anchor{_441}

This function sets distance between axis tics to best fit power of specified base divided by sufficient factor of 2 and 5 to have at least @samp{min_count} tics. 

See also set_tics_step (@pxref{_443}) function and set_tics_count (@pxref{_442}) function.

@subsubheading void set_tics_count(unsigned int count@comma{} AxisMask a = XYZ)
@anchor{_442}

This function sets tics count. 

See also set_tics_step (@pxref{_443}) function and set_tics_base (@pxref{_441}) function.

@subsubheading void set_tics_step(double step@comma{} AxisMask a = XYZ)
@anchor{_443}

This function sets distance between axis tics to specified value.

See also set_tics_count (@pxref{_442}) function and set_tics_base (@pxref{_441}) function.

@subsubheading void set_unit(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &unit@comma{} bool pow10_scale = true@comma{} bool si_prefix = true@comma{} int si_pow10 = 0@comma{} AxisMask a = XYZ)
@anchor{_444}

This function sets axis unit.

When @samp{pow10_scale} is set@comma{} value will be scaled to shorten their length and appropriate power of 10 factor will be displayed in axis label.

If @samp{si_prefix} is set@comma{} SI letter decimal prefix is used and the @samp{pow10} parameter can be used to scale base unit by power of ten (useful when input data use scaled SI base unit).

@page

@heading io::RendererAxes class full member list
@anchor{io_RendererAxes_class_full_member_list}

@subheading Type

@itemize
@item enum AxisMask
@end itemize

@subheading Functions

@itemize
@item RendererAxes()
@item const std::string & get_label(unsigned int axis) const
@item const math::vector3 & get_origin() const
@item const math::vector3 & get_position() const
@item bool get_show_axes(unsigned int axis) const
@item bool get_show_frame() const
@item bool get_show_grid() const
@item bool get_show_tics(unsigned int axis) const
@item bool get_show_values(unsigned int axis) const
@item double get_tics_step(int index@comma{} const math::range_t &r) const
@item void set_label(const std::string &label@comma{} AxisMask a = @emph{[...]})
@item void set_origin(const math::vector3 &origin)
@item void set_position(const math::vector3 &position)
@item void set_range(const math::range_t &r@comma{} AxisMask a = @emph{[...]})
@item void set_show_axes(bool show = @emph{[...]}@comma{} AxisMask a = @emph{[...]})
@item void set_show_frame(bool show = @emph{[...]})
@item void set_show_grid(bool show = @emph{[...]})
@item void set_show_tics(bool show = @emph{[...]}@comma{} AxisMask a = @emph{[...]})
@item void set_show_values(bool show = @emph{[...]}@comma{} AxisMask a = @emph{[...]})
@item void set_tics_base(unsigned int min_count = @emph{[...]}@comma{} double base = @emph{[...]}@comma{} AxisMask a = @emph{[...]})
@item void set_tics_count(unsigned int count@comma{} AxisMask a = @emph{[...]})
@item void set_tics_step(double step@comma{} AxisMask a = @emph{[...]})
@item void set_unit(const std::string &unit@comma{} bool pow10_scale = @emph{[...]}@comma{} bool si_prefix = @emph{[...]}@comma{} int si_pow10 = @emph{[...]}@comma{} AxisMask a = @emph{[...]})
@end itemize

@page

@heading io::RendererAxes::Axis internal struct members

@subheading Axis()

No documentation available

@subheading bool _axis

No documentation available

@subheading unsigned int _count

No documentation available

@subheading std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  _label

No documentation available

@subheading int _pow10

No documentation available

@subheading bool _pow10_scale

No documentation available

@subheading math::range_t _range

No documentation available

@subheading bool _si_prefix

No documentation available

@subheading double _step_base

No documentation available

@subheading step_mode_e _step_mode

No documentation available

@subheading bool _tics

No documentation available

@subheading std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  _unit

No documentation available

@subheading bool _values

No documentation available

@page

@heading io::renderer_viewport class reference
@anchor{io_renderer_viewport_class_reference}

@subheading Declaration

@example
#include <goptical/core/io/renderer_viewport>

namespace goptical @{
  namespace io @{
    class renderer_viewport;
  @};
@};

@end example

 This class is a member of the io namespace.

This abstract class contains pure virtuals.

@subheading Inheritance

@subheading Description

This class defines an interface for rendering drivers which rely on viewport windows@comma{} scaling and 2d projection operations. It's designed to be used as a base class for such renderers; this mainly includes pixel based output renderers.

Renderers which write output in vector format in world coordinates directly do not need this class as base.

@subheading Members

 See also the full member list (@pxref{io_renderer_viewport_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 10 members inherited from Renderer (@pxref{io_Renderer_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item renderer_viewport()
@item virtual void draw_pages_grid(const rgb &rgb = @emph{[...]})
@item virtual math::Transform<3> get_camera_transform() const = 0;
@item double get_fov() const
@item const math::vectorPair2 & get_window() const
@item virtual void set_2d_size(double width@comma{} double height)
@item void set_camera_direction(const math::vector3 &dir)
@item void set_camera_position(const math::vector3 &pos)
@item virtual void set_camera_transform(const math::Transform<3> &t) = 0;
@item void set_fov(double fov)
@item void set_margin(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin(double width@comma{} double height)
@item void set_margin_output(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin_output(double width@comma{} double height)
@item void set_margin_ratio(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin_ratio(double width@comma{} double height)
@item void set_numeric_format(std::ios_base::fmtflags format@comma{} unsigned int precision)
@item virtual void set_page(unsigned int page)
@item virtual void set_page_layout(unsigned int cols@comma{} unsigned int rows)
@item virtual void set_perspective() = 0;
@item virtual void set_window(const math::vector2 &center@comma{} const math::vector2 &size@comma{} bool keep_aspect = @emph{[...]})
@item void set_window(const math::vectorPair2 &window@comma{} bool keep_aspect = @emph{[...]})
@item void set_window(const math::vector2 &center@comma{} double radius@comma{} bool keep_aspect = @emph{[...]})
@end itemize

@subheading Members detail

@subsubheading renderer_viewport()
@anchor{_458}

No documentation available

@subsubheading virtual void draw_pages_grid(const rgb &rgb = rgb_gray)
@anchor{_459}

Draw separations between pages@comma{} output window must have been setup before.

@subsubheading virtual math::Transform<3> get_camera_transform() const = 0;
@anchor{_460}

Get reference to 3d camera transform

@subsubheading double get_fov() const
@anchor{_461}

 Get field of view in degrees.

See also set_fov (@pxref{_467}) function.

@subsubheading const math::vectorPair2 & get_window() const
@anchor{_462}

Get current viewport window

@subsubheading virtual void set_2d_size(double width@comma{} double height)
@anchor{_463}

Update 2d output size@comma{} not all drivers support this

@subsubheading void set_camera_direction(const math::vector3 &dir)
@anchor{_464}

Set 3d camera rotation from direction vector

@subsubheading void set_camera_position(const math::vector3 &pos)
@anchor{_465}

Set 3d camera rotation from direction vector

@subsubheading virtual void set_camera_transform(const math::Transform<3> &t) = 0;
@anchor{_466}

Get modifiable reference to 3d camera transform

@subsubheading void set_fov(double fov)
@anchor{_467}

 Set field of view in degrees.

See also get_fov (@pxref{_461}) function.

@subsubheading void set_margin(double left@comma{} double bottom@comma{} double right@comma{} double top)
@anchor{_468}

 Set amount of 2d margin space for set_window (@pxref{_478}) operation in world coordinates units.

@subsubheading void set_margin(double width@comma{} double height)
@anchor{_469}

See set_margin (@pxref{_468}) function.

@subsubheading void set_margin_output(double left@comma{} double bottom@comma{} double right@comma{} double top)
@anchor{_470}

 Set amount of 2d margin space for set_window (@pxref{_478}) operation in output size units (usually pixels).

@subsubheading void set_margin_output(double width@comma{} double height)
@anchor{_471}

See set_margin_output (@pxref{_470}) function.

@subsubheading void set_margin_ratio(double left@comma{} double bottom@comma{} double right@comma{} double top)
@anchor{_472}

 Set amount of 2d margin space for set_window (@pxref{_478}) operation as ratio of window.

@subsubheading void set_margin_ratio(double width@comma{} double height)
@anchor{_473}

See set_margin_ratio (@pxref{_472}) function.

@subsubheading void set_numeric_format(std::ios_base:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a00951.html#7f39867a040f53ebf29b2a9d45677395,,fmtflags}  format@comma{} unsigned int precision)
@anchor{_474}

Set format used to print numeric values

@subsubheading virtual void set_page(unsigned int page)
@anchor{_475}

Select current page when multiple pages layout is in use. 

See also set_page_layout (@pxref{_476}) function.

@subsubheading virtual void set_page_layout(unsigned int cols@comma{} unsigned int rows)
@anchor{_476}

This function can be used to setup a pages grid. Current output page must be selected with set_page (@pxref{_475}).

@subsubheading virtual void set_perspective() = 0;
@anchor{_477}

Set 3d perspective projection mode. This function reset the viewport window to (-1@comma{}1). 

See also set_window (@pxref{_478}) function and set_fov (@pxref{_467}) function.

@subsubheading virtual void set_window(const math::vector2 &center@comma{} const math::vector2 &size@comma{} bool keep_aspect = true)
@anchor{_478}

 Set 2d viewport window. This function set 3d projection to orthographic.

@subsubheading void set_window(const math::vectorPair2 &window@comma{} bool keep_aspect = true)
@anchor{_479}

 Set 2d viewport window. This function set 3d projection to orthographic.

@subsubheading void set_window(const math::vector2 &center@comma{} double radius@comma{} bool keep_aspect = true)
@anchor{_480}

 Set 2d viewport window. This function set 3d projection to orthographic.

@page

@heading io::renderer_viewport class full member list
@anchor{io_renderer_viewport_class_full_member_list}

@subheading Functions

@itemize
@item renderer_viewport()
@item virtual void draw_pages_grid(const rgb &rgb = @emph{[...]})
@item virtual math::Transform<3> get_camera_transform() const = 0;
@item double get_feature_size() const
@item double get_fov() const
@item const rgb & get_style_color(Style s) const
@item const math::vectorPair2 & get_window() const
@item const rgb & rgb_background() const
@item const rgb & rgb_foreground() const
@item virtual void set_2d_size(double width@comma{} double height)
@item void set_camera_direction(const math::vector3 &dir)
@item void set_camera_position(const math::vector3 &pos)
@item virtual void set_camera_transform(const math::Transform<3> &t) = 0;
@item void set_feature_size(double feature_size)
@item void set_fov(double fov)
@item void set_margin(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin(double width@comma{} double height)
@item void set_margin_output(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin_output(double width@comma{} double height)
@item void set_margin_ratio(double left@comma{} double bottom@comma{} double right@comma{} double top)
@item void set_margin_ratio(double width@comma{} double height)
@item void set_numeric_format(std::ios_base::fmtflags format@comma{} unsigned int precision)
@item virtual void set_page(unsigned int page)
@item virtual void set_page_layout(unsigned int cols@comma{} unsigned int rows)
@item virtual void set_perspective() = 0;
@item void set_ray_color_mode(RayColorMode m)
@item void set_ray_intensity_mode(IntensityMode m)
@item void set_style_color(Style s@comma{} const rgb &rgb)
@item virtual void set_window(const math::vector2 &center@comma{} const math::vector2 &size@comma{} bool keep_aspect = @emph{[...]})
@item void set_window(const math::vectorPair2 &window@comma{} bool keep_aspect = @emph{[...]})
@item void set_window(const math::vector2 &center@comma{} double radius@comma{} bool keep_aspect = @emph{[...]})
@end itemize

@page

@heading io::rgb struct reference
@anchor{io_rgb_struct_reference}

@subheading Declaration

@example
#include <goptical/core/io/rgb>

namespace goptical @{
  namespace io @{
    struct rgb;
  @};
@};

@end example

 This struct is a member of the io namespace.

@subheading Description
RGB color descriptor
@subheading Members

 See also the full member list (@pxref{io_rgb_struct_full_member_list}) section for this struct.

@subsubheading Functions

@itemize
@item rgb()
@item rgb(float red@comma{} float green@comma{} float blue@comma{} float alpha = @emph{[...]})
@item bool operator<(const rgb &rgb) const
@item rgb operator~() const
@end itemize

@subsubheading Fields

@itemize
@item float a
@item float b
@item float g
@item float r
@end itemize

@subheading Members detail

@subsubheading rgb()
@anchor{_481}

No documentation available

@subsubheading rgb(float red@comma{} float green@comma{} float blue@comma{} float alpha = 1.0)
@anchor{_482}

No documentation available

@subsubheading float a
@anchor{_483}

No documentation available

@subsubheading float b
@anchor{_484}

No documentation available

@subsubheading float g
@anchor{_485}

No documentation available

@subsubheading bool operator<(const rgb &rgb) const
@anchor{_486}

No documentation available

@subsubheading rgb operator~() const
@anchor{_487}

No documentation available

@subsubheading float r
@anchor{_488}

No documentation available

@page

@heading io::rgb struct full member list
@anchor{io_rgb_struct_full_member_list}

@subheading Functions

@itemize
@item rgb()
@item rgb(float red@comma{} float green@comma{} float blue@comma{} float alpha = @emph{[...]})
@item bool operator<(const rgb &rgb) const
@item rgb operator~() const
@end itemize

@subheading Fields

@itemize
@item float a
@item float b
@item float g
@item float r
@end itemize

@page

@heading light namespace reference
@anchor{light_namespace_reference}

@subheading Description
Physical properties of light
@subheading Members

@subsubheading Types

@itemize
@item class Ray
@item class SpectralLine
@end itemize

@page

@heading light::Ray class reference
@anchor{light_Ray_class_reference}

@subheading Declaration

@example
#include <goptical/core/light/Ray>

namespace goptical @{
  namespace light @{
    class Ray;
  @};
@};

@end example

 This class is a member of the light namespace.

@subheading Inheritance

@subheading Description

This class is used to describe a ray of light. It contains geometrical and physical informations about a light ray.

@subheading Members

 See also the full member list (@pxref{light_Ray_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 34 members inherited from math::vectorPair (@pxref{math_vectorPair_3_struct_reference})<3>
@end itemize

@subsubheading Functions

@itemize
@item Ray()
@item Ray(const math::vectorPair3 &ray@comma{} double intensity = @emph{[...]}@comma{} double wavelen = @emph{[...]})
@item double get_intensity() const
@item double get_wavelen() const
@item void set_intensity(double intensity)
@item void set_wavelen(double wavelen)
@end itemize

@subheading Members detail

@subsubheading Ray()
@anchor{_489}

No documentation available

@subsubheading Ray(const math::vectorPair3 &ray@comma{} double intensity = 1@comma{} double wavelen = 550)
@anchor{_490}

Create a ray of light with specified properties

@subsubheading double get_intensity() const
@anchor{_491}

Get light ray intensity

@subsubheading double get_wavelen() const
@anchor{_492}

Set light ray wavelen

@subsubheading void set_intensity(double intensity)
@anchor{_493}

Set light ray intensity

@subsubheading void set_wavelen(double wavelen)
@anchor{_494}

Get light ray wavelen

@page

@heading light::Ray class full member list
@anchor{light_Ray_class_full_member_list}

@subheading Functions

@itemize
@item Ray()
@item Ray(const math::vectorPair3 &ray@comma{} double intensity = @emph{[...]}@comma{} double wavelen = @emph{[...]})
@item math::vector<N> & direction()
@item const math::vector<N> & direction() const
@item double get_intensity() const
@item double get_wavelen() const
@item math::vector<3> ln_ln_clst_pt(const math::vectorPair<3> &line) const
@item double ln_ln_clst_pt_scale(const math::vectorPair<3> &line) const
@item math::vector<N> ln_pt_clst_pt(const math::vector<N> &point) const
@item double ln_pt_clst_pt_scale(const math::vector<N> &point) const
@item math::vector<N> & normal()
@item const math::vector<N> & normal() const
@item math::vectorPairBase<3> operator*(double factor)
@item const math::vectorPairBase<3> & operator+=(const math::vectorPairBase<3> &p)
@item const math::vector<N> & operator[](int n) const
@item math::vector<N> & operator[](int n)
@item math::vector<N> & origin()
@item const math::vector<N> & origin() const
@item math::vector<3> pl_ln_intersect(const math::vectorPair<3> &line) const
@item double pl_ln_intersect_scale(const math::vectorPair<3> &line) const
@item math::vector<N> seg_pt_clst_pt(const math::vector<N> &point) const
@item double seg_pt_clst_pt_scale(const math::vector<N> &point) const
@item void set_intensity(double intensity)
@item void set_wavelen(double wavelen)
@item double x0() const
@item double & x0()
@item double x1() const
@item double & x1()
@item double y0() const
@item double & y0()
@item double y1() const
@item double & y1()
@item double z0() const
@item double & z0()
@item double z1() const
@item double & z1()
@end itemize

@page

@heading light::SpectralLine class reference
@anchor{light_SpectralLine_class_reference}

@subheading Declaration

@example
#include <goptical/core/light/SpectralLine>

namespace goptical @{
  namespace light @{
    class SpectralLine;
  @};
@};

@end example

 This class is a member of the light namespace.

@subheading Description

This class can be used to describe a spectral line. It contains constants for wave length of standard rays

@subheading Members

 See also the full member list (@pxref{light_SpectralLine_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item SpectralLine(double wavelen@comma{} double intensity = @emph{[...]})
@item io::rgb get_color() const
@item double get_intensity() const
@item double get_wavelen() const
@end itemize

@subsubheading Static function

@itemize
@item static io::rgb get_wavelen_color(double wl)
@end itemize

@subsubheading Constants

@itemize
@item static const double C
@item static const double C_
@item static const double D
@item static const double F
@item static const double F_
@item static const double blue
@item static const double d
@item static const double e
@item static const double g
@item static const double green
@item static const double h
@item static const double i
@item static const double r
@item static const double red
@item static const double s
@item static const double t
@end itemize

@subheading Members detail

@subsubheading SpectralLine(double wavelen@comma{} double intensity = 1.0)
@anchor{_495}

Create a spectral line with specified wavelen and intensity.

@subsubheading static const double C
@anchor{_496}

red hydrogen line at 656.2725nm

@subsubheading static const double C_
@anchor{_497}

red cadmium line at 643.8469nm

@subsubheading static const double D
@anchor{_498}

yellow sodium line at 589.2938nm

@subsubheading static const double F
@anchor{_499}

blue hydrogen line at 486.1327nm

@subsubheading static const double F_
@anchor{_500}

blue cadmium line at 479.9914nm

@subsubheading static const double blue
@anchor{_501}

blue colored line at 440nm

@subsubheading static const double d
@anchor{_502}

yellow helium line at 587.5618nm

@subsubheading static const double e
@anchor{_503}

green mercury line at 546.074nm

@subsubheading static const double g
@anchor{_504}

blue mercury line at 435.8343nm

@subsubheading io::rgb get_color() const
@anchor{_505}

get rgb color associated spectral line@comma{} ignore intensity

@subsubheading double get_intensity() const
@anchor{_506}

get spectral line intensity

@subsubheading double get_wavelen() const
@anchor{_507}

get spectral line wavelen

@subsubheading static io::rgb get_wavelen_color(double wl)
@anchor{_508}

get rgb color associated with wavelen

@subsubheading static const double green
@anchor{_509}

green colored line at 510nm

@subsubheading static const double h
@anchor{_510}

violet mercury line at 404.6561nm

@subsubheading static const double i
@anchor{_511}

ultraviolet mercury line at 365.0146nm

@subsubheading static const double r
@anchor{_512}

red helium line at 706.5188nm

@subsubheading static const double red
@anchor{_513}

red colored line at 645nm

@subsubheading static const double s
@anchor{_514}

infrared cesium line at 852.11nm

@subsubheading static const double t
@anchor{_515}

infrared mercury line at 1013.98nm

@page

@heading light::SpectralLine class full member list
@anchor{light_SpectralLine_class_full_member_list}

@subheading Functions

@itemize
@item SpectralLine(double wavelen@comma{} double intensity = @emph{[...]})
@item io::rgb get_color() const
@item double get_intensity() const
@item double get_wavelen() const
@end itemize

@subheading Static function

@itemize
@item static io::rgb get_wavelen_color(double wl)
@end itemize

@subheading Constants

@itemize
@item static const double C
@item static const double C_
@item static const double D
@item static const double F
@item static const double F_
@item static const double blue
@item static const double d
@item static const double e
@item static const double g
@item static const double green
@item static const double h
@item static const double i
@item static const double r
@item static const double red
@item static const double s
@item static const double t
@end itemize

@page

@heading material namespace reference
@anchor{material_namespace_reference}

@subheading Description
material models for optical components
@subheading Members

@subsubheading Types

@itemize
@item template class Abbe
@item template class Air
@item class Base
@item class Catalog
@item class Conrady
@item class DispersionTable
@item class Herzberger
@item class Metal
@item class Mil
@item class mirror
@item class Schott
@item class Sellmeier
@item template class SellmeierMod
@item class Vacuum
@item enum AbbeFormula
@item typedef @emph{ [...] } AbbeVd
@item typedef @emph{ [...] } AbbeVe
@item typedef @emph{ [...] } AirBirch94
@item enum AirFormula
@item typedef @emph{ [...] } AirKohlrausch68
@item class Dielectric
@item typedef @emph{ [...] } Handbook1
@item typedef @emph{ [...] } Handbook2
@item class Proxy
@item typedef @emph{ [...] } SellmeierMod2
@item enum SellmeierModFormula
@item class Solid
@end itemize

@subsubheading Constants

@itemize
@item const const_ref<Base> none
@item const AirBirch94 std_air
@end itemize

@subsubheading Variables

@itemize
@item AirBirch94 air
@item mirror mirror
@item Vacuum vacuum
@end itemize

@subheading Members detail

@subsubheading enum AbbeFormula
@anchor{_516}

Specify Abbe number type used by the Abbe (@pxref{material_Abbe_class_reference}) class

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item AbbeVdFormula @tab 
Abbe number of Fraunhofer @emph{d} line

@item AbbeVeFormula @tab 
Abbe number of Fraunhofer @emph{e} line

@end multitable

@subsubheading typedef Abbe<AbbeVdFormula> AbbeVd
@anchor{_517}

See Abbe (@pxref{material_Abbe_class_reference}) class.

@subsubheading typedef Abbe<AbbeVeFormula> AbbeVe
@anchor{_518}

See Abbe (@pxref{material_Abbe_class_reference}) class.

@subsubheading typedef Air<AirBirch94Formula> AirBirch94
@anchor{_519}

See Air (@pxref{material_Air_class_reference}) class.

@subsubheading enum AirFormula
@anchor{_520}

Specify air refractive index model used by Air (@pxref{material_Air_class_reference}) class.

@multitable @columnfractions 0.309859154929577 0.690140845070423
@headitem Identifier @tab Description
@item AirBirch94Formula @tab 
Birch@comma{} Metrologia@comma{} 1994@comma{} 31@comma{} 315

@item AirKohlrausch68Formula @tab 
F. Kohlrausch@comma{} Praktische Physik@comma{} 1968@comma{} 1@comma{} 408

@end multitable

@subsubheading typedef Air<AirKohlrausch68Formula> AirKohlrausch68
@anchor{_521}

See Air (@pxref{material_Air_class_reference}) class.

@subsubheading typedef SellmeierMod<Handbook1Formula> Handbook1
@anchor{_522}

See SellmeierMod (@pxref{material_SellmeierMod_class_reference}) class.

@subsubheading typedef SellmeierMod<Handbook2Formula> Handbook2
@anchor{_523}

See SellmeierMod (@pxref{material_SellmeierMod_class_reference}) class.

@subsubheading typedef SellmeierMod<SellmeierMod2Formula> SellmeierMod2
@anchor{_524}

See SellmeierMod (@pxref{material_SellmeierMod_class_reference}) class.

@subsubheading enum SellmeierModFormula
@anchor{_525}

Specify Sellmeier variation used by the SellmeierMod (@pxref{material_SellmeierMod_class_reference}) class

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item SellmeierMod2Formula @tab 
@item Handbook1Formula @tab 
@item Handbook2Formula @tab 
@end multitable

@subsubheading AirBirch94 air
@anchor{_526}

A global instance of AirBirch94 (@pxref{_519}) material.

@subsubheading mirror mirror
@anchor{_527}

A global instance of material::mirror material.

@subsubheading const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <Base> none
@anchor{_528}

material null pointer

@subsubheading const AirBirch94 std_air
@anchor{_529}

A global read only instance of AirBirch94 (@pxref{_519}) material with standard parameters.

@subsubheading Vacuum vacuum
@anchor{_530}

A global instance of material::Vacuum material.

@page

@heading material::Abbe class reference
@anchor{material_Abbe_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/Abbe>

namespace goptical @{
  namespace material @{
    template <enum AbbeFormula m> class Abbe;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description

This class models optical properties of glass materials using known refractive index value@comma{}  @uref{http://en.wikipedia.org/wiki/Abbe_number,,Abbe number}  and partial dispersion deviation (dpgF).

AbbeVd (@pxref{_517}) and AbbeVe (@pxref{_518}) template instances are available for @emph{d} and @emph{e} line definitions of Abbe number.

The following formula is used to determine refractive index at any wavelen in visible spectrum:

 @math{n_\lambda = n_d + \frac{\left( n_d-1\right)}{v_d}\times\left( c_1+a\times c_0 +
               \frac{c_3+a\times c_2}{\lambda} + \frac{c_5+a\times c_4}{{\lambda}^{2}} +
               \frac{c_7+a\times c_6}{{\lambda}^{3}} \right)} 

with  @math{a = a_1\times v_d+a_0+\Delta P_{g,F}}  and  @math{\lambda}  the micrometer wavelength.

@emph{a0} and @emph{a1} values are given in Schott "@emph{TIE-29: Refractive Index and Dispersion}" technical information document.

@emph{c0} to @emph{c7} values were determined using least square fitting on indexes obtained using Sellmeier data from 118 glass materials from the Schott catalog for 360 wavelengths between 390nm and 750nm. Two different coefficients sets are used for @emph{nd/vd} and @emph{ne/ve} pairs.

Mean error is less than 0.00002 from Sellmeier indexes and largest error found across fitted glasses and wavelengths is 0.0008. When dpgF is set to 0@comma{} mean error becomes 0.0001 and largest error is close to 0.006.

@subheading Members

 See also the full member list (@pxref{material_Abbe_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 36 members inherited from Dielectric (@pxref{material_Dielectric_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Abbe(double n@comma{} double v@comma{} double dpgF = @emph{[...]})
@item virtual double get_measurement_index(double wavelen) const
@end itemize

@subheading Members detail

@subsubheading Abbe(double n@comma{} double v@comma{} double dpgF = 0.)
@anchor{_531}

Create an abbe glass model

@subsubheading virtual double get_measurement_index(double wavelen) const
@anchor{_532}

This virtual function implements the @code{get_measurement_index (@pxref{_617})} pure function declared in the @code{Dielectric (@pxref{material_Dielectric_class_reference})} base abstract class.

Documentation inherited from base class:

Get material relative refractive index in measurment medium at specified wavelen in @emph{nm.}

@page

@heading material::Abbe class full member list
@anchor{material_Abbe_class_full_member_list}

@subheading Functions

@itemize
@item Abbe(double n@comma{} double v@comma{} double dpgF = @emph{[...]})
@item void clear_internal_transmittance()
@item void disable_temperature_coeff()
@item double get_abbe_vd() const
@item double get_abbe_ve() const
@item virtual io::rgb get_color() const
@item double get_density() const
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_measurement_index(double wavelen) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_partial_dispersion(double wavelen1@comma{} double wavelen2) const
@item double get_poisson_ratio() const
@item double get_principal_dispersion() const
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual double get_temperature() const
@item double get_thermal_conductivity() const
@item double get_thermal_expansion() const
@item data::DiscreteSet & get_transmittance_dataset()
@item double get_young_modulus() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_density(double density)
@item void set_internal_transmittance(double wavelen@comma{} double thickness@comma{} double transmittance)
@item void set_measurement_medium(const const_ref<Base> &medium)
@item void set_poisson_ratio(double poisson_ratio)
@item void set_temperature(double temp)
@item void set_temperature_dndt(double dndt)
@item void set_temperature_schott(double d0@comma{} double d1@comma{} double d2@comma{} double e0@comma{} double e1@comma{} double wl_tk)
@item void set_thermal_conductivity(double thermal_conductivity)
@item void set_thermal_expansion(double thermal_expansion)
@item void set_wavelen_range(double low@comma{} double high)
@item void set_young_modulus(double young_modulus)
@end itemize

@page

@heading material::Air class reference
@anchor{material_Air_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/Air>

namespace goptical @{
  namespace material @{
    template <enum AirFormula M> class Air;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description

This class models optical properties of air. Refractive index of air depends on temperature and pressure.

This class provides different formulas:

@itemize
@item 
AirBirch94 (@pxref{_519}) : described in "@emph{Birch@comma{} Metrologia@comma{} 1994@comma{} 31@comma{} 315}".

@item 
AirKohlrausch68 (@pxref{_521}) : described in "@emph{F. Kohlrausch@comma{} Praktische Physik@comma{} 1968@comma{} 1@comma{} 408}".

@end itemize

Global variables air (@pxref{_526}) and std_air (@pxref{_529}) are available with default parameters and Birch model.

@subheading Members

 See also the full member list (@pxref{material_Air_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 14 members inherited from Base (@pxref{material_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Air(double pressure = @emph{[...]})
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_pressure() const
@item virtual double get_refractive_index(double wavelen) const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_pressure(double pressure)
@end itemize

@subsubheading Constant

@itemize
@item static const double std_pressure
@end itemize

@subheading Members detail

@subsubheading Air(double pressure = std_pressure)
@anchor{_533}

Create a new air material model with 101325 Pa pressure.

@subsubheading virtual double get_extinction_coef(double wavelen) const
@anchor{_534}

This virtual function overrides the @code{get_extinction_coef (@pxref{_545})} virtual function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get extinction coefficient. Subclasses _must_ provide this function or the get_internal_transmittance() function.

@subsubheading virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@anchor{_535}

This virtual function overrides the @code{get_internal_transmittance (@pxref{_546})} virtual function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get material internal transmittance for thickness in mm. Subclasses _must_ provide this function or the get_extinction_coef() function.

@subsubheading double get_pressure() const
@anchor{_536}

 Get relative air pressure in @emph{Pa}.

See also set_pressure (@pxref{_540}) function and std_pressure (@pxref{_541}) variable.

@subsubheading virtual double get_refractive_index(double wavelen) const
@anchor{_537}

This virtual function implements the @code{get_refractive_index (@pxref{_550})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get material absolute refractive index at specified wavelen in @emph{nm.}

@subsubheading virtual bool is_opaque() const
@anchor{_538}

This virtual function implements the @code{is_opaque (@pxref{_553})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Return true if material must be considered opaque for ray tracing

@subsubheading virtual bool is_reflecting() const
@anchor{_539}

This virtual function implements the @code{is_reflecting (@pxref{_554})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Return true if material may reflect most of the light and must be considered as a mirror when ignoring ray intensity computation during ray tracing.

@subsubheading void set_pressure(double pressure)
@anchor{_540}

 Set relative air pressure in @emph{Pa}.

See also get_pressure (@pxref{_536}) function and std_pressure (@pxref{_541}) variable.

@subsubheading static const double std_pressure
@anchor{_541}

Standard air pressure is 101325 @emph{Pa}

@page

@heading material::Air class full member list
@anchor{material_Air_class_full_member_list}

@subheading Functions

@itemize
@item Air(double pressure = @emph{[...]})
@item virtual io::rgb get_color() const
@item virtual double get_extinction_coef(double wavelen) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_pressure() const
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual double get_temperature() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_pressure(double pressure)
@item void set_temperature(double temp)
@end itemize

@subheading Constant

@itemize
@item static const double std_pressure
@end itemize

@page

@heading material::Base class reference
@anchor{material_Base_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/Base>

namespace goptical @{
  namespace material @{
    class Base;
  @};
@};

@end example

 This class is a member of the material namespace.

This abstract class contains pure virtuals.

@subheading Inheritance

@subheading Description

This class is the base class for all material classes. It desrcibes physical properties of materials which interact with light.

@subheading Members

 See also the full member list (@pxref{material_Base_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item Base()
@item virtual ~Base()
@item virtual io::rgb get_color() const
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item virtual double get_refractive_index(double wavelen) const = 0;
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_temperature() const
@item virtual bool is_opaque() const = 0;
@item virtual bool is_reflecting() const = 0;
@item void set_temperature(double temp)
@end itemize

@subheading Members detail

@subsubheading Base()
@anchor{_542}

material base constuctor. Set material temperature to 20.

@subsubheading virtual ~Base()
@anchor{_543}

No documentation available

@subsubheading virtual io::rgb get_color() const
@anchor{_544}

Get material color and alpha

@subsubheading virtual double get_extinction_coef(double wavelen) const
@anchor{_545}

Get extinction coefficient. Subclasses _must_ provide this function or the get_internal_transmittance() function.

@subsubheading virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@anchor{_546}

Get material internal transmittance for thickness in mm. Subclasses _must_ provide this function or the get_extinction_coef() function.

@subsubheading double get_internal_transmittance(double wavelen) const
@anchor{_547}

Get material internal transmittance for 1mm thickness.

@subsubheading virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@anchor{_548}

Get reflectance at normal incidence

@subsubheading virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@anchor{_549}

Get transmittance at normal incidence

@subsubheading virtual double get_refractive_index(double wavelen) const = 0;
@anchor{_550}

Get material absolute refractive index at specified wavelen in @emph{nm.}

@subsubheading double get_refractive_index(double wavelen@comma{} const Base &env) const
@anchor{_551}

Get material relative refractive index in given medium at specified wavelen in @emph{nm.}

@subsubheading virtual double get_temperature() const
@anchor{_552}

Get material temperature in celcius

@subsubheading virtual bool is_opaque() const = 0;
@anchor{_553}

Return true if material must be considered opaque for ray tracing

@subsubheading virtual bool is_reflecting() const = 0;
@anchor{_554}

Return true if material may reflect most of the light and must be considered as a mirror when ignoring ray intensity computation during ray tracing.

@subsubheading void set_temperature(double temp)
@anchor{_555}

Set material temperature in celcius

@page

@heading material::Base class full member list
@anchor{material_Base_class_full_member_list}

@subheading Functions

@itemize
@item Base()
@item virtual ~Base()
@item virtual io::rgb get_color() const
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item virtual double get_refractive_index(double wavelen) const = 0;
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_temperature() const
@item virtual bool is_opaque() const = 0;
@item virtual bool is_reflecting() const = 0;
@item void set_temperature(double temp)
@end itemize

@page

@heading material::Catalog class reference
@anchor{material_Catalog_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/Catalog>

namespace goptical @{
  namespace material @{
    class Catalog;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description
Hold a glass material catalog
@subheading Members

 See also the full member list (@pxref{material_Catalog_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item Catalog(const std::string &name = @emph{[...]})
@item void add_material(const std::string &material_name@comma{} const const_ref<Base> &material)
@item void del_material(const std::string &material_name)
@item const Base & get_material(const std::string &material_name)
@item const std::string & get_name() const
@item void set_name(const std::string &name)
@end itemize

@subheading Members detail

@subsubheading Catalog(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &name = "")
@anchor{_556}

Create a catalog with given name

@subsubheading void add_material(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &material_name@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <Base> &material)
@anchor{_557}

Add a material to catalog. material object will be deleted on catalog destruction if owner is set.

@subsubheading void del_material(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &material_name)
@anchor{_558}

Remove a material from catalog

@subsubheading const Base & get_material(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &material_name)
@anchor{_559}

Get material with given name

@subsubheading const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  & get_name() const
@anchor{_560}

Get catalog name

@subsubheading void set_name(const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01697.html#a431813f68fa8a80ea10ea2ad21066a2,,string}  &name)
@anchor{_561}

Set catalog name

@page

@heading material::Catalog class full member list
@anchor{material_Catalog_class_full_member_list}

@subheading Functions

@itemize
@item Catalog(const std::string &name = @emph{[...]})
@item void add_material(const std::string &material_name@comma{} const const_ref<Base> &material)
@item void del_material(const std::string &material_name)
@item const Base & get_material(const std::string &material_name)
@item const std::string & get_name() const
@item void set_name(const std::string &name)
@end itemize

@page

@heading material::Conrady class reference
@anchor{material_Conrady_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/Conrady>

namespace goptical @{
  namespace material @{
    class Conrady;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description

This class models optical properties of dielectric materials with conrady refractive index dispersion formula.

Refractive index formula is:

 @math{n_\lambda = A + \frac{B}{\lambda} + \frac{C}{\lambda^{3.5}}} 

with  @math{\lambda}  the micrometer wavelength.

@subheading Members

 See also the full member list (@pxref{material_Conrady_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 36 members inherited from Dielectric (@pxref{material_Dielectric_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Conrady()
@item Conrady(double A@comma{} double B@comma{} double C)
@item virtual double get_measurement_index(double wavelen) const
@item void set_coefficients(double A@comma{} double B@comma{} double C)
@end itemize

@subheading Members detail

@subsubheading Conrady()
@anchor{_562}

Create an empty conrady model

@subsubheading Conrady(double A@comma{} double B@comma{} double C)
@anchor{_563}

Create an conrady model with given coefficients

@subsubheading virtual double get_measurement_index(double wavelen) const
@anchor{_564}

This virtual function implements the @code{get_measurement_index (@pxref{_617})} pure function declared in the @code{Dielectric (@pxref{material_Dielectric_class_reference})} base abstract class.

Documentation inherited from base class:

Get material relative refractive index in measurment medium at specified wavelen in @emph{nm.}

@subsubheading void set_coefficients(double A@comma{} double B@comma{} double C)
@anchor{_565}

Change conrady constant term

@page

@heading material::Conrady class full member list
@anchor{material_Conrady_class_full_member_list}

@subheading Functions

@itemize
@item Conrady()
@item Conrady(double A@comma{} double B@comma{} double C)
@item void clear_internal_transmittance()
@item void disable_temperature_coeff()
@item double get_abbe_vd() const
@item double get_abbe_ve() const
@item virtual io::rgb get_color() const
@item double get_density() const
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_measurement_index(double wavelen) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_partial_dispersion(double wavelen1@comma{} double wavelen2) const
@item double get_poisson_ratio() const
@item double get_principal_dispersion() const
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual double get_temperature() const
@item double get_thermal_conductivity() const
@item double get_thermal_expansion() const
@item data::DiscreteSet & get_transmittance_dataset()
@item double get_young_modulus() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_coefficients(double A@comma{} double B@comma{} double C)
@item void set_density(double density)
@item void set_internal_transmittance(double wavelen@comma{} double thickness@comma{} double transmittance)
@item void set_measurement_medium(const const_ref<Base> &medium)
@item void set_poisson_ratio(double poisson_ratio)
@item void set_temperature(double temp)
@item void set_temperature_dndt(double dndt)
@item void set_temperature_schott(double d0@comma{} double d1@comma{} double d2@comma{} double e0@comma{} double e1@comma{} double wl_tk)
@item void set_thermal_conductivity(double thermal_conductivity)
@item void set_thermal_expansion(double thermal_expansion)
@item void set_wavelen_range(double low@comma{} double high)
@item void set_young_modulus(double young_modulus)
@end itemize

@page

@heading material::DispersionTable class reference
@anchor{material_DispersionTable_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/DispersionTable>

namespace goptical @{
  namespace material @{
    class DispersionTable;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description

This class models refractive index of optical material using user provided data table.

Known refractive index values are stored and interpolated by a data::DiscreteSet (@pxref{data_DiscreteSet_class_reference}) object. Default interpolation is data::Cubic (@pxref{_146}).

@subheading Members

 See also the full member list (@pxref{material_DispersionTable_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 36 members inherited from Dielectric (@pxref{material_Dielectric_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item DispersionTable()
@item void clear_refractive_index_table()
@item virtual double get_measurement_index(double wavelen) const
@item data::DiscreteSet & get_refractive_index_dataset()
@item void set_refractive_index(double wavelen@comma{} double index)
@end itemize

@subheading Members detail

@subsubheading DispersionTable()
@anchor{_566}

No documentation available

@subsubheading void clear_refractive_index_table()
@anchor{_567}

Clear all refractive index data

@subsubheading virtual double get_measurement_index(double wavelen) const
@anchor{_568}

This virtual function implements the @code{get_measurement_index (@pxref{_617})} pure function declared in the @code{Dielectric (@pxref{material_Dielectric_class_reference})} base abstract class.

Documentation inherited from base class:

Get material relative refractive index in measurment medium at specified wavelen in @emph{nm.}

@subsubheading data::DiscreteSet & get_refractive_index_dataset()
@anchor{_569}

Get refractive index dataset object

@subsubheading void set_refractive_index(double wavelen@comma{} double index)
@anchor{_570}

Add refractive index data

@page

@heading material::DispersionTable class full member list
@anchor{material_DispersionTable_class_full_member_list}

@subheading Functions

@itemize
@item DispersionTable()
@item void clear_internal_transmittance()
@item void clear_refractive_index_table()
@item void disable_temperature_coeff()
@item double get_abbe_vd() const
@item double get_abbe_ve() const
@item virtual io::rgb get_color() const
@item double get_density() const
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_measurement_index(double wavelen) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_partial_dispersion(double wavelen1@comma{} double wavelen2) const
@item double get_poisson_ratio() const
@item double get_principal_dispersion() const
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_refractive_index(double wavelen) const
@item data::DiscreteSet & get_refractive_index_dataset()
@item virtual double get_temperature() const
@item double get_thermal_conductivity() const
@item double get_thermal_expansion() const
@item data::DiscreteSet & get_transmittance_dataset()
@item double get_young_modulus() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_density(double density)
@item void set_internal_transmittance(double wavelen@comma{} double thickness@comma{} double transmittance)
@item void set_measurement_medium(const const_ref<Base> &medium)
@item void set_poisson_ratio(double poisson_ratio)
@item void set_refractive_index(double wavelen@comma{} double index)
@item void set_temperature(double temp)
@item void set_temperature_dndt(double dndt)
@item void set_temperature_schott(double d0@comma{} double d1@comma{} double d2@comma{} double e0@comma{} double e1@comma{} double wl_tk)
@item void set_thermal_conductivity(double thermal_conductivity)
@item void set_thermal_expansion(double thermal_expansion)
@item void set_wavelen_range(double low@comma{} double high)
@item void set_young_modulus(double young_modulus)
@end itemize

@page

@heading material::Herzberger class reference
@anchor{material_Herzberger_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/Herzberger>

namespace goptical @{
  namespace material @{
    class Herzberger;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description

This class models optical properties of dielectric materials with Herzberger refractive index dispersion formula:

 @math{n_\lambda = A + B\times\lambda^2 + C\times\lambda^4 + D\times\lambda^6
               + \frac{E}{\lambda^2-0.028} + \frac{F}{\left(\lambda^2-0.028\right)^2}} 

with  @math{\lambda}  the micrometer wavelength.

@subheading Members

 See also the full member list (@pxref{material_Herzberger_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 36 members inherited from Dielectric (@pxref{material_Dielectric_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Herzberger()
@item Herzberger(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E@comma{} double F)
@item virtual double get_measurement_index(double wavelen) const
@item void set_coefficients(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E@comma{} double F)
@end itemize

@subheading Members detail

@subsubheading Herzberger()
@anchor{_571}

Create an empty herzberger model

@subsubheading Herzberger(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E@comma{} double F)
@anchor{_572}

Create an herzberger model with given coefficients

@subsubheading virtual double get_measurement_index(double wavelen) const
@anchor{_573}

This virtual function implements the @code{get_measurement_index (@pxref{_617})} pure function declared in the @code{Dielectric (@pxref{material_Dielectric_class_reference})} base abstract class.

Documentation inherited from base class:

Get material relative refractive index in measurment medium at specified wavelen in @emph{nm.}

@subsubheading void set_coefficients(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E@comma{} double F)
@anchor{_574}

Change herzberger constant term

@page

@heading material::Herzberger class full member list
@anchor{material_Herzberger_class_full_member_list}

@subheading Functions

@itemize
@item Herzberger()
@item Herzberger(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E@comma{} double F)
@item void clear_internal_transmittance()
@item void disable_temperature_coeff()
@item double get_abbe_vd() const
@item double get_abbe_ve() const
@item virtual io::rgb get_color() const
@item double get_density() const
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_measurement_index(double wavelen) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_partial_dispersion(double wavelen1@comma{} double wavelen2) const
@item double get_poisson_ratio() const
@item double get_principal_dispersion() const
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual double get_temperature() const
@item double get_thermal_conductivity() const
@item double get_thermal_expansion() const
@item data::DiscreteSet & get_transmittance_dataset()
@item double get_young_modulus() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_coefficients(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E@comma{} double F)
@item void set_density(double density)
@item void set_internal_transmittance(double wavelen@comma{} double thickness@comma{} double transmittance)
@item void set_measurement_medium(const const_ref<Base> &medium)
@item void set_poisson_ratio(double poisson_ratio)
@item void set_temperature(double temp)
@item void set_temperature_dndt(double dndt)
@item void set_temperature_schott(double d0@comma{} double d1@comma{} double d2@comma{} double e0@comma{} double e1@comma{} double wl_tk)
@item void set_thermal_conductivity(double thermal_conductivity)
@item void set_thermal_expansion(double thermal_expansion)
@item void set_wavelen_range(double low@comma{} double high)
@item void set_young_modulus(double young_modulus)
@end itemize

@page

@heading material::Metal class reference
@anchor{material_Metal_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/Metal>

namespace goptical @{
  namespace material @{
    class Metal;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description

This class models optical properties of metal materials. Extinction and refractive index are stored as interpolated data sets.

@subheading Members

 See also the full member list (@pxref{material_Metal_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 23 members inherited from Solid (@pxref{material_Solid_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Metal()
@item double get_absolute_refractive_index(double wavelen) const
@item virtual double get_extinction_coef(double wavelen) const
@item data::DiscreteSet & get_extinction_coef_dataset()
@item virtual double get_refractive_index(double wavelen) const
@item data::DiscreteSet & get_refractive_index_dataset()
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@end itemize

@subheading Members detail

@subsubheading Metal()
@anchor{_575}

No documentation available

@subsubheading double get_absolute_refractive_index(double wavelen) const
@anchor{_576}

No documentation available

@subsubheading virtual double get_extinction_coef(double wavelen) const
@anchor{_577}

This virtual function overrides the @code{get_extinction_coef (@pxref{_545})} virtual function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get extinction coefficient. Subclasses _must_ provide this function or the get_internal_transmittance() function.

@subsubheading data::DiscreteSet & get_extinction_coef_dataset()
@anchor{_578}

Get extinction dataset object

@subsubheading virtual double get_refractive_index(double wavelen) const
@anchor{_579}

This virtual function implements the @code{get_refractive_index (@pxref{_550})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get material absolute refractive index at specified wavelen in @emph{nm.}

@subsubheading data::DiscreteSet & get_refractive_index_dataset()
@anchor{_580}

Get refractive index dataset object

@subsubheading virtual bool is_opaque() const
@anchor{_581}

This virtual function implements the @code{is_opaque (@pxref{_553})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Return true if material must be considered opaque for ray tracing

@subsubheading virtual bool is_reflecting() const
@anchor{_582}

This virtual function implements the @code{is_reflecting (@pxref{_554})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Return true if material may reflect most of the light and must be considered as a mirror when ignoring ray intensity computation during ray tracing.

@page

@heading material::Metal class full member list
@anchor{material_Metal_class_full_member_list}

@subheading Functions

@itemize
@item Metal()
@item double get_absolute_refractive_index(double wavelen) const
@item virtual io::rgb get_color() const
@item double get_density() const
@item virtual double get_extinction_coef(double wavelen) const
@item data::DiscreteSet & get_extinction_coef_dataset()
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_poisson_ratio() const
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_refractive_index(double wavelen) const
@item data::DiscreteSet & get_refractive_index_dataset()
@item virtual double get_temperature() const
@item double get_thermal_conductivity() const
@item double get_thermal_expansion() const
@item double get_young_modulus() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_density(double density)
@item void set_poisson_ratio(double poisson_ratio)
@item void set_temperature(double temp)
@item void set_thermal_conductivity(double thermal_conductivity)
@item void set_thermal_expansion(double thermal_expansion)
@item void set_young_modulus(double young_modulus)
@end itemize

@page

@heading material::Mil class reference
@anchor{material_Mil_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/Mil>

namespace goptical @{
  namespace material @{
    class Mil;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description

This class is able to extract @emph{nd} index and @emph{vd} Abbe number values from glass code in order to model mil glass material. Glass code format is described in "@emph{MIL-G-174B}" standard.

See also Abbe (@pxref{material_Abbe_class_reference}) class.

@subheading Members

 See also the full member list (@pxref{material_Mil_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 36 members inherited from Abbe (@pxref{material_Abbe_class_reference})<AbbeVdFormula>
@end itemize

@subsubheading Function

@itemize
@item Mil(unsigned int code)
@end itemize

@subheading Members detail

@subsubheading Mil(unsigned int code)
@anchor{_583}

Create a glass model based on glass code with "@emph{nnnnvvv}" format.

@page

@heading material::Mil class full member list
@anchor{material_Mil_class_full_member_list}

@subheading Functions

@itemize
@item Mil(unsigned int code)
@item void clear_internal_transmittance()
@item void disable_temperature_coeff()
@item double get_abbe_vd() const
@item double get_abbe_ve() const
@item virtual io::rgb get_color() const
@item double get_density() const
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_measurement_index(double wavelen) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_partial_dispersion(double wavelen1@comma{} double wavelen2) const
@item double get_poisson_ratio() const
@item double get_principal_dispersion() const
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual double get_temperature() const
@item double get_thermal_conductivity() const
@item double get_thermal_expansion() const
@item data::DiscreteSet & get_transmittance_dataset()
@item double get_young_modulus() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_density(double density)
@item void set_internal_transmittance(double wavelen@comma{} double thickness@comma{} double transmittance)
@item void set_measurement_medium(const const_ref<Base> &medium)
@item void set_poisson_ratio(double poisson_ratio)
@item void set_temperature(double temp)
@item void set_temperature_dndt(double dndt)
@item void set_temperature_schott(double d0@comma{} double d1@comma{} double d2@comma{} double e0@comma{} double e1@comma{} double wl_tk)
@item void set_thermal_conductivity(double thermal_conductivity)
@item void set_thermal_expansion(double thermal_expansion)
@item void set_wavelen_range(double low@comma{} double high)
@item void set_young_modulus(double young_modulus)
@end itemize

@page

@heading material::mirror class reference
@anchor{material_mirror_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/mirror>

namespace goptical @{
  namespace material @{
    class mirror;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description

This class models optical properties of a perfect reflecting material.

A global mirror (@pxref{_527}) variable is available.

@subheading Members

 See also the full member list (@pxref{material_mirror_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 14 members inherited from Base (@pxref{material_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item mirror()
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@end itemize

@subheading Members detail

@subsubheading mirror()
@anchor{_584}

No documentation available

@subsubheading virtual double get_extinction_coef(double wavelen) const
@anchor{_585}

This virtual function overrides the @code{get_extinction_coef (@pxref{_545})} virtual function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get extinction coefficient. Subclasses _must_ provide this function or the get_internal_transmittance() function.

@subsubheading virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@anchor{_586}

This virtual function overrides the @code{get_internal_transmittance (@pxref{_546})} virtual function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get material internal transmittance for thickness in mm. Subclasses _must_ provide this function or the get_extinction_coef() function.

@subsubheading virtual double get_refractive_index(double wavelen) const
@anchor{_587}

This virtual function implements the @code{get_refractive_index (@pxref{_550})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get material absolute refractive index at specified wavelen in @emph{nm.}

@subsubheading virtual bool is_opaque() const
@anchor{_588}

This virtual function implements the @code{is_opaque (@pxref{_553})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Return true if material must be considered opaque for ray tracing

@subsubheading virtual bool is_reflecting() const
@anchor{_589}

This virtual function implements the @code{is_reflecting (@pxref{_554})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Return true if material may reflect most of the light and must be considered as a mirror when ignoring ray intensity computation during ray tracing.

@page

@heading material::mirror class full member list
@anchor{material_mirror_class_full_member_list}

@subheading Functions

@itemize
@item mirror()
@item virtual io::rgb get_color() const
@item virtual double get_extinction_coef(double wavelen) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual double get_temperature() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_temperature(double temp)
@end itemize

@page

@heading material::Schott class reference
@anchor{material_Schott_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/Schott>

namespace goptical @{
  namespace material @{
    class Schott;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description

This class models optical properties of dielectric materials with Schott refractive index dispersion formula:

 @math{n_\lambda = \sqrt{ \sum\limits_{i} A_{i}\times\lambda^{2i}}} 

with  @math{\lambda}  the micrometer wavelength.

@subheading Members

 See also the full member list (@pxref{material_Schott_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 36 members inherited from Dielectric (@pxref{material_Dielectric_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Schott()
@item Schott(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E@comma{} double F)
@item void set_term(int term@comma{} double K)
@item void set_terms_range(int first@comma{} int last)
@end itemize

@subheading Members detail

@subsubheading Schott()
@anchor{_590}

Create an empty schott model

@subsubheading Schott(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E@comma{} double F)
@anchor{_591}

Create a schott model with [-8@comma{}2] exponents range:

 @math{n_\lambda = \sqrt{ A + B\times\lambda^2 + \frac{C}{\lambda^2}
                  + \frac{D}{\lambda^4} + \frac{E}{\lambda^6} + \frac{F}{\lambda^8}}} 

@subsubheading void set_term(int term@comma{} double K)
@anchor{_592}

Set term coefficient@comma{} @samp{term} must be a multiple of 2.

@subsubheading void set_terms_range(int first@comma{} int last)
@anchor{_593}

Set exponents range@comma{} must be multiples of 2

@page

@heading material::Schott class full member list
@anchor{material_Schott_class_full_member_list}

@subheading Functions

@itemize
@item Schott()
@item Schott(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E@comma{} double F)
@item void clear_internal_transmittance()
@item void disable_temperature_coeff()
@item double get_abbe_vd() const
@item double get_abbe_ve() const
@item virtual io::rgb get_color() const
@item double get_density() const
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_partial_dispersion(double wavelen1@comma{} double wavelen2) const
@item double get_poisson_ratio() const
@item double get_principal_dispersion() const
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual double get_temperature() const
@item double get_thermal_conductivity() const
@item double get_thermal_expansion() const
@item data::DiscreteSet & get_transmittance_dataset()
@item double get_young_modulus() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_density(double density)
@item void set_internal_transmittance(double wavelen@comma{} double thickness@comma{} double transmittance)
@item void set_measurement_medium(const const_ref<Base> &medium)
@item void set_poisson_ratio(double poisson_ratio)
@item void set_temperature(double temp)
@item void set_temperature_dndt(double dndt)
@item void set_temperature_schott(double d0@comma{} double d1@comma{} double d2@comma{} double e0@comma{} double e1@comma{} double wl_tk)
@item void set_term(int term@comma{} double K)
@item void set_terms_range(int first@comma{} int last)
@item void set_thermal_conductivity(double thermal_conductivity)
@item void set_thermal_expansion(double thermal_expansion)
@item void set_wavelen_range(double low@comma{} double high)
@item void set_young_modulus(double young_modulus)
@end itemize

@page

@heading material::Sellmeier class reference
@anchor{material_Sellmeier_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/Sellmeier>

namespace goptical @{
  namespace material @{
    class Sellmeier;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description

This class models optical properties of dielectric materials using  @uref{http://en.wikipedia.org/wiki/Sellmeier_equation,,Sellmeier}  refractive index dispersion formula:

 @math{n_\lambda = \sqrt{ A + \sum\limits_{i}^{} \frac{B_i \times \lambda^2}{\lambda^2 - C_i}}} 

with  @math{\lambda}  the micrometer wavelength.

See also SellmeierMod (@pxref{material_SellmeierMod_class_reference}) class.

@subheading Members

 See also the full member list (@pxref{material_Sellmeier_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 36 members inherited from Dielectric (@pxref{material_Dielectric_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Sellmeier()
@item Sellmeier(double K1@comma{} double L1@comma{} double K2@comma{} double L2@comma{} double K3@comma{} double L3)
@item virtual double get_measurement_index(double wavelen) const
@item void set_contant_term(double A)
@item void set_term(unsigned int i@comma{} double B@comma{} double C)
@item void set_terms_count(unsigned int c)
@end itemize

@subheading Members detail

@subsubheading Sellmeier()
@anchor{_594}

Create an empty sellmeier model

@subsubheading Sellmeier(double K1@comma{} double L1@comma{} double K2@comma{} double L2@comma{} double K3@comma{} double L3)
@anchor{_595}

Create an 3rd order sellmeier model with given coefficients and 1.0 constant

@subsubheading virtual double get_measurement_index(double wavelen) const
@anchor{_596}

This virtual function implements the @code{get_measurement_index (@pxref{_617})} pure function declared in the @code{Dielectric (@pxref{material_Dielectric_class_reference})} base abstract class.

Documentation inherited from base class:

Get material relative refractive index in measurment medium at specified wavelen in @emph{nm.}

@subsubheading void set_contant_term(double A)
@anchor{_597}

Change sellmeier constant term

@subsubheading void set_term(unsigned int i@comma{} double B@comma{} double C)
@anchor{_598}

Set term coefficients

@subsubheading void set_terms_count(unsigned int c)
@anchor{_599}

Set terms count

@page

@heading material::Sellmeier class full member list
@anchor{material_Sellmeier_class_full_member_list}

@subheading Functions

@itemize
@item Sellmeier()
@item Sellmeier(double K1@comma{} double L1@comma{} double K2@comma{} double L2@comma{} double K3@comma{} double L3)
@item void clear_internal_transmittance()
@item void disable_temperature_coeff()
@item double get_abbe_vd() const
@item double get_abbe_ve() const
@item virtual io::rgb get_color() const
@item double get_density() const
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_measurement_index(double wavelen) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_partial_dispersion(double wavelen1@comma{} double wavelen2) const
@item double get_poisson_ratio() const
@item double get_principal_dispersion() const
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual double get_temperature() const
@item double get_thermal_conductivity() const
@item double get_thermal_expansion() const
@item data::DiscreteSet & get_transmittance_dataset()
@item double get_young_modulus() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_contant_term(double A)
@item void set_density(double density)
@item void set_internal_transmittance(double wavelen@comma{} double thickness@comma{} double transmittance)
@item void set_measurement_medium(const const_ref<Base> &medium)
@item void set_poisson_ratio(double poisson_ratio)
@item void set_temperature(double temp)
@item void set_temperature_dndt(double dndt)
@item void set_temperature_schott(double d0@comma{} double d1@comma{} double d2@comma{} double e0@comma{} double e1@comma{} double wl_tk)
@item void set_term(unsigned int i@comma{} double B@comma{} double C)
@item void set_terms_count(unsigned int c)
@item void set_thermal_conductivity(double thermal_conductivity)
@item void set_thermal_expansion(double thermal_expansion)
@item void set_wavelen_range(double low@comma{} double high)
@item void set_young_modulus(double young_modulus)
@end itemize

@page

@heading material::SellmeierMod class reference
@anchor{material_SellmeierMod_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/SellmeierMod>

namespace goptical @{
  namespace material @{
    template <enum SellmeierModFormula m> class SellmeierMod;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description

This class models optical properties of dielectric materials with various modified Sellmeier formulas:

@itemize
@item 
SellmeierMod2 (@pxref{_524}) :  @math{n_\lambda = \sqrt{A + \frac{B\times\lambda^2}{\lambda^2 - C^2} 
                                 + \frac{D}{\lambda^2 - E^2}}} 

@item 
Handbook1 (@pxref{_522}) :  @math{n_\lambda = \sqrt{A + B\times\lambda^2 + \frac{C}{\lambda^2-D}}} 

@item 
Handbook2 (@pxref{_523}) :  @math{n_\lambda = \sqrt{A + B\times\lambda^2 + \frac{C\times\lambda^2}{\lambda^2-D}}} 

@end itemize

with  @math{\lambda}  the micrometer wavelength.

See also Sellmeier (@pxref{material_Sellmeier_class_reference}) class.

@subheading Members

 See also the full member list (@pxref{material_SellmeierMod_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 36 members inherited from Dielectric (@pxref{material_Dielectric_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item SellmeierMod()
@item SellmeierMod(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E = @emph{[...]})
@item virtual double get_measurement_index(double wavelen) const
@item void set_coefficients(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E = @emph{[...]})
@end itemize

@subheading Members detail

@subsubheading SellmeierMod()
@anchor{_600}

Create an empty modified sellmeier model

@subsubheading SellmeierMod(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E = 0.0)
@anchor{_601}

Create a modified sellmeier model with given coefficients

@subsubheading virtual double get_measurement_index(double wavelen) const
@anchor{_602}

This virtual function implements the @code{get_measurement_index (@pxref{_617})} pure function declared in the @code{Dielectric (@pxref{material_Dielectric_class_reference})} base abstract class.

Documentation inherited from base class:

Get material relative refractive index in measurment medium at specified wavelen in @emph{nm.}

@subsubheading void set_coefficients(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E = 0.0)
@anchor{_603}

Change coefficients

@page

@heading material::SellmeierMod class full member list
@anchor{material_SellmeierMod_class_full_member_list}

@subheading Functions

@itemize
@item SellmeierMod()
@item SellmeierMod(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E = @emph{[...]})
@item void clear_internal_transmittance()
@item void disable_temperature_coeff()
@item double get_abbe_vd() const
@item double get_abbe_ve() const
@item virtual io::rgb get_color() const
@item double get_density() const
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_measurement_index(double wavelen) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_partial_dispersion(double wavelen1@comma{} double wavelen2) const
@item double get_poisson_ratio() const
@item double get_principal_dispersion() const
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual double get_temperature() const
@item double get_thermal_conductivity() const
@item double get_thermal_expansion() const
@item data::DiscreteSet & get_transmittance_dataset()
@item double get_young_modulus() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_coefficients(double A@comma{} double B@comma{} double C@comma{} double D@comma{} double E = @emph{[...]})
@item void set_density(double density)
@item void set_internal_transmittance(double wavelen@comma{} double thickness@comma{} double transmittance)
@item void set_measurement_medium(const const_ref<Base> &medium)
@item void set_poisson_ratio(double poisson_ratio)
@item void set_temperature(double temp)
@item void set_temperature_dndt(double dndt)
@item void set_temperature_schott(double d0@comma{} double d1@comma{} double d2@comma{} double e0@comma{} double e1@comma{} double wl_tk)
@item void set_thermal_conductivity(double thermal_conductivity)
@item void set_thermal_expansion(double thermal_expansion)
@item void set_wavelen_range(double low@comma{} double high)
@item void set_young_modulus(double young_modulus)
@end itemize

@page

@heading material::Vacuum class reference
@anchor{material_Vacuum_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/Vacuum>

namespace goptical @{
  namespace material @{
    class Vacuum;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description

This class models optical properties of vacuum. A global variable vacuum (@pxref{_530}) is available.

@subheading Members

 See also the full member list (@pxref{material_Vacuum_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 14 members inherited from Base (@pxref{material_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Vacuum()
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@end itemize

@subheading Members detail

@subsubheading Vacuum()
@anchor{_604}

No documentation available

@subsubheading virtual double get_extinction_coef(double wavelen) const
@anchor{_605}

This virtual function overrides the @code{get_extinction_coef (@pxref{_545})} virtual function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get extinction coefficient. Subclasses _must_ provide this function or the get_internal_transmittance() function.

@subsubheading virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@anchor{_606}

This virtual function overrides the @code{get_internal_transmittance (@pxref{_546})} virtual function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get material internal transmittance for thickness in mm. Subclasses _must_ provide this function or the get_extinction_coef() function.

@subsubheading virtual double get_refractive_index(double wavelen) const
@anchor{_607}

This virtual function implements the @code{get_refractive_index (@pxref{_550})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get material absolute refractive index at specified wavelen in @emph{nm.}

@subsubheading virtual bool is_opaque() const
@anchor{_608}

This virtual function implements the @code{is_opaque (@pxref{_553})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Return true if material must be considered opaque for ray tracing

@subsubheading virtual bool is_reflecting() const
@anchor{_609}

This virtual function implements the @code{is_reflecting (@pxref{_554})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Return true if material may reflect most of the light and must be considered as a mirror when ignoring ray intensity computation during ray tracing.

@page

@heading material::Vacuum class full member list
@anchor{material_Vacuum_class_full_member_list}

@subheading Functions

@itemize
@item Vacuum()
@item virtual io::rgb get_color() const
@item virtual double get_extinction_coef(double wavelen) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual double get_temperature() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_temperature(double temp)
@end itemize

@page

@heading material::Dielectric class reference
@anchor{material_Dielectric_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/Dielectric>

namespace goptical @{
  namespace material @{
    class Dielectric;
  @};
@};

@end example

 This class is a member of the material namespace.

This abstract class contains pure virtuals.

@subheading Inheritance

@subheading Description

This class models optical properties of dielectric materials. Transmittance values are stored in an data::Set (@pxref{data_Set_class_reference}) object with data::Cubic (@pxref{_146}) interpolation enabled.

Child class has to implement the get_measurement_index (@pxref{_617}) function which must return relative refractive index as measured in medium material set by set_measurement_medium (@pxref{_625}) function. Default measurement medium is std_air (@pxref{_529}).

The relative refractive index together with the absolute refractive index of measurement medium are used to compute absolute refractive index of dielectric material at reference temperature. This is the value returned by the get_refractive_index (@pxref{_620}) function when no temperature model is in use.

Temperature coeffiecients can be defined to take current material temperature into account when computing absolute refractive index:

@itemize
@item 
The set_temperature_dndt (@pxref{_626}) function enables use of refractive index temperature deviation factor.

@item 
The set_temperature_schott (@pxref{_627}) function enables Schott temperature model as described in Schott "@emph{TIE-19: Temperature Coefficient of the Refractive Index}" technical information document. It uses the following formula:

 @math{n_t = \frac{{n}^{2}-1.0}{2\times n} \times \Delta t
                 \times \left( \frac{\Delta t\times E_1+E_0}{{\lambda}^{2}-{\lambda_{tk}}^{2}} +
                 D_2\times {\Delta t}^{2}+D_1\times \Delta t+D_0 \right)} 

with  @math{\Delta t = t - t_{ref}}  and  @math{\lambda}  the micrometer wavelength.

@end itemize

@subheading Members

 See also the full member list (@pxref{material_Dielectric_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 23 members inherited from Solid (@pxref{material_Solid_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Dielectric()
@item void clear_internal_transmittance()
@item void disable_temperature_coeff()
@item double get_abbe_vd() const
@item double get_abbe_ve() const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_measurement_index(double wavelen) const = 0;
@item double get_partial_dispersion(double wavelen1@comma{} double wavelen2) const
@item double get_principal_dispersion() const
@item virtual double get_refractive_index(double wavelen) const
@item data::DiscreteSet & get_transmittance_dataset()
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_internal_transmittance(double wavelen@comma{} double thickness@comma{} double transmittance)
@item void set_measurement_medium(const const_ref<Base> &medium)
@item void set_temperature_dndt(double dndt)
@item void set_temperature_schott(double d0@comma{} double d1@comma{} double d2@comma{} double e0@comma{} double e1@comma{} double wl_tk)
@item void set_wavelen_range(double low@comma{} double high)
@end itemize

@subheading Members detail

@subsubheading Dielectric()
@anchor{_610}

No documentation available

@subsubheading void clear_internal_transmittance()
@anchor{_611}

Clear all transmittance data. Returned transmittance value is always 1.0 when the data set is empty.

See also get_transmittance_dataset (@pxref{_621}) function.

@subsubheading void disable_temperature_coeff()
@anchor{_612}

Disable use of temperature coefficients

@subsubheading double get_abbe_vd() const
@anchor{_613}

Compute glass Abbe number from refractive index model. Use d spectral line. Wavelen is in @emph{nm}

@subsubheading double get_abbe_ve() const
@anchor{_614}

Compute glass Abbe number from refractive index model. Use d spectral line. Wavelen is in @emph{nm}

@subsubheading virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@anchor{_615}

This virtual function overrides the @code{get_internal_transmittance (@pxref{_546})} virtual function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get material internal transmittance for thickness in mm. Subclasses _must_ provide this function or the get_extinction_coef() function.

@subsubheading double get_internal_transmittance(double wavelen) const
@anchor{_616}

This function shadows the @code{get_internal_transmittance (@pxref{_547})} function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get material internal transmittance for 1mm thickness.

@subsubheading virtual double get_measurement_index(double wavelen) const = 0;
@anchor{_617}

Get material relative refractive index in measurment medium at specified wavelen in @emph{nm.}

@subsubheading double get_partial_dispersion(double wavelen1@comma{} double wavelen2) const
@anchor{_618}

Compute glass partial dispersion between two wavelen in @emph{nm}

@subsubheading double get_principal_dispersion() const
@anchor{_619}

Compute glass principal dispersion.

@subsubheading virtual double get_refractive_index(double wavelen) const
@anchor{_620}

This virtual function implements the @code{get_refractive_index (@pxref{_550})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get material absolute refractive index at specified wavelen in @emph{nm.}

@subsubheading data::DiscreteSet & get_transmittance_dataset()
@anchor{_621}

Get internal tranmittance dataset object.

See also clear_internal_transmittance (@pxref{_611}) function.

@subsubheading virtual bool is_opaque() const
@anchor{_622}

This virtual function implements the @code{is_opaque (@pxref{_553})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Return true if material must be considered opaque for ray tracing

@subsubheading virtual bool is_reflecting() const
@anchor{_623}

This virtual function implements the @code{is_reflecting (@pxref{_554})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Return true if material may reflect most of the light and must be considered as a mirror when ignoring ray intensity computation during ray tracing.

@subsubheading void set_internal_transmittance(double wavelen@comma{} double thickness@comma{} double transmittance)
@anchor{_624}

Add transmittance data@comma{} wavelen in nm

@subsubheading void set_measurement_medium(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <Base> &medium)
@anchor{_625}

Set glass measurement medium material.

@subsubheading void set_temperature_dndt(double dndt)
@anchor{_626}

Set and enable dn/dt thermal coefficient.

@subsubheading void set_temperature_schott(double d0@comma{} double d1@comma{} double d2@comma{} double e0@comma{} double e1@comma{} double wl_tk)
@anchor{_627}

Set and enable Schott thermal coefficients. wl_tk in @emph{um.}

@subsubheading void set_wavelen_range(double low@comma{} double high)
@anchor{_628}

Set wavelen validity range in @emph{nm}

@page

@heading material::Dielectric class full member list
@anchor{material_Dielectric_class_full_member_list}

@subheading Functions

@itemize
@item Dielectric()
@item void clear_internal_transmittance()
@item void disable_temperature_coeff()
@item double get_abbe_vd() const
@item double get_abbe_ve() const
@item virtual io::rgb get_color() const
@item double get_density() const
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_measurement_index(double wavelen) const = 0;
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_partial_dispersion(double wavelen1@comma{} double wavelen2) const
@item double get_poisson_ratio() const
@item double get_principal_dispersion() const
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual double get_temperature() const
@item double get_thermal_conductivity() const
@item double get_thermal_expansion() const
@item data::DiscreteSet & get_transmittance_dataset()
@item double get_young_modulus() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_density(double density)
@item void set_internal_transmittance(double wavelen@comma{} double thickness@comma{} double transmittance)
@item void set_measurement_medium(const const_ref<Base> &medium)
@item void set_poisson_ratio(double poisson_ratio)
@item void set_temperature(double temp)
@item void set_temperature_dndt(double dndt)
@item void set_temperature_schott(double d0@comma{} double d1@comma{} double d2@comma{} double e0@comma{} double e1@comma{} double wl_tk)
@item void set_thermal_conductivity(double thermal_conductivity)
@item void set_thermal_expansion(double thermal_expansion)
@item void set_wavelen_range(double low@comma{} double high)
@item void set_young_modulus(double young_modulus)
@end itemize

@page

@heading material::Proxy class reference
@anchor{material_Proxy_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/Proxy>

namespace goptical @{
  namespace material @{
    class Proxy;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description
Optical material proxy class.
@subheading Members

 See also the full member list (@pxref{material_Proxy_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 14 members inherited from Base (@pxref{material_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Proxy(const const_ref<Base> &m)
@item virtual io::rgb get_color() const
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item const Base & get_material() const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual double get_temperature() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_material(const const_ref<Base> &m)
@end itemize

@subheading Members detail

@subsubheading Proxy(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <Base> &m)
@anchor{_629}

No documentation available

@subsubheading virtual io::rgb get_color() const
@anchor{_630}

This virtual function overrides the @code{get_color (@pxref{_544})} virtual function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get material color and alpha

@subsubheading virtual double get_extinction_coef(double wavelen) const
@anchor{_631}

This virtual function overrides the @code{get_extinction_coef (@pxref{_545})} virtual function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get extinction coefficient. Subclasses _must_ provide this function or the get_internal_transmittance() function.

@subsubheading virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@anchor{_632}

This virtual function overrides the @code{get_internal_transmittance (@pxref{_546})} virtual function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get material internal transmittance for thickness in mm. Subclasses _must_ provide this function or the get_extinction_coef() function.

@subsubheading const Base & get_material() const
@anchor{_633}

No documentation available

@subsubheading virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@anchor{_634}

This virtual function overrides the @code{get_normal_reflectance (@pxref{_548})} virtual function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get reflectance at normal incidence

@subsubheading virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@anchor{_635}

This virtual function overrides the @code{get_normal_transmittance (@pxref{_549})} virtual function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get transmittance at normal incidence

@subsubheading virtual double get_refractive_index(double wavelen) const
@anchor{_636}

This virtual function implements the @code{get_refractive_index (@pxref{_550})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get material absolute refractive index at specified wavelen in @emph{nm.}

@subsubheading virtual double get_temperature() const
@anchor{_637}

This virtual function overrides the @code{get_temperature (@pxref{_552})} virtual function defined in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get material temperature in celcius

@subsubheading virtual bool is_opaque() const
@anchor{_638}

This virtual function implements the @code{is_opaque (@pxref{_553})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Return true if material must be considered opaque for ray tracing

@subsubheading virtual bool is_reflecting() const
@anchor{_639}

This virtual function implements the @code{is_reflecting (@pxref{_554})} pure function declared in the @code{Base (@pxref{material_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Return true if material may reflect most of the light and must be considered as a mirror when ignoring ray intensity computation during ray tracing.

@subsubheading void set_material(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <Base> &m)
@anchor{_640}

No documentation available

@page

@heading material::Proxy class full member list
@anchor{material_Proxy_class_full_member_list}

@subheading Functions

@itemize
@item Proxy(const const_ref<Base> &m)
@item virtual io::rgb get_color() const
@item virtual double get_extinction_coef(double wavelen) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item const Base & get_material() const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_refractive_index(double wavelen) const
@item virtual double get_temperature() const
@item virtual bool is_opaque() const
@item virtual bool is_reflecting() const
@item void set_material(const const_ref<Base> &m)
@item void set_temperature(double temp)
@end itemize

@page

@heading material::Solid class reference
@anchor{material_Solid_class_reference}

@subheading Declaration

@example
#include <goptical/core/material/Solid>

namespace goptical @{
  namespace material @{
    class Solid;
  @};
@};

@end example

 This class is a member of the material namespace.

@subheading Inheritance

@subheading Description

This class is the base class for all solid material models.

@subheading Members

 See also the full member list (@pxref{material_Solid_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 14 members inherited from Base (@pxref{material_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Solid()
@item double get_density() const
@item double get_poisson_ratio() const
@item double get_thermal_conductivity() const
@item double get_thermal_expansion() const
@item double get_young_modulus() const
@item void set_density(double density)
@item void set_poisson_ratio(double poisson_ratio)
@item void set_thermal_conductivity(double thermal_conductivity)
@item void set_thermal_expansion(double thermal_expansion)
@item void set_young_modulus(double young_modulus)
@end itemize

@subheading Members detail

@subsubheading Solid()
@anchor{_641}

No documentation available

@subsubheading double get_density() const
@anchor{_642}

 Get material density in g/cm^3.

See also set_density (@pxref{_647}) function.

@subsubheading double get_poisson_ratio() const
@anchor{_643}

 Get material poisson ratio.

See also set_poisson_ratio (@pxref{_648}) function.

@subsubheading double get_thermal_conductivity() const
@anchor{_644}

 Get Set material thermal conductivity in W/m.K.

See also set_thermal_conductivity (@pxref{_649}) function.

@subsubheading double get_thermal_expansion() const
@anchor{_645}

 Get material thermal expansion coefficient.

See also set_thermal_expansion (@pxref{_650}) function.

@subsubheading double get_young_modulus() const
@anchor{_646}

 Get material young modulus.

See also set_young_modulus (@pxref{_651}) function.

@subsubheading void set_density(double density)
@anchor{_647}

 Set material density in g/cm^3.

See also get_density (@pxref{_642}) function.

@subsubheading void set_poisson_ratio(double poisson_ratio)
@anchor{_648}

 Set material poisson ratio.

See also get_poisson_ratio (@pxref{_643}) function.

@subsubheading void set_thermal_conductivity(double thermal_conductivity)
@anchor{_649}

 Set Set material thermal conductivity in W/m.K.

See also get_thermal_conductivity (@pxref{_644}) function.

@subsubheading void set_thermal_expansion(double thermal_expansion)
@anchor{_650}

 Set material thermal expansion coefficient.

See also get_thermal_expansion (@pxref{_645}) function.

@subsubheading void set_young_modulus(double young_modulus)
@anchor{_651}

 Set material young modulus.

See also get_young_modulus (@pxref{_646}) function.

@page

@heading material::Solid class full member list
@anchor{material_Solid_class_full_member_list}

@subheading Functions

@itemize
@item Solid()
@item virtual io::rgb get_color() const
@item double get_density() const
@item virtual double get_extinction_coef(double wavelen) const
@item virtual double get_internal_transmittance(double wavelen@comma{} double thickness) const
@item double get_internal_transmittance(double wavelen) const
@item virtual double get_normal_reflectance(const Base *from@comma{} double wavelen) const
@item virtual double get_normal_transmittance(const Base *from@comma{} double wavelen) const
@item double get_poisson_ratio() const
@item virtual double get_refractive_index(double wavelen) const = 0;
@item double get_refractive_index(double wavelen@comma{} const Base &env) const
@item virtual double get_temperature() const
@item double get_thermal_conductivity() const
@item double get_thermal_expansion() const
@item double get_young_modulus() const
@item virtual bool is_opaque() const = 0;
@item virtual bool is_reflecting() const = 0;
@item void set_density(double density)
@item void set_poisson_ratio(double poisson_ratio)
@item void set_temperature(double temp)
@item void set_thermal_conductivity(double thermal_conductivity)
@item void set_thermal_expansion(double thermal_expansion)
@item void set_young_modulus(double young_modulus)
@end itemize

@page

@heading math namespace reference
@anchor{math_namespace_reference}

@subheading Description
mathematical tools and functions
@subheading Members

@subsubheading Types

@itemize
@item typedef @emph{ [...] } vector2
@item typedef @emph{ [...] } vector3
@item typedef @emph{ [...] } vectorPair3
@item template struct Matrix
@item typedef @emph{ [...] } Matrix3x3
@item class Quaternion
@item template class Transform<3>
@item template class Transform<2>
@item typedef @emph{ [...] } Transform2
@item typedef @emph{ [...] } Transform3
@item template struct Triangle
@item template struct Triangle<3>
@item template struct vector
@item template struct vector<3@comma{} T>
@item template struct vector<2@comma{} T>
@item template struct vectorPair
@item template struct vectorPair<2>
@item template struct vectorPair<3>
@item typedef @emph{ [...] } vectorPair2
@item typedef @emph{ [...] } range_t
@end itemize

@subsubheading Functions

@itemize
@item double degree2rad(double x)
@item void get_rotation_matrix(Matrix<2> &m@comma{} unsigned int axis@comma{} double rangle)
@item void get_rotation_matrix(Matrix<3> &m@comma{} unsigned int axis@comma{} double rangle)
@item double lp_floor(double x@comma{} double n)
@item double lp_mod(double x@comma{} double n)
@item template std::ostream & operator<<(std::ostream &o@comma{} const vectorBase<N@comma{} T> &v)
@item template std::ostream & operator<<(std::ostream &o@comma{} const vectorPairBase<N> &l)
@item template std::ostream & operator<<(std::ostream &o@comma{} const Matrix<N> &m)
@item std::ostream & operator<<(std::ostream &o@comma{} const Quaternion &q)
@item template std::ostream & operator<<(std::ostream &o@comma{} const TransformBase<N> &t)
@item template std::ostream & operator<<(std::ostream &o@comma{} const Triangle<N> &l)
@item double rad2degree(double x)
@item double square(double x)
@end itemize

@subsubheading Constants

@itemize
@item const vector2 vector2_0
@item const vector2 vector2_01
@item const vector2 vector2_1
@item const vector2 vector2_10
@item const vectorPair<2> vector2_pair_00
@item const vectorPair<2> vector2_pair_01
@item const vector3 vector3_0
@item const vector3 vector3_001
@item const vector3 vector3_010
@item const vector3 vector3_1
@item const vector3 vector3_100
@item const vectorPair<3> vector3_pair_00
@item const vectorPair<3> vector3_pair_01
@end itemize

@subheading Members detail

@subsubheading typedef vector<2@comma{} double> vector2
@anchor{_652}

See vector (@pxref{math_vector_2_T_struct_reference})<2@comma{} T> struct.

@subsubheading typedef vector<3@comma{} double> vector3
@anchor{_653}

See vector (@pxref{math_vector_3_T_struct_reference})<3@comma{} T> struct.

@subsubheading typedef vectorPair<3> vectorPair3
@anchor{_654}

See vectorPair (@pxref{math_vectorPair_3_struct_reference})<3> struct.

@subsubheading typedef Matrix<3> Matrix3x3
@anchor{_655}

No documentation available

@subsubheading typedef Transform<2> Transform2
@anchor{_656}

See Transform (@pxref{math_Transform_2_class_reference})<2> class.

@subsubheading typedef Transform<3> Transform3
@anchor{_657}

See Transform (@pxref{math_Transform_3_class_reference})<3> class.

@subsubheading typedef vectorPair<2> vectorPair2
@anchor{_658}

See vectorPair (@pxref{math_vectorPair_2_struct_reference})<2> struct.

@subsubheading double degree2rad(double x)
@anchor{_659}

Convert from degrees to radians

@subsubheading void get_rotation_matrix(Matrix<2> &m@comma{} unsigned int axis@comma{} double rangle)
@anchor{_660}

Setup a 2d rotation matrix with specified angle in radian. axis parameter must be 0.

@subsubheading void get_rotation_matrix(Matrix<3> &m@comma{} unsigned int axis@comma{} double rangle)
@anchor{_661}

Setup a 3d rotation matrix with specified angle in radian. axis parameter can be 0@comma{} 1 or 2 for x@comma{} y and z axes.

@subsubheading double lp_floor(double x@comma{} double n)
@anchor{_662}

No documentation available

@subsubheading double lp_mod(double x@comma{} double n)
@anchor{_663}

No documentation available

@subsubheading template <int N@comma{} typename T> std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  & operator<<(std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  &o@comma{} const vectorBase<N@comma{} T> &v)
@anchor{_664}

No documentation available

@subsubheading template <int N> std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  & operator<<(std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  &o@comma{} const vectorPairBase<N> &l)
@anchor{_665}

No documentation available

@subsubheading template <int N> std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  & operator<<(std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  &o@comma{} const Matrix<N> &m)
@anchor{_666}

No documentation available

@subsubheading std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  & operator<<(std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  &o@comma{} const Quaternion &q)
@anchor{_667}

No documentation available

@subsubheading template <int N> std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  & operator<<(std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  &o@comma{} const TransformBase<N> &t)
@anchor{_668}

No documentation available

@subsubheading template <int N> std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  & operator<<(std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  &o@comma{} const Triangle<N> &l)
@anchor{_669}

No documentation available

@subsubheading double rad2degree(double x)
@anchor{_670}

Convert from radians to degrees

@subsubheading typedef std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01149.html,,pair} <double@comma{} double> range_t
@anchor{_671}

No documentation available

@subsubheading double square(double x)
@anchor{_672}

Compute square

@subsubheading const vector2 vector2_0 = vector2(0.0@comma{}0.0)
@anchor{_673}

 Commonly used vector constant

@subsubheading const vector2 vector2_01
@anchor{_674}

 Commonly used vector constant

@subsubheading const vector2 vector2_1
@anchor{_675}

 Commonly used vector constant

@subsubheading const vector2 vector2_10
@anchor{_676}

 Commonly used vector constant

@subsubheading const vectorPair<2> vector2_pair_00
@anchor{_677}

No documentation available

@subsubheading const vectorPair<2> vector2_pair_01
@anchor{_678}

No documentation available

@subsubheading const vector3 vector3_0
@anchor{_679}

 Commonly used vector constant

@subsubheading const vector3 vector3_001
@anchor{_680}

 Commonly used vector constant

@subsubheading const vector3 vector3_010
@anchor{_681}

 Commonly used vector constant

@subsubheading const vector3 vector3_1
@anchor{_682}

 Commonly used vector constant

@subsubheading const vector3 vector3_100
@anchor{_683}

 Commonly used vector constant

@subsubheading const vectorPair<3> vector3_pair_00
@anchor{_684}

No documentation available

@subsubheading const vectorPair<3> vector3_pair_01
@anchor{_685}

No documentation available

@page

@heading math::Matrix struct reference
@anchor{math_Matrix_struct_reference}

@subheading Declaration

@example
#include <goptical/core/math/Matrix>

namespace goptical @{
  namespace math @{
    template <int N> struct Matrix;
  @};
@};

@end example

 This struct is a member of the math namespace.

@subheading Description
NxN square matrix class.
@subheading Members

 See also the full member list (@pxref{math_Matrix_struct_full_member_list}) section for this struct.

@subsubheading Functions

@itemize
@item void adjugate(Matrix &result) const
@item Matrix adjugate() const
@item double determinant() const
@item void inverse(Matrix &result) const
@item Matrix inverse() const
@item Matrix operator*(double scale) const
@item Matrix operator*(const Matrix &m) const
@item vector<N> operator*(const vector<N> &v) const
@item Matrix operator+(const Matrix &m) const
@item Matrix operator-(const Matrix &m) const
@item Matrix operator/(double scale) const
@item Matrix & set(double value = @emph{[...]})
@item Matrix & set_col(int col@comma{} double value)
@item Matrix & set_col(int col@comma{} const vector<N> &v)
@item Matrix & set_diag(double value = @emph{[...]})
@item Matrix & set_diag(const vector<N> &v)
@item Matrix & set_id()
@item Matrix & set_row(int row@comma{} double value)
@item Matrix & set_row(int row@comma{} const vector<N> &v)
@item void transpose(Matrix &result) const
@item Matrix transpose() const
@item double value(int x@comma{} int y) const
@item double & value(int x@comma{} int y)
@end itemize

@subheading Members detail

@subsubheading void adjugate(Matrix &result) const
@anchor{_686}

replace matrix by the adjugate matrix

@subsubheading Matrix adjugate() const
@anchor{_687}

Get the adjugate matrix

@subsubheading double determinant() const
@anchor{_688}

compute matrix determinant

@subsubheading void inverse(Matrix &result) const
@anchor{_689}

replace matrix by the inverse matrix

@subsubheading Matrix inverse() const
@anchor{_690}

Get the inverse matrix

@subsubheading Matrix operator*(double scale) const
@anchor{_691}

Scale matrix

@subsubheading Matrix operator*(const Matrix &m) const
@anchor{_692}

Multiply matrix

@subsubheading vector<N> operator*(const vector<N> &v) const
@anchor{_693}

Multiply matrix with vector. See vector class for vector/matrix multiplication.

@subsubheading Matrix operator+(const Matrix &m) const
@anchor{_694}

Add matrix

@subsubheading Matrix operator-(const Matrix &m) const
@anchor{_695}

Subtract matrix

@subsubheading Matrix operator/(double scale) const
@anchor{_696}

Scale matrix

@subsubheading Matrix & set(double value = 0)
@anchor{_697}

Set whole matrix to specified value.

@subsubheading Matrix & set_col(int col@comma{} double value)
@anchor{_698}

Set whole matrix column to specified value.

@subsubheading Matrix & set_col(int col@comma{} const vector<N> &v)
@anchor{_699}

Set matrix column to specified vector.

@subsubheading Matrix & set_diag(double value = 1)
@anchor{_700}

Set matrix diagonal to specified value.

@subsubheading Matrix & set_diag(const vector<N> &v)
@anchor{_701}

Set matrix diagonal to specified value.

@subsubheading Matrix & set_id()
@anchor{_702}

Setup an identity matrix.

@subsubheading Matrix & set_row(int row@comma{} double value)
@anchor{_703}

Set whole matrix row to specified value.

@subsubheading Matrix & set_row(int row@comma{} const vector<N> &v)
@anchor{_704}

Set matrix row to specified vector.

@subsubheading void transpose(Matrix &result) const
@anchor{_705}

replace matrix by the transposed matrix

@subsubheading Matrix transpose() const
@anchor{_706}

Get the transposed matrix

@subsubheading double value(int x@comma{} int y) const
@anchor{_707}

Get value at x row and y column

@subsubheading double & value(int x@comma{} int y)
@anchor{_708}

Get modifiable reference to value at x row and y column

@page

@heading math::Matrix struct full member list
@anchor{math_Matrix_struct_full_member_list}

@subheading Functions

@itemize
@item void adjugate(Matrix &result) const
@item Matrix adjugate() const
@item double determinant() const
@item void inverse(Matrix &result) const
@item Matrix inverse() const
@item Matrix operator*(double scale) const
@item Matrix operator*(const Matrix &m) const
@item vector<N> operator*(const vector<N> &v) const
@item Matrix operator+(const Matrix &m) const
@item Matrix operator-(const Matrix &m) const
@item Matrix operator/(double scale) const
@item Matrix & set(double value = @emph{[...]})
@item Matrix & set_col(int col@comma{} double value)
@item Matrix & set_col(int col@comma{} const vector<N> &v)
@item Matrix & set_diag(double value = @emph{[...]})
@item Matrix & set_diag(const vector<N> &v)
@item Matrix & set_id()
@item Matrix & set_row(int row@comma{} double value)
@item Matrix & set_row(int row@comma{} const vector<N> &v)
@item void transpose(Matrix &result) const
@item Matrix transpose() const
@item double value(int x@comma{} int y) const
@item double & value(int x@comma{} int y)
@end itemize

@page

@heading math::Quaternion class reference
@anchor{math_Quaternion_class_reference}

@subheading Declaration

@example
#include <goptical/core/math/Quaternion>

namespace goptical @{
  namespace math @{
    class Quaternion;
  @};
@};

@end example

 This class is a member of the math namespace.

@subheading Description

This class describe a quaternion object. Useful for 3d rotations.

@subheading Members

 See also the full member list (@pxref{math_Quaternion_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item Quaternion()
@item Quaternion(double x@comma{} double y@comma{} double z@comma{} double w)
@item Quaternion(const vector3 &a@comma{} const vector3 &b)
@item double norm() const
@item const Quaternion & normalize()
@item Quaternion operator*(const Quaternion &q) const
@item double w() const
@item double & w()
@item double x() const
@item double & x()
@item double y() const
@item double & y()
@item double z() const
@item double & z()
@end itemize

@subsubheading Static functions

@itemize
@item static Quaternion angle(const vector3 &v@comma{} double angle)
@item static Quaternion angle_rad(const vector3 &v@comma{} double angle)
@end itemize

@subheading Members detail

@subsubheading Quaternion()
@anchor{_709}

No documentation available

@subsubheading Quaternion(double x@comma{} double y@comma{} double z@comma{} double w)
@anchor{_710}

Create a Quaternion from its real values

@subsubheading Quaternion(const vector3 &a@comma{} const vector3 &b)
@anchor{_711}

Create a Quaternion as rotation between two unit vectors

@subsubheading static Quaternion angle(const vector3 &v@comma{} double angle)
@anchor{_712}

Create a Quaternion with given rotation angle along a 3d vector

@subsubheading static Quaternion angle_rad(const vector3 &v@comma{} double angle)
@anchor{_713}

Create a Quaternion with given rotation angle in radian along a 3d vector

@subsubheading double norm() const
@anchor{_714}

Adjust vector length

@subsubheading const Quaternion & normalize()
@anchor{_715}

Normalize vector length

@subsubheading Quaternion operator*(const Quaternion &q) const
@anchor{_716}

Multiply with an other quaternion

@subsubheading double w() const
@anchor{_717}

Get quaterion w value

@subsubheading double & w()
@anchor{_718}

Get reference to quaterion w value

@subsubheading double x() const
@anchor{_719}

Get quaterion x value

@subsubheading double & x()
@anchor{_720}

Get reference to quaterion x value

@subsubheading double y() const
@anchor{_721}

Get quaterion y value

@subsubheading double & y()
@anchor{_722}

Get reference to quaterion y value

@subsubheading double z() const
@anchor{_723}

Get quaterion z value

@subsubheading double & z()
@anchor{_724}

Get reference to quaterion z value

@page

@heading math::Quaternion class full member list
@anchor{math_Quaternion_class_full_member_list}

@subheading Functions

@itemize
@item Quaternion()
@item Quaternion(double x@comma{} double y@comma{} double z@comma{} double w)
@item Quaternion(const vector3 &a@comma{} const vector3 &b)
@item double norm() const
@item const Quaternion & normalize()
@item Quaternion operator*(const Quaternion &q) const
@item double w() const
@item double & w()
@item double x() const
@item double & x()
@item double y() const
@item double & y()
@item double z() const
@item double & z()
@end itemize

@subheading Static functions

@itemize
@item static Quaternion angle(const vector3 &v@comma{} double angle)
@item static Quaternion angle_rad(const vector3 &v@comma{} double angle)
@end itemize

@page

@heading math::Transform<3> class reference
@anchor{math_Transform_3_class_reference}

@subheading Declaration

@example
#include <goptical/core/math/Transform>

namespace goptical @{
  namespace math @{
    template <> class Transform<3>;
  @};
@};

@end example

 This class is a member of the math namespace.

This class is a specialization of Transform.

@subheading Description

This class describes linear and affine transformations in 3d space. It contains a 3x3 transformation matrix and a 3d translation vector. It can be used for translation and rotation in 3d.

See also Transform3 (@pxref{_657}) typedef.

@subheading Members

 See also the full member list (@pxref{math_Transform_3_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item Transform()
@item Transform(const TransformBase<3> &t)
@item Transform(const Quaternion &q@comma{} const vector3 &v)
@item TransformBase<3> & affine_rotation(unsigned int axis@comma{} double dangle)
@item Transform<3> & affine_rotation(const vector3 &rangles)
@item TransformBase<3> & affine_rotation_rad(unsigned int axis@comma{} double rangle)
@item Transform<3> & affine_rotation_rad(const vector3 &rangles)
@item TransformBase<3> & affine_scaling(const vector<N> &v)
@item TransformBase<3> & affine_scaling(double s)
@item TransformBase<3> & apply_translation(const vector<N> &v)
@item void compose(const TransformBase<N> &t)
@item const Matrix<N> & get_linear() const
@item Matrix<N> & get_linear()
@item const vector<N> & get_translation() const
@item vector<N> & get_translation()
@item TransformBase<3> inverse() const
@item void linear_reset()
@item TransformBase<3> & linear_rotation(unsigned int axis@comma{} double dangle)
@item Transform<3> & linear_rotation(const vector3 &dangles)
@item TransformBase<3> & linear_rotation_rad(unsigned int axis@comma{} double rangle)
@item Transform<3> & linear_rotation_rad(const vector3 &rangles)
@item TransformBase<3> & linear_scaling(const vector<N> &v)
@item TransformBase<3> & linear_scaling(double s)
@item void reset()
@item void set_direction(const vector3 &d)
@item void set_rotation(const Quaternion &q)
@item void set_translation(const vector<N> &v)
@item vector<N> transform(const vector<N> &v) const
@item vectorPair<N> transform_line(const vectorPair<N> &v) const
@item vector<N> transform_linear(const vector<N> &v) const
@item vectorPair<N> transform_pair(const vectorPair<N> &p) const
@item vector<N> transform_translate(const vector<N> &v) const
@item void translation_reset()
@end itemize

@subheading Members detail

@subsubheading Transform()
@anchor{_725}

No documentation available

@subsubheading Transform(const TransformBase<3> &t)
@anchor{_726}

No documentation available

@subsubheading Transform(const Quaternion &q@comma{} const vector3 &v)
@anchor{_727}

Create a transform from rotation quaternion and translation vector

@subsubheading Transform<3> & affine_rotation(const vector3 &rangles)
@anchor{_728}

apply rotation to current transform (degree)

@subsubheading Transform<3> & affine_rotation_rad(const vector3 &rangles)
@anchor{_729}

apply rotation to current transform (radian)

@subsubheading Transform<3> & linear_rotation(const vector3 &dangles)
@anchor{_730}

apply rotation to current transform (degree) (does not transform translation vector)

@subsubheading Transform<3> & linear_rotation_rad(const vector3 &rangles)
@anchor{_731}

apply rotation to current transform (radian) (does not transform translation vector)

@subsubheading void set_direction(const vector3 &d)
@anchor{_732}

set rotation from given direction vector

@subsubheading void set_rotation(const Quaternion &q)
@anchor{_733}

set rotation from given quaternion

@page

@heading math::Transform<3> class full member list
@anchor{math_Transform_3_class_full_member_list}

@subheading Functions

@itemize
@item Transform()
@item Transform(const TransformBase<3> &t)
@item Transform(const Quaternion &q@comma{} const vector3 &v)
@item TransformBase<3> & affine_rotation(unsigned int axis@comma{} double dangle)
@item Transform<3> & affine_rotation(const vector3 &rangles)
@item TransformBase<3> & affine_rotation_rad(unsigned int axis@comma{} double rangle)
@item Transform<3> & affine_rotation_rad(const vector3 &rangles)
@item TransformBase<3> & affine_scaling(const vector<N> &v)
@item TransformBase<3> & affine_scaling(double s)
@item TransformBase<3> & apply_translation(const vector<N> &v)
@item void compose(const TransformBase<N> &t)
@item const Matrix<N> & get_linear() const
@item Matrix<N> & get_linear()
@item const vector<N> & get_translation() const
@item vector<N> & get_translation()
@item TransformBase<3> inverse() const
@item void linear_reset()
@item TransformBase<3> & linear_rotation(unsigned int axis@comma{} double dangle)
@item Transform<3> & linear_rotation(const vector3 &dangles)
@item TransformBase<3> & linear_rotation_rad(unsigned int axis@comma{} double rangle)
@item Transform<3> & linear_rotation_rad(const vector3 &rangles)
@item TransformBase<3> & linear_scaling(const vector<N> &v)
@item TransformBase<3> & linear_scaling(double s)
@item void reset()
@item void set_direction(const vector3 &d)
@item void set_rotation(const Quaternion &q)
@item void set_translation(const vector<N> &v)
@item vector<N> transform(const vector<N> &v) const
@item vectorPair<N> transform_line(const vectorPair<N> &v) const
@item vector<N> transform_linear(const vector<N> &v) const
@item vectorPair<N> transform_pair(const vectorPair<N> &p) const
@item vector<N> transform_translate(const vector<N> &v) const
@item void translation_reset()
@end itemize

@page

@heading math::Transform<2> class reference
@anchor{math_Transform_2_class_reference}

@subheading Declaration

@example
#include <goptical/core/math/Transform>

namespace goptical @{
  namespace math @{
    template <> class Transform<2>;
  @};
@};

@end example

 This class is a member of the math namespace.

This class is a specialization of Transform.

@subheading Description

This class describes linear and affine transformations in 2d space. It contains a 2x2 transformation matrix and a 2d translation vector. It can be used for translation and rotation in 2d.

See also Transform2 (@pxref{_656}) typedef.

@subheading Members

 See also the full member list (@pxref{math_Transform_2_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item Transform()
@item Transform(const TransformBase<2> &t)
@item TransformBase<2> & affine_rotation(unsigned int axis@comma{} double dangle)
@item TransformBase<2> & affine_rotation_rad(unsigned int axis@comma{} double rangle)
@item TransformBase<2> & affine_scaling(const vector<N> &v)
@item TransformBase<2> & affine_scaling(double s)
@item TransformBase<2> & apply_translation(const vector<N> &v)
@item void compose(const TransformBase<N> &t)
@item const Matrix<N> & get_linear() const
@item Matrix<N> & get_linear()
@item const vector<N> & get_translation() const
@item vector<N> & get_translation()
@item TransformBase<2> inverse() const
@item void linear_reset()
@item TransformBase<2> & linear_rotation(unsigned int axis@comma{} double dangle)
@item TransformBase<2> & linear_rotation_rad(unsigned int axis@comma{} double rangle)
@item TransformBase<2> & linear_scaling(const vector<N> &v)
@item TransformBase<2> & linear_scaling(double s)
@item void reset()
@item void set_translation(const vector<N> &v)
@item vector<N> transform(const vector<N> &v) const
@item vectorPair<N> transform_line(const vectorPair<N> &v) const
@item vector<N> transform_linear(const vector<N> &v) const
@item vectorPair<N> transform_pair(const vectorPair<N> &p) const
@item vector<N> transform_translate(const vector<N> &v) const
@item void translation_reset()
@end itemize

@subheading Members detail

@subsubheading Transform()
@anchor{_734}

No documentation available

@subsubheading Transform(const TransformBase<2> &t)
@anchor{_735}

No documentation available

@page

@heading math::Transform<2> class full member list
@anchor{math_Transform_2_class_full_member_list}

@subheading Functions

@itemize
@item Transform()
@item Transform(const TransformBase<2> &t)
@item TransformBase<2> & affine_rotation(unsigned int axis@comma{} double dangle)
@item TransformBase<2> & affine_rotation_rad(unsigned int axis@comma{} double rangle)
@item TransformBase<2> & affine_scaling(const vector<N> &v)
@item TransformBase<2> & affine_scaling(double s)
@item TransformBase<2> & apply_translation(const vector<N> &v)
@item void compose(const TransformBase<N> &t)
@item const Matrix<N> & get_linear() const
@item Matrix<N> & get_linear()
@item const vector<N> & get_translation() const
@item vector<N> & get_translation()
@item TransformBase<2> inverse() const
@item void linear_reset()
@item TransformBase<2> & linear_rotation(unsigned int axis@comma{} double dangle)
@item TransformBase<2> & linear_rotation_rad(unsigned int axis@comma{} double rangle)
@item TransformBase<2> & linear_scaling(const vector<N> &v)
@item TransformBase<2> & linear_scaling(double s)
@item void reset()
@item void set_translation(const vector<N> &v)
@item vector<N> transform(const vector<N> &v) const
@item vectorPair<N> transform_line(const vectorPair<N> &v) const
@item vector<N> transform_linear(const vector<N> &v) const
@item vectorPair<N> transform_pair(const vectorPair<N> &p) const
@item vector<N> transform_translate(const vector<N> &v) const
@item void translation_reset()
@end itemize

@page

@heading math::TransformBase<2> internal class members

@subheading TransformBase()

No documentation available

@subheading TransformBase<2> & affine_rotation(unsigned int axis@comma{} double dangle)
@anchor{_737}

apply rotation to current transform (degree)

@subheading TransformBase<2> & affine_rotation_rad(unsigned int axis@comma{} double rangle)
@anchor{_738}

apply rotation to current transform (radian)

@subheading TransformBase<2> & affine_scaling(const vector<N> &v)
@anchor{_739}

apply scaling to current transform

@subheading TransformBase<2> & affine_scaling(double s)
@anchor{_740}

apply scaling to current transform

@subheading TransformBase<2> & apply_translation(const vector<N> &v)
@anchor{_741}

apply translation to current transform

@subheading void compose(const TransformBase<N> &t)
@anchor{_742}

compose with t. new transform is equivalent to applying t then this transform

@subheading const Matrix<N> & get_linear() const
@anchor{_743}

get linear transform matrix

@subheading Matrix<N> & get_linear()
@anchor{_744}

get linear transform matrix

@subheading const vector<N> & get_translation() const
@anchor{_745}

get translation vector

@subheading vector<N> & get_translation()
@anchor{_746}

get translation vector

@subheading TransformBase<2> inverse() const
@anchor{_747}

get inverse transformation

@subheading void linear_reset()
@anchor{_748}

reset linear transform to identity

@subheading TransformBase<2> & linear_rotation(unsigned int axis@comma{} double dangle)
@anchor{_749}

apply rotation to current transform (degree) (does not transform translation vector)

@subheading TransformBase<2> & linear_rotation_rad(unsigned int axis@comma{} double rangle)
@anchor{_750}

apply rotation to current transform (radian) (does not transform translation vector)

@subheading TransformBase<2> & linear_scaling(const vector<N> &v)
@anchor{_751}

apply linear scaling to current transform (does not transform translation vector)

@subheading TransformBase<2> & linear_scaling(double s)
@anchor{_752}

apply scaling to current transform (does not transform translation vector)

@subheading void reset()
@anchor{_753}

reset linear transform to identity and translation to zero

@subheading void set_translation(const vector<N> &v)
@anchor{_754}

set current translation

@subheading vector<N> transform(const vector<N> &v) const
@anchor{_755}

apply affine transform (translation and linear) to vector

@subheading vectorPair<N> transform_line(const vectorPair<N> &v) const
@anchor{_756}

apply affine transform to line origin and linear to direction

@subheading vector<N> transform_linear(const vector<N> &v) const
@anchor{_757}

apply linear transform to vector

@subheading vectorPair<N> transform_pair(const vectorPair<N> &p) const
@anchor{_758}

apply affine transform to both vectors in pair

@subheading vector<N> transform_translate(const vector<N> &v) const
@anchor{_759}

apply translation to vector

@subheading void translation_reset()
@anchor{_760}

reset translation to zero

@subheading virtual ~TransformBase()

No documentation available

@page

@heading math::TransformBase<3> internal class members

@subheading TransformBase()

No documentation available

@subheading TransformBase<3> & affine_rotation(unsigned int axis@comma{} double dangle)
@anchor{_763}

apply rotation to current transform (degree)

@subheading TransformBase<3> & affine_rotation_rad(unsigned int axis@comma{} double rangle)
@anchor{_764}

apply rotation to current transform (radian)

@subheading TransformBase<3> & affine_scaling(const vector<N> &v)
@anchor{_765}

apply scaling to current transform

@subheading TransformBase<3> & affine_scaling(double s)
@anchor{_766}

apply scaling to current transform

@subheading TransformBase<3> & apply_translation(const vector<N> &v)
@anchor{_767}

apply translation to current transform

@subheading void compose(const TransformBase<N> &t)
@anchor{_768}

compose with t. new transform is equivalent to applying t then this transform

@subheading const Matrix<N> & get_linear() const
@anchor{_769}

get linear transform matrix

@subheading Matrix<N> & get_linear()
@anchor{_770}

get linear transform matrix

@subheading const vector<N> & get_translation() const
@anchor{_771}

get translation vector

@subheading vector<N> & get_translation()
@anchor{_772}

get translation vector

@subheading TransformBase<3> inverse() const
@anchor{_773}

get inverse transformation

@subheading void linear_reset()
@anchor{_774}

reset linear transform to identity

@subheading TransformBase<3> & linear_rotation(unsigned int axis@comma{} double dangle)
@anchor{_775}

apply rotation to current transform (degree) (does not transform translation vector)

@subheading TransformBase<3> & linear_rotation_rad(unsigned int axis@comma{} double rangle)
@anchor{_776}

apply rotation to current transform (radian) (does not transform translation vector)

@subheading TransformBase<3> & linear_scaling(const vector<N> &v)
@anchor{_777}

apply linear scaling to current transform (does not transform translation vector)

@subheading TransformBase<3> & linear_scaling(double s)
@anchor{_778}

apply scaling to current transform (does not transform translation vector)

@subheading void reset()
@anchor{_779}

reset linear transform to identity and translation to zero

@subheading void set_translation(const vector<N> &v)
@anchor{_780}

set current translation

@subheading vector<N> transform(const vector<N> &v) const
@anchor{_781}

apply affine transform (translation and linear) to vector

@subheading vectorPair<N> transform_line(const vectorPair<N> &v) const
@anchor{_782}

apply affine transform to line origin and linear to direction

@subheading vector<N> transform_linear(const vector<N> &v) const
@anchor{_783}

apply linear transform to vector

@subheading vectorPair<N> transform_pair(const vectorPair<N> &p) const
@anchor{_784}

apply affine transform to both vectors in pair

@subheading vector<N> transform_translate(const vector<N> &v) const
@anchor{_785}

apply translation to vector

@subheading void translation_reset()
@anchor{_786}

reset translation to zero

@subheading virtual ~TransformBase()

No documentation available

@page

@heading math::Triangle struct reference
@anchor{math_Triangle_struct_reference}

@subheading Declaration

@example
#include <goptical/core/math/Triangle>

namespace goptical @{
  namespace math @{
    template <int N> struct Triangle;
  @};
@};

@end example

 This struct is a member of the math namespace.

@subheading Description

This class is the general purpose N dimensions triangles class.

@subheading Class specializations

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item Triangle<3> @tab 3d triangle class
@end multitable

@subheading Members

 See also the full member list (@pxref{math_Triangle_struct_full_member_list}) section for this struct.

@subsubheading Type

@itemize
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subsubheading Functions

@itemize
@item Triangle()
@item Triangle(const vector<N> &a@comma{} const vector<N> &b@comma{} const vector<N> &c)
@item vector<N> get_centroid() const
@item const vector<N> & operator[](int n) const
@item vector<N> & operator[](int n)
@end itemize

@subheading Members detail

@subsubheading Triangle()
@anchor{_788}

No documentation available

@subsubheading Triangle(const vector<N> &a@comma{} const vector<N> &b@comma{} const vector<N> &c)
@anchor{_789}

Create a triangle from 3 points

@subsubheading typedef  @uref{http://diaxen.ssji.net/dpp/delegate_class_reference.html,,delegate} <void(const math::Triangle<N>&)> put_delegate_t
@anchor{_790}

No documentation available

@page

@heading math::Triangle struct full member list
@anchor{math_Triangle_struct_full_member_list}

@subheading Type

@itemize
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item Triangle()
@item Triangle(const vector<N> &a@comma{} const vector<N> &b@comma{} const vector<N> &c)
@item vector<N> get_centroid() const
@item const vector<N> & operator[](int n) const
@item vector<N> & operator[](int n)
@end itemize

@page

@heading math::Triangle<3> struct reference
@anchor{math_Triangle_3_struct_reference}

@subheading Declaration

@example
#include <goptical/core/math/Triangle>

namespace goptical @{
  namespace math @{
    template <> struct Triangle<3>;
  @};
@};

@end example

 This struct is a member of the math namespace.

This struct is a specialization of Triangle (@pxref{math_Triangle_struct_reference}).

@subheading Description

This class is the 3d triangles class.

@subheading Members

 See also the full member list (@pxref{math_Triangle_3_struct_full_member_list}) section for this struct.

@subsubheading Type

@itemize
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subsubheading Functions

@itemize
@item Triangle()
@item Triangle(const vector3 &a@comma{} const vector3 &b@comma{} const vector3 &c)
@item vector<N> get_centroid() const
@item vector3 normal() const
@item const vector<N> & operator[](int n) const
@item vector<N> & operator[](int n)
@end itemize

@subheading Members detail

@subsubheading Triangle()
@anchor{_791}

No documentation available

@subsubheading Triangle(const vector3 &a@comma{} const vector3 &b@comma{} const vector3 &c)
@anchor{_792}

Create a triangle from 3 points

@subsubheading vector3 normal() const
@anchor{_793}

Get triangle normal

@subsubheading typedef  @uref{http://diaxen.ssji.net/dpp/delegate_class_reference.html,,delegate} <void(const math::Triangle<3>&)> put_delegate_t
@anchor{_794}

No documentation available

@page

@heading math::Triangle<3> struct full member list
@anchor{math_Triangle_3_struct_full_member_list}

@subheading Type

@itemize
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item Triangle()
@item Triangle(const vector3 &a@comma{} const vector3 &b@comma{} const vector3 &c)
@item vector<N> get_centroid() const
@item vector3 normal() const
@item const vector<N> & operator[](int n) const
@item vector<N> & operator[](int n)
@end itemize

@page

@heading math::Triangle<2> internal struct members

@subheading Triangle()

No documentation available

@subheading Triangle(const vector<N> &a@comma{} const vector<N> &b@comma{} const vector<N> &c)

Create a triangle from 3 points

@subheading typedef  @uref{http://diaxen.ssji.net/dpp/delegate_class_reference.html,,delegate} <void(const math::Triangle<N>&)> put_delegate_t
@anchor{_797}

No documentation available

@page

@heading math::TriangleBase<N> internal struct members

@subheading TriangleBase()

No documentation available

@subheading TriangleBase(const vector<N> &a@comma{} const vector<N> &b@comma{} const vector<N> &c)

Create a triangle from 3 points

@subheading vector<N> get_centroid() const
@anchor{_800}

Get triangle centroid

@subheading const vector<N> & operator[](int n) const
@anchor{_801}

Get point n of the triangle

@subheading vector<N> & operator[](int n)
@anchor{_802}

Get reference to point n of the triangle

@page

@heading math::TriangleBase<3> internal struct members

@subheading TriangleBase()

No documentation available

@subheading TriangleBase(const vector<N> &a@comma{} const vector<N> &b@comma{} const vector<N> &c)

Create a triangle from 3 points

@subheading vector<N> get_centroid() const
@anchor{_805}

Get triangle centroid

@subheading const vector<N> & operator[](int n) const
@anchor{_806}

Get point n of the triangle

@subheading vector<N> & operator[](int n)
@anchor{_807}

Get reference to point n of the triangle

@page

@heading math::vector struct reference
@anchor{math_vector_struct_reference}

@subheading Declaration

@example
#include <goptical/core/math/vector>

namespace goptical @{
  namespace math @{
    template <int N@comma{} typename T = double> struct vector;
  @};
@};

@end example

 This struct is a member of the math namespace.

@subheading Description

This class is the general purpose N dimensions vector class.

@subheading Class specializations

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item vector<3@comma{} T> @tab 3d vector class
@item vector<2@comma{} T> @tab 2d vector class
@end multitable

@subheading Members

 See also the full member list (@pxref{math_vector_struct_full_member_list}) section for this struct.

@subsubheading Functions

@itemize
@item vector()
@item vector(const vectorBase<N@comma{} T> &v)
@item vector(T v)
@item bool close_to(const vectorBase<N@comma{} T> &m@comma{} T error = @emph{[...]})
@item T len() const
@item vectorBase<N@comma{} T> magnitude(T newlen) const
@item vectorBase<N@comma{} T> mul(const vectorBase<N@comma{} T> &v) const
@item vectorBase<N@comma{} T> & neg()
@item const vectorBase<N@comma{} T> & normalize()
@item vectorBase<N@comma{} T> normalized() const
@item T operator*(const vectorBase<N@comma{} T> &v) const
@item vectorBase<N@comma{} T> operator*(T scale) const
@item vectorBase<N@comma{} T> operator*(const Matrix<N> &m)
@item const vectorBase<N@comma{} T> & operator*=(T scale)
@item vectorBase<N@comma{} T> operator+(const vectorBase<N@comma{} T> &v) const
@item const vectorBase<N@comma{} T> & operator+=(const vectorBase<N@comma{} T> &v)
@item vectorBase<N@comma{} T> operator-(const vectorBase<N@comma{} T> &v) const
@item vectorBase<N@comma{} T> operator-() const
@item const vectorBase<N@comma{} T> & operator-=(const vectorBase<N@comma{} T> &v)
@item vectorBase<N@comma{} T> operator/(T scale) const
@item vectorBase<N@comma{} T> operator/(const vectorBase<N@comma{} T> &v) const
@item const vectorBase<N@comma{} T> & operator/=(T scale)
@item bool operator==(const vectorBase<N@comma{} T> &m) const
@item T operator[](int n) const
@item T & operator[](int n)
@item template vectorBase<M@comma{} T> select(unsigned int bitmask@comma{} const vectorBase<M@comma{} T> &v) const
@item void set(T value)
@end itemize

@subheading Members detail

@subsubheading vector()
@anchor{_808}

No documentation available

@subsubheading vector(const vectorBase<N@comma{} T> &v)
@anchor{_809}

No documentation available

@subsubheading vector(T v)
@anchor{_810}

Create a 2d vector with same value for all components

@page

@heading math::vector struct full member list
@anchor{math_vector_struct_full_member_list}

@subheading Functions

@itemize
@item vector()
@item vector(const vectorBase<N@comma{} T> &v)
@item vector(T v)
@item bool close_to(const vectorBase<N@comma{} T> &m@comma{} T error = @emph{[...]})
@item T len() const
@item vectorBase<N@comma{} T> magnitude(T newlen) const
@item vectorBase<N@comma{} T> mul(const vectorBase<N@comma{} T> &v) const
@item vectorBase<N@comma{} T> & neg()
@item const vectorBase<N@comma{} T> & normalize()
@item vectorBase<N@comma{} T> normalized() const
@item T operator*(const vectorBase<N@comma{} T> &v) const
@item vectorBase<N@comma{} T> operator*(T scale) const
@item vectorBase<N@comma{} T> operator*(const Matrix<N> &m)
@item const vectorBase<N@comma{} T> & operator*=(T scale)
@item vectorBase<N@comma{} T> operator+(const vectorBase<N@comma{} T> &v) const
@item const vectorBase<N@comma{} T> & operator+=(const vectorBase<N@comma{} T> &v)
@item vectorBase<N@comma{} T> operator-(const vectorBase<N@comma{} T> &v) const
@item vectorBase<N@comma{} T> operator-() const
@item const vectorBase<N@comma{} T> & operator-=(const vectorBase<N@comma{} T> &v)
@item vectorBase<N@comma{} T> operator/(T scale) const
@item vectorBase<N@comma{} T> operator/(const vectorBase<N@comma{} T> &v) const
@item const vectorBase<N@comma{} T> & operator/=(T scale)
@item bool operator==(const vectorBase<N@comma{} T> &m) const
@item T operator[](int n) const
@item T & operator[](int n)
@item template vectorBase<M@comma{} T> select(unsigned int bitmask@comma{} const vectorBase<M@comma{} T> &v) const
@item void set(T value)
@end itemize

@page

@heading math::vector<3@comma{}T> struct reference
@anchor{math_vector_3_T_struct_reference}

@subheading Declaration

@example
#include <goptical/core/math/vector>

namespace goptical @{
  namespace math @{
    template <typename T> struct vector<3@comma{} T>;
  @};
@};

@end example

 This struct is a member of the math namespace.

This template struct is a specialization of vector (@pxref{math_vector_struct_reference}).

@subheading Description

This class implements 3d vectors.

The math (@pxref{math_namespace_reference}) namespace contains some commonly used constant vector objects.

@subheading Members

 See also the full member list (@pxref{math_vector_3_T_struct_full_member_list}) section for this struct.

@subsubheading Types

@itemize
@item typedef @emph{ [...] } base
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subsubheading Functions

@itemize
@item vector()
@item vector(const vectorBase<3@comma{} T> &v)
@item template vector(const vectorBase<M@comma{} T> &v@comma{} T p)
@item vector(T v)
@item vector(T x@comma{} T y@comma{} T z)
@item bool close_to(const vectorBase<3@comma{} T> &m@comma{} T error = @emph{[...]})
@item vector cross_product(const vector<3@comma{} T> &v) const
@item T len() const
@item vectorBase<3@comma{} T> magnitude(T newlen) const
@item vectorBase<3@comma{} T> mul(const vectorBase<3@comma{} T> &v) const
@item vectorBase<3@comma{} T> & neg()
@item const vectorBase<3@comma{} T> & normalize()
@item vectorBase<3@comma{} T> normalized() const
@item T operator*(const vectorBase<3@comma{} T> &v) const
@item vectorBase<3@comma{} T> operator*(T scale) const
@item vectorBase<3@comma{} T> operator*(const Matrix<N> &m)
@item const vectorBase<3@comma{} T> & operator*=(T scale)
@item vectorBase<3@comma{} T> operator+(const vectorBase<3@comma{} T> &v) const
@item const vectorBase<3@comma{} T> & operator+=(const vectorBase<3@comma{} T> &v)
@item vectorBase<3@comma{} T> operator-(const vectorBase<3@comma{} T> &v) const
@item vectorBase<3@comma{} T> operator-() const
@item const vectorBase<3@comma{} T> & operator-=(const vectorBase<3@comma{} T> &v)
@item vectorBase<3@comma{} T> operator/(T scale) const
@item vectorBase<3@comma{} T> operator/(const vectorBase<3@comma{} T> &v) const
@item const vectorBase<3@comma{} T> & operator/=(T scale)
@item bool operator==(const vectorBase<3@comma{} T> &m) const
@item T operator[](int n) const
@item T & operator[](int n)
@item vector<2@comma{} T> project_xy() const
@item vector<2@comma{} T> project_zy() const
@item template vectorBase<M@comma{} T> select(unsigned int bitmask@comma{} const vectorBase<M@comma{} T> &v) const
@item void set(T value)
@item T & x()
@item T x() const
@item T & y()
@item T y() const
@item T & z()
@item T z() const
@end itemize

@subheading Members detail

@subsubheading vector()
@anchor{_811}

No documentation available

@subsubheading vector(const vectorBase<3@comma{} T> &v)
@anchor{_812}

Copy constructor

@subsubheading template <int M> vector(const vectorBase<M@comma{} T> &v@comma{} T p)
@anchor{_813}

Create a 3d vector from 2d vector and given z value.

@subsubheading vector(T v)
@anchor{_814}

Create a 2d vector with same value for all components

@subsubheading vector(T x@comma{} T y@comma{} T z)
@anchor{_815}

Create a 3d vector from x@comma{} y and z values

@subsubheading typedef vectorBase<3@comma{} T> base
@anchor{_816}

No documentation available

@subsubheading vector cross_product(const vector<3@comma{} T> &v) const
@anchor{_817}

Compute vectors cross product

@subsubheading vector<2@comma{} T> project_xy() const
@anchor{_818}

Get a 2d vector formed x and y values.

@subsubheading vector<2@comma{} T> project_zy() const
@anchor{_819}

Get a 2d vector formed z and y values.

@subsubheading typedef  @uref{http://diaxen.ssji.net/dpp/delegate_class_reference.html,,delegate} <void(const vector<3@comma{}T>&)> put_delegate_t
@anchor{_820}

No documentation available

@subsubheading T & x()
@anchor{_821}

Get reference to vector x value

@subsubheading T x() const
@anchor{_822}

Get vector x value

@subsubheading T & y()
@anchor{_823}

Get reference to vector y value

@subsubheading T y() const
@anchor{_824}

Get vector y value

@subsubheading T & z()
@anchor{_825}

Get reference to vector z value

@subsubheading T z() const
@anchor{_826}

Get vector z value

@page

@heading math::vector<3@comma{}T> struct full member list
@anchor{math_vector_3_T_struct_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } base
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item vector()
@item vector(const vectorBase<3@comma{} T> &v)
@item template vector(const vectorBase<M@comma{} T> &v@comma{} T p)
@item vector(T v)
@item vector(T x@comma{} T y@comma{} T z)
@item bool close_to(const vectorBase<3@comma{} T> &m@comma{} T error = @emph{[...]})
@item vector cross_product(const vector<3@comma{} T> &v) const
@item T len() const
@item vectorBase<3@comma{} T> magnitude(T newlen) const
@item vectorBase<3@comma{} T> mul(const vectorBase<3@comma{} T> &v) const
@item vectorBase<3@comma{} T> & neg()
@item const vectorBase<3@comma{} T> & normalize()
@item vectorBase<3@comma{} T> normalized() const
@item T operator*(const vectorBase<3@comma{} T> &v) const
@item vectorBase<3@comma{} T> operator*(T scale) const
@item vectorBase<3@comma{} T> operator*(const Matrix<N> &m)
@item const vectorBase<3@comma{} T> & operator*=(T scale)
@item vectorBase<3@comma{} T> operator+(const vectorBase<3@comma{} T> &v) const
@item const vectorBase<3@comma{} T> & operator+=(const vectorBase<3@comma{} T> &v)
@item vectorBase<3@comma{} T> operator-(const vectorBase<3@comma{} T> &v) const
@item vectorBase<3@comma{} T> operator-() const
@item const vectorBase<3@comma{} T> & operator-=(const vectorBase<3@comma{} T> &v)
@item vectorBase<3@comma{} T> operator/(T scale) const
@item vectorBase<3@comma{} T> operator/(const vectorBase<3@comma{} T> &v) const
@item const vectorBase<3@comma{} T> & operator/=(T scale)
@item bool operator==(const vectorBase<3@comma{} T> &m) const
@item T operator[](int n) const
@item T & operator[](int n)
@item vector<2@comma{} T> project_xy() const
@item vector<2@comma{} T> project_zy() const
@item template vectorBase<M@comma{} T> select(unsigned int bitmask@comma{} const vectorBase<M@comma{} T> &v) const
@item void set(T value)
@item T & x()
@item T x() const
@item T & y()
@item T y() const
@item T & z()
@item T z() const
@end itemize

@page

@heading math::vector<2@comma{}T> struct reference
@anchor{math_vector_2_T_struct_reference}

@subheading Declaration

@example
#include <goptical/core/math/vector>

namespace goptical @{
  namespace math @{
    template <typename T> struct vector<2@comma{} T>;
  @};
@};

@end example

 This struct is a member of the math namespace.

This template struct is a specialization of vector (@pxref{math_vector_struct_reference}).

@subheading Description

This class implements 2d vectors.

The math (@pxref{math_namespace_reference}) namespace contains some commonly used constant vector objects.

@subheading Members

 See also the full member list (@pxref{math_vector_2_T_struct_full_member_list}) section for this struct.

@subsubheading Types

@itemize
@item typedef @emph{ [...] } base
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subsubheading Functions

@itemize
@item vector()
@item vector(const vectorBase<2@comma{} T> &v)
@item template vector(const vectorBase<M@comma{} T> &v@comma{} T p)
@item vector(T v)
@item vector(T x@comma{} T y)
@item template vector(const vectorBase<N@comma{} T> &v@comma{} unsigned int c0@comma{} unsigned int c1)
@item bool close_to(const vectorBase<2@comma{} T> &m@comma{} T error = @emph{[...]})
@item T cross_product(const vector<2@comma{} T> &v) const
@item T len() const
@item vectorBase<2@comma{} T> magnitude(T newlen) const
@item vectorBase<2@comma{} T> mul(const vectorBase<2@comma{} T> &v) const
@item vectorBase<2@comma{} T> & neg()
@item const vectorBase<2@comma{} T> & normalize()
@item vectorBase<2@comma{} T> normalized() const
@item T operator*(const vectorBase<2@comma{} T> &v) const
@item vectorBase<2@comma{} T> operator*(T scale) const
@item vectorBase<2@comma{} T> operator*(const Matrix<N> &m)
@item const vectorBase<2@comma{} T> & operator*=(T scale)
@item vectorBase<2@comma{} T> operator+(const vectorBase<2@comma{} T> &v) const
@item const vectorBase<2@comma{} T> & operator+=(const vectorBase<2@comma{} T> &v)
@item vectorBase<2@comma{} T> operator-(const vectorBase<2@comma{} T> &v) const
@item vectorBase<2@comma{} T> operator-() const
@item const vectorBase<2@comma{} T> & operator-=(const vectorBase<2@comma{} T> &v)
@item vectorBase<2@comma{} T> operator/(T scale) const
@item vectorBase<2@comma{} T> operator/(const vectorBase<2@comma{} T> &v) const
@item const vectorBase<2@comma{} T> & operator/=(T scale)
@item bool operator==(const vectorBase<2@comma{} T> &m) const
@item T operator[](int n) const
@item T & operator[](int n)
@item template vectorBase<M@comma{} T> select(unsigned int bitmask@comma{} const vectorBase<M@comma{} T> &v) const
@item void set(T value)
@item T & x()
@item T x() const
@item T & y()
@item T y() const
@end itemize

@subheading Members detail

@subsubheading vector()
@anchor{_827}

No documentation available

@subsubheading vector(const vectorBase<2@comma{} T> &v)
@anchor{_828}

No documentation available

@subsubheading template <int M> vector(const vectorBase<M@comma{} T> &v@comma{} T p)
@anchor{_829}

No documentation available

@subsubheading vector(T v)
@anchor{_830}

Create a 2d vector with same value for all components

@subsubheading vector(T x@comma{} T y)
@anchor{_831}

Create a 2d vector from x and y z values

@subsubheading template <int N> vector(const vectorBase<N@comma{} T> &v@comma{} unsigned int c0@comma{} unsigned int c1)
@anchor{_832}

Create a 2d vector and initialize from specified components of an other vector

@subsubheading typedef vectorBase<2@comma{} T> base
@anchor{_833}

No documentation available

@subsubheading T cross_product(const vector<2@comma{} T> &v) const
@anchor{_834}

No documentation available

@subsubheading typedef  @uref{http://diaxen.ssji.net/dpp/delegate_class_reference.html,,delegate} <void(const math::vector2&)> put_delegate_t
@anchor{_835}

No documentation available

@subsubheading T & x()
@anchor{_836}

Get reference to vector x value

@subsubheading T x() const
@anchor{_837}

Get vector x value

@subsubheading T & y()
@anchor{_838}

Get reference to vector y value

@subsubheading T y() const
@anchor{_839}

Get vector y value

@page

@heading math::vector<2@comma{}T> struct full member list
@anchor{math_vector_2_T_struct_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } base
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item vector()
@item vector(const vectorBase<2@comma{} T> &v)
@item template vector(const vectorBase<M@comma{} T> &v@comma{} T p)
@item vector(T v)
@item vector(T x@comma{} T y)
@item template vector(const vectorBase<N@comma{} T> &v@comma{} unsigned int c0@comma{} unsigned int c1)
@item bool close_to(const vectorBase<2@comma{} T> &m@comma{} T error = @emph{[...]})
@item T cross_product(const vector<2@comma{} T> &v) const
@item T len() const
@item vectorBase<2@comma{} T> magnitude(T newlen) const
@item vectorBase<2@comma{} T> mul(const vectorBase<2@comma{} T> &v) const
@item vectorBase<2@comma{} T> & neg()
@item const vectorBase<2@comma{} T> & normalize()
@item vectorBase<2@comma{} T> normalized() const
@item T operator*(const vectorBase<2@comma{} T> &v) const
@item vectorBase<2@comma{} T> operator*(T scale) const
@item vectorBase<2@comma{} T> operator*(const Matrix<N> &m)
@item const vectorBase<2@comma{} T> & operator*=(T scale)
@item vectorBase<2@comma{} T> operator+(const vectorBase<2@comma{} T> &v) const
@item const vectorBase<2@comma{} T> & operator+=(const vectorBase<2@comma{} T> &v)
@item vectorBase<2@comma{} T> operator-(const vectorBase<2@comma{} T> &v) const
@item vectorBase<2@comma{} T> operator-() const
@item const vectorBase<2@comma{} T> & operator-=(const vectorBase<2@comma{} T> &v)
@item vectorBase<2@comma{} T> operator/(T scale) const
@item vectorBase<2@comma{} T> operator/(const vectorBase<2@comma{} T> &v) const
@item const vectorBase<2@comma{} T> & operator/=(T scale)
@item bool operator==(const vectorBase<2@comma{} T> &m) const
@item T operator[](int n) const
@item T & operator[](int n)
@item template vectorBase<M@comma{} T> select(unsigned int bitmask@comma{} const vectorBase<M@comma{} T> &v) const
@item void set(T value)
@item T & x()
@item T x() const
@item T & y()
@item T y() const
@end itemize

@page

@heading math::vectorBase<N@comma{}math::vector::T> internal struct members

@subheading bool close_to(const vectorBase<N@comma{} T> &m@comma{} T error = 1 e-8)
@anchor{_840}

compare two almost equal vectors

@subheading T len() const
@anchor{_841}

Compute vector length

@subheading vectorBase<N@comma{} T> magnitude(T newlen) const
@anchor{_842}

Adjust vector length

@subheading vectorBase<N@comma{} T> mul(const vectorBase<N@comma{} T> &v) const
@anchor{_843}

vector values multiply

@subheading vectorBase<N@comma{} T> & neg()
@anchor{_844}

Negate vector

@subheading const vectorBase<N@comma{} T> & normalize()
@anchor{_845}

Normalize vector length 

See also normalized (@pxref{_1036}) function.

@subheading vectorBase<N@comma{} T> normalized() const
@anchor{_846}

Get normalized vector 

See also normalize (@pxref{_1035}) function.

@subheading T operator*(const vectorBase<N@comma{} T> &v) const
@anchor{_847}

vector dot product

@subheading vectorBase<N@comma{} T> operator*(T scale) const
@anchor{_848}

Scale vector

@subheading vectorBase<N@comma{} T> operator*(const Matrix<N> &m)
@anchor{_849}

Multiply vector with matrix. See vector class for matrix/vector multiplication.

@subheading const vectorBase<N@comma{} T> & operator*=(T scale)
@anchor{_850}

Multiply by a vector

@subheading vectorBase<N@comma{} T> operator+(const vectorBase<N@comma{} T> &v) const
@anchor{_851}

Add two vectors

@subheading const vectorBase<N@comma{} T> & operator+=(const vectorBase<N@comma{} T> &v)
@anchor{_852}

Add a vector

@subheading vectorBase<N@comma{} T> operator-(const vectorBase<N@comma{} T> &v) const
@anchor{_853}

Subtract two vectors

@subheading vectorBase<N@comma{} T> operator-() const
@anchor{_854}

Get negated vector

@subheading const vectorBase<N@comma{} T> & operator-=(const vectorBase<N@comma{} T> &v)
@anchor{_855}

Sutract a vector

@subheading vectorBase<N@comma{} T> operator/(T scale) const
@anchor{_856}

Scale vector

@subheading vectorBase<N@comma{} T> operator/(const vectorBase<N@comma{} T> &v) const
@anchor{_857}

vector division

@subheading const vectorBase<N@comma{} T> & operator/=(T scale)
@anchor{_858}

Divide by a vector

@subheading bool operator==(const vectorBase<N@comma{} T> &m) const
@anchor{_859}

compare two vectors for equality

@subheading T operator[](int n) const
@anchor{_860}

Get value at specified index

@subheading T & operator[](int n)
@anchor{_861}

Get reference to value at specified index

@subheading template <int M> vectorBase<M@comma{} T> select(unsigned int bitmask@comma{} const vectorBase<M@comma{} T> &v) const
@anchor{_862}

Select components from two vectors. Components which have their corresponding bit set in the mask are extracted from this vector and other components are taken from passed vector.

@subheading void set(T value)
@anchor{_863}

Set the whole vector to the specified value

@page

@heading math::vectorBase<2@comma{}math::vector<2@comma{}T>::T> internal struct members

@subheading bool close_to(const vectorBase<2@comma{} T> &m@comma{} T error = 1 e-8)
@anchor{_864}

compare two almost equal vectors

@subheading T len() const
@anchor{_865}

Compute vector length

@subheading vectorBase<2@comma{} T> magnitude(T newlen) const
@anchor{_866}

Adjust vector length

@subheading vectorBase<2@comma{} T> mul(const vectorBase<2@comma{} T> &v) const
@anchor{_867}

vector values multiply

@subheading vectorBase<2@comma{} T> & neg()
@anchor{_868}

Negate vector

@subheading const vectorBase<2@comma{} T> & normalize()
@anchor{_869}

Normalize vector length 

See also normalized (@pxref{_1036}) function.

@subheading vectorBase<2@comma{} T> normalized() const
@anchor{_870}

Get normalized vector 

See also normalize (@pxref{_1035}) function.

@subheading T operator*(const vectorBase<2@comma{} T> &v) const
@anchor{_871}

vector dot product

@subheading vectorBase<2@comma{} T> operator*(T scale) const
@anchor{_872}

Scale vector

@subheading vectorBase<2@comma{} T> operator*(const Matrix<N> &m)
@anchor{_873}

Multiply vector with matrix. See vector class for matrix/vector multiplication.

@subheading const vectorBase<2@comma{} T> & operator*=(T scale)
@anchor{_874}

Multiply by a vector

@subheading vectorBase<2@comma{} T> operator+(const vectorBase<2@comma{} T> &v) const
@anchor{_875}

Add two vectors

@subheading const vectorBase<2@comma{} T> & operator+=(const vectorBase<2@comma{} T> &v)
@anchor{_876}

Add a vector

@subheading vectorBase<2@comma{} T> operator-(const vectorBase<2@comma{} T> &v) const
@anchor{_877}

Subtract two vectors

@subheading vectorBase<2@comma{} T> operator-() const
@anchor{_878}

Get negated vector

@subheading const vectorBase<2@comma{} T> & operator-=(const vectorBase<2@comma{} T> &v)
@anchor{_879}

Sutract a vector

@subheading vectorBase<2@comma{} T> operator/(T scale) const
@anchor{_880}

Scale vector

@subheading vectorBase<2@comma{} T> operator/(const vectorBase<2@comma{} T> &v) const
@anchor{_881}

vector division

@subheading const vectorBase<2@comma{} T> & operator/=(T scale)
@anchor{_882}

Divide by a vector

@subheading bool operator==(const vectorBase<2@comma{} T> &m) const
@anchor{_883}

compare two vectors for equality

@subheading T operator[](int n) const
@anchor{_884}

Get value at specified index

@subheading T & operator[](int n)
@anchor{_885}

Get reference to value at specified index

@subheading template <int M> vectorBase<M@comma{} T> select(unsigned int bitmask@comma{} const vectorBase<M@comma{} T> &v) const
@anchor{_886}

Select components from two vectors. Components which have their corresponding bit set in the mask are extracted from this vector and other components are taken from passed vector.

@subheading void set(T value)
@anchor{_887}

Set the whole vector to the specified value

@page

@heading math::vectorBase<3@comma{}math::vector<3@comma{}T>::T> internal struct members

@subheading bool close_to(const vectorBase<3@comma{} T> &m@comma{} T error = 1 e-8)
@anchor{_888}

compare two almost equal vectors

@subheading T len() const
@anchor{_889}

Compute vector length

@subheading vectorBase<3@comma{} T> magnitude(T newlen) const
@anchor{_890}

Adjust vector length

@subheading vectorBase<3@comma{} T> mul(const vectorBase<3@comma{} T> &v) const
@anchor{_891}

vector values multiply

@subheading vectorBase<3@comma{} T> & neg()
@anchor{_892}

Negate vector

@subheading const vectorBase<3@comma{} T> & normalize()
@anchor{_893}

Normalize vector length 

See also normalized (@pxref{_1036}) function.

@subheading vectorBase<3@comma{} T> normalized() const
@anchor{_894}

Get normalized vector 

See also normalize (@pxref{_1035}) function.

@subheading T operator*(const vectorBase<3@comma{} T> &v) const
@anchor{_895}

vector dot product

@subheading vectorBase<3@comma{} T> operator*(T scale) const
@anchor{_896}

Scale vector

@subheading vectorBase<3@comma{} T> operator*(const Matrix<N> &m)
@anchor{_897}

Multiply vector with matrix. See vector class for matrix/vector multiplication.

@subheading const vectorBase<3@comma{} T> & operator*=(T scale)
@anchor{_898}

Multiply by a vector

@subheading vectorBase<3@comma{} T> operator+(const vectorBase<3@comma{} T> &v) const
@anchor{_899}

Add two vectors

@subheading const vectorBase<3@comma{} T> & operator+=(const vectorBase<3@comma{} T> &v)
@anchor{_900}

Add a vector

@subheading vectorBase<3@comma{} T> operator-(const vectorBase<3@comma{} T> &v) const
@anchor{_901}

Subtract two vectors

@subheading vectorBase<3@comma{} T> operator-() const
@anchor{_902}

Get negated vector

@subheading const vectorBase<3@comma{} T> & operator-=(const vectorBase<3@comma{} T> &v)
@anchor{_903}

Sutract a vector

@subheading vectorBase<3@comma{} T> operator/(T scale) const
@anchor{_904}

Scale vector

@subheading vectorBase<3@comma{} T> operator/(const vectorBase<3@comma{} T> &v) const
@anchor{_905}

vector division

@subheading const vectorBase<3@comma{} T> & operator/=(T scale)
@anchor{_906}

Divide by a vector

@subheading bool operator==(const vectorBase<3@comma{} T> &m) const
@anchor{_907}

compare two vectors for equality

@subheading T operator[](int n) const
@anchor{_908}

Get value at specified index

@subheading T & operator[](int n)
@anchor{_909}

Get reference to value at specified index

@subheading template <int M> vectorBase<M@comma{} T> select(unsigned int bitmask@comma{} const vectorBase<M@comma{} T> &v) const
@anchor{_910}

Select components from two vectors. Components which have their corresponding bit set in the mask are extracted from this vector and other components are taken from passed vector.

@subheading void set(T value)
@anchor{_911}

Set the whole vector to the specified value

@page

@heading math::vectorPair struct reference
@anchor{math_vectorPair_struct_reference}

@subheading Declaration

@example
#include <goptical/core/math/vectorPair>

namespace goptical @{
  namespace math @{
    template <int N> struct vectorPair;
  @};
@};

@end example

 This struct is a member of the math namespace.

@subheading Description

This class hold two N dimensions vectors.

@subheading Class specializations

@multitable @columnfractions 0.3 0.7
@headitem Name @tab Description
@item vectorPair<2> @tab vector pair class
@item vectorPair<3> @tab vector pair class
@end multitable

@subheading Members

 See also the full member list (@pxref{math_vectorPair_struct_full_member_list}) section for this struct.

@subsubheading Functions

@itemize
@item vectorPair()
@item vectorPair(const vectorPairBase<N> &vp)
@item vectorPair(const vector<N> &a@comma{} const vector<N> &b)
@item vector<N> & direction()
@item const vector<N> & direction() const
@item vector<N> ln_pt_clst_pt(const vector<N> &point) const
@item double ln_pt_clst_pt_scale(const vector<N> &point) const
@item vector<N> & normal()
@item const vector<N> & normal() const
@item vectorPairBase<N> operator*(double factor)
@item const vectorPairBase<N> & operator+=(const vectorPairBase<N> &p)
@item const vector<N> & operator[](int n) const
@item vector<N> & operator[](int n)
@item vector<N> & origin()
@item const vector<N> & origin() const
@item vector<N> seg_pt_clst_pt(const vector<N> &point) const
@item double seg_pt_clst_pt_scale(const vector<N> &point) const
@end itemize

@subheading Members detail

@subsubheading vectorPair()
@anchor{_912}

No documentation available

@subsubheading vectorPair(const vectorPairBase<N> &vp)
@anchor{_913}

No documentation available

@subsubheading vectorPair(const vector<N> &a@comma{} const vector<N> &b)
@anchor{_914}

No documentation available

@page

@heading math::vectorPair struct full member list
@anchor{math_vectorPair_struct_full_member_list}

@subheading Functions

@itemize
@item vectorPair()
@item vectorPair(const vectorPairBase<N> &vp)
@item vectorPair(const vector<N> &a@comma{} const vector<N> &b)
@item vector<N> & direction()
@item const vector<N> & direction() const
@item vector<N> ln_pt_clst_pt(const vector<N> &point) const
@item double ln_pt_clst_pt_scale(const vector<N> &point) const
@item vector<N> & normal()
@item const vector<N> & normal() const
@item vectorPairBase<N> operator*(double factor)
@item const vectorPairBase<N> & operator+=(const vectorPairBase<N> &p)
@item const vector<N> & operator[](int n) const
@item vector<N> & operator[](int n)
@item vector<N> & origin()
@item const vector<N> & origin() const
@item vector<N> seg_pt_clst_pt(const vector<N> &point) const
@item double seg_pt_clst_pt_scale(const vector<N> &point) const
@end itemize

@page

@heading math::vectorPair<2> struct reference
@anchor{math_vectorPair_2_struct_reference}

@subheading Declaration

@example
#include <goptical/core/math/vectorPair>

namespace goptical @{
  namespace math @{
    template <> struct vectorPair<2>;
  @};
@};

@end example

 This struct is a member of the math namespace.

This struct is a specialization of vectorPair (@pxref{math_vectorPair_struct_reference}).

@subheading Description

This class hold two 2d vectors.

See also vectorPair2 (@pxref{_658}) typedef.

@subheading Members

 See also the full member list (@pxref{math_vectorPair_2_struct_full_member_list}) section for this struct.

@subsubheading Functions

@itemize
@item vectorPair()
@item vectorPair(const vectorPairBase<2> &vp)
@item vectorPair(const vector<2> &a@comma{} const vector<2> &b)
@item vectorPair(double ax@comma{} double ay@comma{} double bx@comma{} double by)
@item template vectorPair(const vectorPairBase<N> &v@comma{} unsigned int c0@comma{} unsigned int c1)
@item vector<N> & direction()
@item const vector<N> & direction() const
@item vector<2> ln_intersect_ln(const vectorPair<2> &line) const
@item double ln_intersect_ln_scale(const vectorPair<2> &line) const
@item vector<N> ln_pt_clst_pt(const vector<N> &point) const
@item double ln_pt_clst_pt_scale(const vector<N> &point) const
@item vector<N> & normal()
@item const vector<N> & normal() const
@item vectorPairBase<2> operator*(double factor)
@item const vectorPairBase<2> & operator+=(const vectorPairBase<2> &p)
@item const vector<N> & operator[](int n) const
@item vector<N> & operator[](int n)
@item vector<N> & origin()
@item const vector<N> & origin() const
@item template vector<2> seg_intersect_seg(const vectorPair<2> &segment) const
@item vector<N> seg_pt_clst_pt(const vector<N> &point) const
@item double seg_pt_clst_pt_scale(const vector<N> &point) const
@item double x0() const
@item double & x0()
@item double x1() const
@item double & x1()
@item double y0() const
@item double & y0()
@item double y1() const
@item double & y1()
@end itemize

@subheading Members detail

@subsubheading vectorPair()
@anchor{_915}

No documentation available

@subsubheading vectorPair(const vectorPairBase<2> &vp)
@anchor{_916}

No documentation available

@subsubheading vectorPair(const vector<2> &a@comma{} const vector<2> &b)
@anchor{_917}

No documentation available

@subsubheading vectorPair(double ax@comma{} double ay@comma{} double bx@comma{} double by)
@anchor{_918}

No documentation available

@subsubheading template <int N> vectorPair(const vectorPairBase<N> &v@comma{} unsigned int c0@comma{} unsigned int c1)
@anchor{_919}

Create a 2d vector pair and initialize vectors from specified components of vectors from an other pair.

@subsubheading vector<2> ln_intersect_ln(const vectorPair<2> &line) const
@anchor{_920}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a line with origin and direction vectors and find the intersection point with an other line.

The return value is position of the intersection point. this function throws if lines are almost parallel.

See also ln_intersect_ln_scale (@pxref{_921}) function.

@subsubheading double ln_intersect_ln_scale(const vectorPair<2> &line) const
@anchor{_921}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a line with origin and direction vectors and find the intersection point with an other line.

The return value is scale factor of the direction vector from line origin. this function throws if lines are almost parallel.

See also ln_intersect_ln (@pxref{_920}) function.

@subsubheading template <bool infinite_1st@comma{} bool infinite_2nd> vector<2> seg_intersect_seg(const vectorPair<2> &segment) const
@anchor{_922}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a segment with two point vectors and find the intersection point with an other segment.

The return value is position of the intersection point. 

The @samp{infinite_1st} and @samp{infinite_2nd} template parameters can be used to disable point-in-segment tests for each segments. this template function throws if lines are almost parallel or if intersection point lies outside segment and associated test is enabled.

@subsubheading double x0() const
@anchor{_923}

 Get vector pair component

@subsubheading double & x0()
@anchor{_924}

 Get vector pair component

@subsubheading double x1() const
@anchor{_925}

 Get vector pair component

@subsubheading double & x1()
@anchor{_926}

 Get vector pair component

@subsubheading double y0() const
@anchor{_927}

 Get vector pair component

@subsubheading double & y0()
@anchor{_928}

 Get vector pair component

@subsubheading double y1() const
@anchor{_929}

 Get vector pair component

@subsubheading double & y1()
@anchor{_930}

 Get vector pair component

@page

@heading math::vectorPair<2> struct full member list
@anchor{math_vectorPair_2_struct_full_member_list}

@subheading Functions

@itemize
@item vectorPair()
@item vectorPair(const vectorPairBase<2> &vp)
@item vectorPair(const vector<2> &a@comma{} const vector<2> &b)
@item vectorPair(double ax@comma{} double ay@comma{} double bx@comma{} double by)
@item template vectorPair(const vectorPairBase<N> &v@comma{} unsigned int c0@comma{} unsigned int c1)
@item vector<N> & direction()
@item const vector<N> & direction() const
@item vector<2> ln_intersect_ln(const vectorPair<2> &line) const
@item double ln_intersect_ln_scale(const vectorPair<2> &line) const
@item vector<N> ln_pt_clst_pt(const vector<N> &point) const
@item double ln_pt_clst_pt_scale(const vector<N> &point) const
@item vector<N> & normal()
@item const vector<N> & normal() const
@item vectorPairBase<2> operator*(double factor)
@item const vectorPairBase<2> & operator+=(const vectorPairBase<2> &p)
@item const vector<N> & operator[](int n) const
@item vector<N> & operator[](int n)
@item vector<N> & origin()
@item const vector<N> & origin() const
@item template vector<2> seg_intersect_seg(const vectorPair<2> &segment) const
@item vector<N> seg_pt_clst_pt(const vector<N> &point) const
@item double seg_pt_clst_pt_scale(const vector<N> &point) const
@item double x0() const
@item double & x0()
@item double x1() const
@item double & x1()
@item double y0() const
@item double & y0()
@item double y1() const
@item double & y1()
@end itemize

@page

@heading math::vectorPair<3> struct reference
@anchor{math_vectorPair_3_struct_reference}

@subheading Declaration

@example
#include <goptical/core/math/vectorPair>

namespace goptical @{
  namespace math @{
    template <> struct vectorPair<3>;
  @};
@};

@end example

 This struct is a member of the math namespace.

This struct is a specialization of vectorPair (@pxref{math_vectorPair_struct_reference}).

@subheading Inheritance

@subheading Description

This class hold two 3d vectors.

See also vectorPair3 (@pxref{_654}) typedef.

@subheading Members

 See also the full member list (@pxref{math_vectorPair_3_struct_full_member_list}) section for this struct.

@subsubheading Functions

@itemize
@item vectorPair()
@item vectorPair(const vectorPairBase<3> &vp)
@item vectorPair(const vector<3> &a@comma{} const vector<3> &b = @emph{[...]})
@item vectorPair(double ax@comma{} double ay@comma{} double az@comma{} double bx = @emph{[...]}@comma{} double by = @emph{[...]}@comma{} double bz = @emph{[...]})
@item vector<N> & direction()
@item const vector<N> & direction() const
@item vector<3> ln_ln_clst_pt(const vectorPair<3> &line) const
@item double ln_ln_clst_pt_scale(const vectorPair<3> &line) const
@item vector<N> ln_pt_clst_pt(const vector<N> &point) const
@item double ln_pt_clst_pt_scale(const vector<N> &point) const
@item vector<N> & normal()
@item const vector<N> & normal() const
@item vectorPairBase<3> operator*(double factor)
@item const vectorPairBase<3> & operator+=(const vectorPairBase<3> &p)
@item const vector<N> & operator[](int n) const
@item vector<N> & operator[](int n)
@item vector<N> & origin()
@item const vector<N> & origin() const
@item vector<3> pl_ln_intersect(const vectorPair<3> &line) const
@item double pl_ln_intersect_scale(const vectorPair<3> &line) const
@item vector<N> seg_pt_clst_pt(const vector<N> &point) const
@item double seg_pt_clst_pt_scale(const vector<N> &point) const
@item double x0() const
@item double & x0()
@item double x1() const
@item double & x1()
@item double y0() const
@item double & y0()
@item double y1() const
@item double & y1()
@item double z0() const
@item double & z0()
@item double z1() const
@item double & z1()
@end itemize

@subheading Members detail

@subsubheading vectorPair()
@anchor{_931}

No documentation available

@subsubheading vectorPair(const vectorPairBase<3> &vp)
@anchor{_932}

No documentation available

@subsubheading vectorPair(const vector<3> &a@comma{} const vector<3> &b = vector3_001)
@anchor{_933}

No documentation available

@subsubheading vectorPair(double ax@comma{} double ay@comma{} double az@comma{} double bx = 0.0@comma{} double by = 0.0@comma{} double bz = 1.0)
@anchor{_934}

No documentation available

@subsubheading vector<3> ln_ln_clst_pt(const vectorPair<3> &line) const
@anchor{_935}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a line with origin and direction vectors and find the closest point on this line to an other line.

The return value is position of the closest point on the line. this function throws if lines are almost parallel.

See also ln_ln_clst_pt_scale (@pxref{_936}) function.

@subsubheading double ln_ln_clst_pt_scale(const vectorPair<3> &line) const
@anchor{_936}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a line with origin and direction vectors and find the closest point on this line to an other line.

The return value is scale factor of the direction vector from origin. this function throws if lines are almost parallel.

See also ln_ln_clst_pt (@pxref{_935}) function.

@subsubheading vector<3> pl_ln_intersect(const vectorPair<3> &line) const
@anchor{_937}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a plane and find intersection point with a line. Plane is defined by origin and normal vectors and line is defined by origin and direction vectors.

The return value is position of the intersection point on the line.

See also pl_ln_intersect_scale (@pxref{_938}) function.

@subsubheading double pl_ln_intersect_scale(const vectorPair<3> &line) const
@anchor{_938}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a plane and find intersection point with a line. Plane is defined by origin and normal vectors and line is defined by origin and direction vectors.

The return value is scale factor of the line direction vector from line origin.

See also pl_ln_intersect (@pxref{_937}) function.

@subsubheading double x0() const
@anchor{_939}

 Get vector pair component

@subsubheading double & x0()
@anchor{_940}

 Get vector pair component

@subsubheading double x1() const
@anchor{_941}

 Get vector pair component

@subsubheading double & x1()
@anchor{_942}

 Get vector pair component

@subsubheading double y0() const
@anchor{_943}

 Get vector pair component

@subsubheading double & y0()
@anchor{_944}

 Get vector pair component

@subsubheading double y1() const
@anchor{_945}

 Get vector pair component

@subsubheading double & y1()
@anchor{_946}

 Get vector pair component

@subsubheading double z0() const
@anchor{_947}

 Get vector pair component

@subsubheading double & z0()
@anchor{_948}

 Get vector pair component

@subsubheading double z1() const
@anchor{_949}

 Get vector pair component

@subsubheading double & z1()
@anchor{_950}

 Get vector pair component

@page

@heading math::vectorPair<3> struct full member list
@anchor{math_vectorPair_3_struct_full_member_list}

@subheading Functions

@itemize
@item vectorPair()
@item vectorPair(const vectorPairBase<3> &vp)
@item vectorPair(const vector<3> &a@comma{} const vector<3> &b = @emph{[...]})
@item vectorPair(double ax@comma{} double ay@comma{} double az@comma{} double bx = @emph{[...]}@comma{} double by = @emph{[...]}@comma{} double bz = @emph{[...]})
@item vector<N> & direction()
@item const vector<N> & direction() const
@item vector<3> ln_ln_clst_pt(const vectorPair<3> &line) const
@item double ln_ln_clst_pt_scale(const vectorPair<3> &line) const
@item vector<N> ln_pt_clst_pt(const vector<N> &point) const
@item double ln_pt_clst_pt_scale(const vector<N> &point) const
@item vector<N> & normal()
@item const vector<N> & normal() const
@item vectorPairBase<3> operator*(double factor)
@item const vectorPairBase<3> & operator+=(const vectorPairBase<3> &p)
@item const vector<N> & operator[](int n) const
@item vector<N> & operator[](int n)
@item vector<N> & origin()
@item const vector<N> & origin() const
@item vector<3> pl_ln_intersect(const vectorPair<3> &line) const
@item double pl_ln_intersect_scale(const vectorPair<3> &line) const
@item vector<N> seg_pt_clst_pt(const vector<N> &point) const
@item double seg_pt_clst_pt_scale(const vector<N> &point) const
@item double x0() const
@item double & x0()
@item double x1() const
@item double & x1()
@item double y0() const
@item double & y0()
@item double y1() const
@item double & y1()
@item double z0() const
@item double & z0()
@item double z1() const
@item double & z1()
@end itemize

@page

@heading math::vectorPairBase<N> internal struct members

@subheading vectorPairBase()

No documentation available

@subheading vectorPairBase(const vector<N> &a@comma{} const vector<N> &b)

No documentation available

@subheading vector<N> & direction()
@anchor{_953}

Get reference to second vector

@subheading const vector<N> & direction() const
@anchor{_954}

Get reference to second vector

@subheading vector<N> ln_pt_clst_pt(const vector<N> &point) const
@anchor{_955}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a line with origin and direction vectors and find the closest point on this line to a point.

The return value is position of the closest point on the line.

See also ln_pt_clst_pt_scale (@pxref{_1059}) function.

@subheading double ln_pt_clst_pt_scale(const vector<N> &point) const
@anchor{_956}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a line with origin and direction vectors and find the closest point on this line to an other line.

The return value is scale factor of the direction vector from origin.

See also ln_pt_clst_pt (@pxref{_1058}) function.

@subheading vector<N> & normal()
@anchor{_957}

Get reference to second vector

@subheading const vector<N> & normal() const
@anchor{_958}

Get reference to second vector

@subheading vectorPairBase<N> operator*(double factor)
@anchor{_959}

No documentation available

@subheading const vectorPairBase<N> & operator+=(const vectorPairBase<N> &p)
@anchor{_960}

No documentation available

@subheading const vector<N> & operator[](int n) const
@anchor{_961}

Get a reference to a vector stored in the pair

@subheading vector<N> & operator[](int n)
@anchor{_962}

Get a reference to a vector stored in the pair

@subheading vector<N> & origin()
@anchor{_963}

Get reference to first vector

@subheading const vector<N> & origin() const
@anchor{_964}

Get reference to first vector

@subheading vector<N> seg_pt_clst_pt(const vector<N> &point) const
@anchor{_965}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a segment with two point vectors and find the closest point on this segment to a point in space.

The return value is position of the closest point on segment.

See also seg_pt_clst_pt_scale (@pxref{_1069}) function.

@subheading double seg_pt_clst_pt_scale(const vector<N> &point) const
@anchor{_966}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a segment with two point vectors and find the closest point on this segment to a point in space.

The return value is position on segment@comma{} value is in [0@comma{} 1] range if on segment.

See also seg_pt_clst_pt (@pxref{_1068}) function.

@page

@heading math::vectorPairBase<2> internal struct members

@subheading vectorPairBase()

No documentation available

@subheading vectorPairBase(const vector<N> &a@comma{} const vector<N> &b)

No documentation available

@subheading vector<N> & direction()
@anchor{_969}

Get reference to second vector

@subheading const vector<N> & direction() const
@anchor{_970}

Get reference to second vector

@subheading vector<N> ln_pt_clst_pt(const vector<N> &point) const
@anchor{_971}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a line with origin and direction vectors and find the closest point on this line to a point.

The return value is position of the closest point on the line.

See also ln_pt_clst_pt_scale (@pxref{_1059}) function.

@subheading double ln_pt_clst_pt_scale(const vector<N> &point) const
@anchor{_972}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a line with origin and direction vectors and find the closest point on this line to an other line.

The return value is scale factor of the direction vector from origin.

See also ln_pt_clst_pt (@pxref{_1058}) function.

@subheading vector<N> & normal()
@anchor{_973}

Get reference to second vector

@subheading const vector<N> & normal() const
@anchor{_974}

Get reference to second vector

@subheading vectorPairBase<2> operator*(double factor)
@anchor{_975}

No documentation available

@subheading const vectorPairBase<2> & operator+=(const vectorPairBase<2> &p)
@anchor{_976}

No documentation available

@subheading const vector<N> & operator[](int n) const
@anchor{_977}

Get a reference to a vector stored in the pair

@subheading vector<N> & operator[](int n)
@anchor{_978}

Get a reference to a vector stored in the pair

@subheading vector<N> & origin()
@anchor{_979}

Get reference to first vector

@subheading const vector<N> & origin() const
@anchor{_980}

Get reference to first vector

@subheading vector<N> seg_pt_clst_pt(const vector<N> &point) const
@anchor{_981}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a segment with two point vectors and find the closest point on this segment to a point in space.

The return value is position of the closest point on segment.

See also seg_pt_clst_pt_scale (@pxref{_1069}) function.

@subheading double seg_pt_clst_pt_scale(const vector<N> &point) const
@anchor{_982}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a segment with two point vectors and find the closest point on this segment to a point in space.

The return value is position on segment@comma{} value is in [0@comma{} 1] range if on segment.

See also seg_pt_clst_pt (@pxref{_1068}) function.

@page

@heading math::vectorPairBase<3> internal struct members

@subheading vectorPairBase()

No documentation available

@subheading vectorPairBase(const vector<N> &a@comma{} const vector<N> &b)

No documentation available

@subheading vector<N> & direction()
@anchor{_985}

Get reference to second vector

@subheading const vector<N> & direction() const
@anchor{_986}

Get reference to second vector

@subheading vector<N> ln_pt_clst_pt(const vector<N> &point) const
@anchor{_987}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a line with origin and direction vectors and find the closest point on this line to a point.

The return value is position of the closest point on the line.

See also ln_pt_clst_pt_scale (@pxref{_1059}) function.

@subheading double ln_pt_clst_pt_scale(const vector<N> &point) const
@anchor{_988}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a line with origin and direction vectors and find the closest point on this line to an other line.

The return value is scale factor of the direction vector from origin.

See also ln_pt_clst_pt (@pxref{_1058}) function.

@subheading vector<N> & normal()
@anchor{_989}

Get reference to second vector

@subheading const vector<N> & normal() const
@anchor{_990}

Get reference to second vector

@subheading vectorPairBase<3> operator*(double factor)
@anchor{_991}

No documentation available

@subheading const vectorPairBase<3> & operator+=(const vectorPairBase<3> &p)
@anchor{_992}

No documentation available

@subheading const vector<N> & operator[](int n) const
@anchor{_993}

Get a reference to a vector stored in the pair

@subheading vector<N> & operator[](int n)
@anchor{_994}

Get a reference to a vector stored in the pair

@subheading vector<N> & origin()
@anchor{_995}

Get reference to first vector

@subheading const vector<N> & origin() const
@anchor{_996}

Get reference to first vector

@subheading vector<N> seg_pt_clst_pt(const vector<N> &point) const
@anchor{_997}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a segment with two point vectors and find the closest point on this segment to a point in space.

The return value is position of the closest point on segment.

See also seg_pt_clst_pt_scale (@pxref{_1069}) function.

@subheading double seg_pt_clst_pt_scale(const vector<N> &point) const
@anchor{_998}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a segment with two point vectors and find the closest point on this segment to a point in space.

The return value is position on segment@comma{} value is in [0@comma{} 1] range if on segment.

See also seg_pt_clst_pt (@pxref{_1068}) function.

@page

@heading math::TransformBase internal class members

@subheading TransformBase()

No documentation available

@subheading virtual ~TransformBase()

No documentation available

@subheading TransformBase & affine_rotation(unsigned int axis@comma{} double dangle)

apply rotation to current transform (degree)

@subheading TransformBase & affine_rotation_rad(unsigned int axis@comma{} double rangle)

apply rotation to current transform (radian)

@subheading TransformBase & affine_scaling(const vector<N> &v)

apply scaling to current transform

@subheading TransformBase & affine_scaling(double s)

apply scaling to current transform

@subheading TransformBase & apply_translation(const vector<N> &v)

apply translation to current transform

@subheading void compose(const TransformBase<N> &t)

compose with t. new transform is equivalent to applying t then this transform

@subheading const Matrix<N> & get_linear() const

get linear transform matrix

@subheading Matrix<N> & get_linear()

get linear transform matrix

@subheading const vector<N> & get_translation() const

get translation vector

@subheading vector<N> & get_translation()

get translation vector

@subheading TransformBase inverse() const

get inverse transformation

@subheading void linear_reset()

reset linear transform to identity

@subheading TransformBase & linear_rotation(unsigned int axis@comma{} double dangle)

apply rotation to current transform (degree) (does not transform translation vector)

@subheading TransformBase & linear_rotation_rad(unsigned int axis@comma{} double rangle)

apply rotation to current transform (radian) (does not transform translation vector)

@subheading TransformBase & linear_scaling(const vector<N> &v)

apply linear scaling to current transform (does not transform translation vector)

@subheading TransformBase & linear_scaling(double s)

apply scaling to current transform (does not transform translation vector)

@subheading void reset()

reset linear transform to identity and translation to zero

@subheading void set_translation(const vector<N> &v)

set current translation

@subheading vector<N> transform(const vector<N> &v) const

apply affine transform (translation and linear) to vector

@subheading vectorPair<N> transform_line(const vectorPair<N> &v) const

apply affine transform to line origin and linear to direction

@subheading vector<N> transform_linear(const vector<N> &v) const

apply linear transform to vector

@subheading vectorPair<N> transform_pair(const vectorPair<N> &p) const

apply affine transform to both vectors in pair

@subheading vector<N> transform_translate(const vector<N> &v) const

apply translation to vector

@subheading void translation_reset()

reset translation to zero

@page

@heading math::TriangleBase internal struct members

@subheading TriangleBase()

No documentation available

@subheading TriangleBase(const vector<N> &a@comma{} const vector<N> &b@comma{} const vector<N> &c)

Create a triangle from 3 points

@subheading vector<N> get_centroid() const

Get triangle centroid

@subheading const vector<N> & operator[](int n) const

Get point n of the triangle

@subheading vector<N> & operator[](int n)

Get reference to point n of the triangle

@page

@heading math::vectorBase internal struct members

@subheading bool close_to(const vectorBase &m@comma{} T error = 1 e-8)

compare two almost equal vectors

@subheading T len() const

Compute vector length

@subheading vectorBase magnitude(T newlen) const

Adjust vector length

@subheading vectorBase mul(const vectorBase &v) const

vector values multiply

@subheading vectorBase & neg()

Negate vector

@subheading const vectorBase & normalize()
@anchor{_1035}

Normalize vector length 

See also normalized (@pxref{_1036}) function.

@subheading vectorBase normalized() const
@anchor{_1036}

Get normalized vector 

See also normalize (@pxref{_1035}) function.

@subheading T operator*(const vectorBase &v) const

vector dot product

@subheading vectorBase operator*(T scale) const

Scale vector

@subheading vectorBase operator*(const Matrix<N> &m)

Multiply vector with matrix. See vector class for matrix/vector multiplication.

@subheading const vectorBase & operator*=(T scale)

Multiply by a vector

@subheading vectorBase operator+(const vectorBase &v) const

Add two vectors

@subheading const vectorBase & operator+=(const vectorBase &v)

Add a vector

@subheading vectorBase operator-(const vectorBase &v) const

Subtract two vectors

@subheading vectorBase operator-() const

Get negated vector

@subheading const vectorBase & operator-=(const vectorBase &v)

Sutract a vector

@subheading vectorBase operator/(T scale) const

Scale vector

@subheading vectorBase operator/(const vectorBase &v) const

vector division

@subheading const vectorBase & operator/=(T scale)

Divide by a vector

@subheading bool operator==(const vectorBase &m) const

compare two vectors for equality

@subheading T operator[](int n) const

Get value at specified index

@subheading T & operator[](int n)

Get reference to value at specified index

@subheading template <int M> vectorBase<M@comma{} T> select(unsigned int bitmask@comma{} const vectorBase<M@comma{} T> &v) const

Select components from two vectors. Components which have their corresponding bit set in the mask are extracted from this vector and other components are taken from passed vector.

@subheading void set(T value)

Set the whole vector to the specified value

@page

@heading math::vectorPairBase internal struct members

@subheading vectorPairBase()

No documentation available

@subheading vectorPairBase(const vector<N> &a@comma{} const vector<N> &b)

No documentation available

@subheading vector<N> & direction()

Get reference to second vector

@subheading const vector<N> & direction() const

Get reference to second vector

@subheading vector<N> ln_pt_clst_pt(const vector<N> &point) const
@anchor{_1058}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a line with origin and direction vectors and find the closest point on this line to a point.

The return value is position of the closest point on the line.

See also ln_pt_clst_pt_scale (@pxref{_1059}) function.

@subheading double ln_pt_clst_pt_scale(const vector<N> &point) const
@anchor{_1059}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a line with origin and direction vectors and find the closest point on this line to an other line.

The return value is scale factor of the direction vector from origin.

See also ln_pt_clst_pt (@pxref{_1058}) function.

@subheading vector<N> & normal()

Get reference to second vector

@subheading const vector<N> & normal() const

Get reference to second vector

@subheading vectorPairBase operator*(double factor)

No documentation available

@subheading const vectorPairBase & operator+=(const vectorPairBase &p)

No documentation available

@subheading const vector<N> & operator[](int n) const

Get a reference to a vector stored in the pair

@subheading vector<N> & operator[](int n)

Get a reference to a vector stored in the pair

@subheading vector<N> & origin()

Get reference to first vector

@subheading const vector<N> & origin() const

Get reference to first vector

@subheading vector<N> seg_pt_clst_pt(const vector<N> &point) const
@anchor{_1068}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a segment with two point vectors and find the closest point on this segment to a point in space.

The return value is position of the closest point on segment.

See also seg_pt_clst_pt_scale (@pxref{_1069}) function.

@subheading double seg_pt_clst_pt_scale(const vector<N> &point) const
@anchor{_1069}

Consider the vectorPair (@pxref{math_vectorPair_struct_reference}) as a segment with two point vectors and find the closest point on this segment to a point in space.

The return value is position on segment@comma{} value is in [0@comma{} 1] range if on segment.

See also seg_pt_clst_pt (@pxref{_1068}) function.

@page

@heading shape namespace reference
@anchor{shape_namespace_reference}

@subheading Description
2d shapes used for surface contours
@subheading Members

@subsubheading Types

@itemize
@item class Base
@item class Composer
@item class disk
@item class Ellipse
@item class EllipticalRing
@item class Infinite
@item class Polygon
@item class Rectangle
@item class RegularPolygon
@item class Ring
@end itemize

@subsubheading Variable

@itemize
@item Infinite infinite
@end itemize

@subheading Members detail

@subsubheading Infinite infinite
@anchor{_1070}

No documentation available

@page

@heading shape::Base class reference
@anchor{shape_Base_class_reference}

@subheading Declaration

@example
#include <goptical/core/shape/Base>

namespace goptical @{
  namespace shape @{
    class Base;
  @};
@};

@end example

 This class is a member of the shape namespace.

This abstract class contains pure virtuals.

@subheading Inheritance

@subheading Description

This class defines an interface for all 2d shape implementations. It is mainly used to describe 2d contours of optical surfaces and provides distribution pattern for ray tracing.

@subheading Members

 See also the full member list (@pxref{shape_Base_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item Base()
@item virtual ~Base()
@item virtual math::vectorPair2 get_bounding_box() const = 0;
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const = 0;
@item virtual unsigned int get_contour_count() const = 0;
@item virtual double get_hole_radius(const math::vector2 &dir) const
@item virtual double get_outter_radius(const math::vector2 &dir) const = 0;
@item virtual void get_pattern(const math::vector2::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed = @emph{[...]}) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const = 0;
@item virtual bool inside(const math::vector2 &point) const = 0;
@item virtual double max_radius() const = 0;
@item virtual double min_radius() const = 0;
@end itemize

@subheading Members detail

@subsubheading Base()
@anchor{_1071}

No documentation available

@subsubheading virtual ~Base()
@anchor{_1072}

No documentation available

@subsubheading virtual math::vectorPair2 get_bounding_box() const = 0;
@anchor{_1073}

Get shape bounding box

@subsubheading virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const = 0;
@anchor{_1074}

Get contour polygone points for specified contour id. First contour is always outter edge. 

See also get_contour_count (@pxref{_1075}) function.

@subsubheading virtual unsigned int get_contour_count() const = 0;
@anchor{_1075}

Get number of contours polygones. This function returns value is greater than 1 if shape has hole(s). 

See also get_contour (@pxref{_1074}) function.

@subsubheading virtual double get_hole_radius(const math::vector2 &dir) const
@anchor{_1076}

Get distance between origin and nearest shape outter edge in specified direction

@subsubheading virtual double get_outter_radius(const math::vector2 &dir) const = 0;
@anchor{_1077}

Get distance between origin and farthest shape edge in specified direction

@subsubheading virtual void get_pattern(const math::vector2::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed = false) const
@anchor{_1078}

Get points distributed on shape area with given pattern

@subsubheading virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const = 0;
@anchor{_1079}

Get shape teselation triangles

@subsubheading virtual bool inside(const math::vector2 &point) const = 0;
@anchor{_1080}

Check if the (x@comma{}y) 2d point is inside 2d shape area

@subsubheading virtual double max_radius() const = 0;
@anchor{_1081}

Get distance between origin and farthest shape edge

@subsubheading virtual double min_radius() const = 0;
@anchor{_1082}

Get distance between origin and nearest shape outter edge

@page

@heading shape::Base class full member list
@anchor{shape_Base_class_full_member_list}

@subheading Functions

@itemize
@item Base()
@item virtual ~Base()
@item virtual math::vectorPair2 get_bounding_box() const = 0;
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const = 0;
@item virtual unsigned int get_contour_count() const = 0;
@item virtual double get_hole_radius(const math::vector2 &dir) const
@item virtual double get_outter_radius(const math::vector2 &dir) const = 0;
@item virtual void get_pattern(const math::vector2::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed = @emph{[...]}) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const = 0;
@item virtual bool inside(const math::vector2 &point) const = 0;
@item virtual double max_radius() const = 0;
@item virtual double min_radius() const = 0;
@end itemize

@page

@heading shape::Composer class reference
@anchor{shape_Composer_class_reference}

@subheading Declaration

This class is flagged as experimental.

@example
#include <goptical/core/shape/Composer>

namespace goptical @{
  namespace shape @{
    class Composer;
  @};
@};

@end example

 This class is a member of the shape namespace.

@subheading Inheritance

@subheading Description

This class allows definition of a shape by composition of other shape models. Coordinate transforms and boolean operations can be performed on shapes.

This class is still experimental@comma{} 2d contour and 3d tessellation code doesn't give propser results.

@subheading Members

 See also the full member list (@pxref{shape_Composer_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 12 members inherited from Base (@pxref{shape_Base_class_reference})
@end itemize

@subsubheading Type

@itemize
@item class Attributes
@end itemize

@subsubheading Functions

@itemize
@item Composer()
@item Attributes & add_shape(const const_ref<Base> &shape)
@item virtual math::vectorPair2 get_bounding_box() const
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item virtual double get_hole_radius(const math::vector2 &dir) const
@item virtual double get_outter_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item virtual bool inside(const math::vector2 &point) const
@item virtual double max_radius() const
@item virtual double min_radius() const
@item void use_global_distribution(bool use_global)
@end itemize

@subheading Members detail

@subsubheading Composer()
@anchor{_1083}

This constructor is flagged as experimental.

@subsubheading Attributes & add_shape(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <Base> &shape)
@anchor{_1084}

This function is flagged as experimental.

Add a new shape to shape composer.

This function returns a reference to an Attributes (@pxref{shape_Composer_Attributes_class_reference}) object which may be modified to set shape transform and boolean operations.

The composed shape is the union between all shapes added with this function.

@subsubheading virtual math::vectorPair2 get_bounding_box() const
@anchor{_1085}

This virtual function is flagged as experimental.

This virtual function implements the @code{get_bounding_box (@pxref{_1073})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape bounding box

@subsubheading virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@anchor{_1086}

This virtual function is flagged as experimental.

This virtual function implements the @code{get_contour (@pxref{_1074})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get contour polygone points for specified contour id. First contour is always outter edge. 

See also get_contour_count (@pxref{_1075}) function.

@subsubheading virtual unsigned int get_contour_count() const
@anchor{_1087}

This virtual function is flagged as experimental.

This virtual function implements the @code{get_contour_count (@pxref{_1075})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get number of contours polygones. This function returns value is greater than 1 if shape has hole(s). 

See also get_contour (@pxref{_1074}) function.

@subsubheading virtual double get_hole_radius(const math::vector2 &dir) const
@anchor{_1088}

This virtual function is flagged as experimental.

This virtual function overrides the @code{get_hole_radius (@pxref{_1076})} virtual function defined in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and nearest shape outter edge in specified direction

@subsubheading virtual double get_outter_radius(const math::vector2 &dir) const
@anchor{_1089}

This virtual function is flagged as experimental.

This virtual function implements the @code{get_outter_radius (@pxref{_1077})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and farthest shape edge in specified direction

@subsubheading virtual void get_pattern(const math::vector2::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@anchor{_1090}

This virtual function is flagged as experimental.

This virtual function overrides the @code{get_pattern (@pxref{_1078})} virtual function defined in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get points distributed on shape area with given pattern

@subsubheading virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@anchor{_1091}

This virtual function is flagged as experimental.

This virtual function implements the @code{get_triangles (@pxref{_1079})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape teselation triangles

@subsubheading virtual bool inside(const math::vector2 &point) const
@anchor{_1092}

This virtual function is flagged as experimental.

This virtual function implements the @code{inside (@pxref{_1080})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Check if the (x@comma{}y) 2d point is inside 2d shape area

@subsubheading virtual double max_radius() const
@anchor{_1093}

This virtual function is flagged as experimental.

This virtual function implements the @code{max_radius (@pxref{_1081})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and farthest shape edge

@subsubheading virtual double min_radius() const
@anchor{_1094}

This virtual function is flagged as experimental.

This virtual function implements the @code{min_radius (@pxref{_1082})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and nearest shape outter edge

@subsubheading void use_global_distribution(bool use_global)
@anchor{_1095}

This function is flagged as experimental.

Set ray distribution behavior. Default is to perform individual ray distribution on each composer shape.

Global mode distributes rays over a circle with maximum shape radius@comma{} it may be used to ensure ray density is the same on each shape. Unobstructed ray tracing require global distribution too.

@page

@heading shape::Composer class full member list
@anchor{shape_Composer_class_full_member_list}

@subheading Type

@itemize
@item class Attributes
@end itemize

@subheading Functions

@itemize
@item Composer()
@item Attributes & add_shape(const const_ref<Base> &shape)
@item virtual math::vectorPair2 get_bounding_box() const
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item virtual double get_hole_radius(const math::vector2 &dir) const
@item virtual double get_outter_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item virtual bool inside(const math::vector2 &point) const
@item virtual double max_radius() const
@item virtual double min_radius() const
@item void use_global_distribution(bool use_global)
@end itemize

@page

@heading shape::Composer::Attributes class reference
@anchor{shape_Composer_Attributes_class_reference}

@subheading Declaration

This class is flagged as experimental.

@example
#include <goptical/core/shape/Composer>

namespace goptical @{
  namespace shape @{
    class Composer @{
      class Attributes;
    @};
  @};
@};

@end example

 This class is a member of the Composer class.

@subheading Description

This class contains child shape transform and boolean operations for the Composer (@pxref{shape_Composer_class_reference}) shape class.

@subheading Members

 See also the full member list (@pxref{shape_Composer_Attributes_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item Attributes & exclude(const const_ref<Base> &shape)
@item Attributes & include(const const_ref<Base> &shape)
@item Attributes & rotate(double dangle)
@item Attributes & scale(const math::vector2 &factor)
@item Attributes & translate(const math::vector2 &offset)
@end itemize

@subheading Members detail

@subsubheading Attributes & exclude(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <Base> &shape)
@anchor{_1096}

This function is flagged as experimental.

Peform boolean 'and not' with the given shape

@subsubheading Attributes & include(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <Base> &shape)
@anchor{_1097}

This function is flagged as experimental.

Peform boolean 'and' with the given shape

@subsubheading Attributes & rotate(double dangle)
@anchor{_1098}

This function is flagged as experimental.

Apply rotation affine transform. Angle is in degree.

@subsubheading Attributes & scale(const math::vector2 &factor)
@anchor{_1099}

This function is flagged as experimental.

Apply scaling affine transform using scale factors (xscale@comma{} yscale)

@subsubheading Attributes & translate(const math::vector2 &offset)
@anchor{_1100}

This function is flagged as experimental.

Apply translation transform

@page

@heading shape::Composer::Attributes class full member list
@anchor{shape_Composer_Attributes_class_full_member_list}

@subheading Functions

@itemize
@item Attributes & exclude(const const_ref<Base> &shape)
@item Attributes & include(const const_ref<Base> &shape)
@item Attributes & rotate(double dangle)
@item Attributes & scale(const math::vector2 &factor)
@item Attributes & translate(const math::vector2 &offset)
@end itemize

@page

@heading shape::disk class reference
@anchor{shape_disk_class_reference}

@subheading Declaration

@example
#include <goptical/core/shape/disk>

namespace goptical @{
  namespace shape @{
    class disk;
  @};
@};

@end example

 This class is a member of the shape namespace.

@subheading Inheritance

@subheading Description

This is the most common lens shape.

@subheading Members

 See also the full member list (@pxref{shape_disk_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 12 members inherited from Base (@pxref{shape_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item disk(double radius)
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@item double get_radius(void ) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item void set_radius(double r)
@end itemize

@subheading Members detail

@subsubheading disk(double radius)
@anchor{_1101}

Create a new disk with given radius

@page

@heading shape::disk class full member list
@anchor{shape_disk_class_full_member_list}

@subheading Functions

@itemize
@item disk(double radius)
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item virtual double get_hole_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@item double get_radius(void ) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item void set_radius(double r)
@end itemize

@page

@heading shape::Ellipse class reference
@anchor{shape_Ellipse_class_reference}

@subheading Declaration

@example
#include <goptical/core/shape/Ellipse>

namespace goptical @{
  namespace shape @{
    class Ellipse;
  @};
@};

@end example

 This class is a member of the shape namespace.

@subheading Inheritance

@subheading Description
Ellipse shape
@subheading Members

 See also the full member list (@pxref{shape_Ellipse_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 12 members inherited from Base (@pxref{shape_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Ellipse(double x_radius@comma{} double y_radius)
@item virtual math::vectorPair2 get_bounding_box() const
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item virtual double get_outter_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item double get_x_radius(void ) const
@item double get_y_radius(void ) const
@item virtual bool inside(const math::vector2 &point) const
@item virtual double max_radius() const
@item virtual double min_radius() const
@item void set_radius(double xr@comma{} double yr)
@end itemize

@subheading Members detail

@subsubheading Ellipse(double x_radius@comma{} double y_radius)
@anchor{_1102}

Create a new ellipse with given radius

@page

@heading shape::Ellipse class full member list
@anchor{shape_Ellipse_class_full_member_list}

@subheading Functions

@itemize
@item Ellipse(double x_radius@comma{} double y_radius)
@item virtual math::vectorPair2 get_bounding_box() const
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item virtual double get_hole_radius(const math::vector2 &dir) const
@item virtual double get_outter_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item double get_x_radius(void ) const
@item double get_y_radius(void ) const
@item virtual bool inside(const math::vector2 &point) const
@item virtual double max_radius() const
@item virtual double min_radius() const
@item void set_radius(double xr@comma{} double yr)
@end itemize

@page

@heading shape::EllipticalRing class reference
@anchor{shape_EllipticalRing_class_reference}

@subheading Declaration

@example
#include <goptical/core/shape/EllipticalRing>

namespace goptical @{
  namespace shape @{
    class EllipticalRing;
  @};
@};

@end example

 This class is a member of the shape namespace.

@subheading Inheritance

@subheading Description

This is an ellipse shape with a hole in center.

@subheading Members

 See also the full member list (@pxref{shape_EllipticalRing_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 12 members inherited from Base (@pxref{shape_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item EllipticalRing(double x_radius@comma{} double y_radius@comma{} double x_hole_radius)
@item virtual math::vectorPair2 get_bounding_box() const
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item virtual double get_hole_radius(const math::vector2 &dir) const
@item virtual double get_outter_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item double get_x_hole_radius(void ) const
@item double get_x_radius(void ) const
@item double get_y_hole_radius(void ) const
@item double get_y_radius(void ) const
@item virtual bool inside(const math::vector2 &point) const
@item virtual double max_radius() const
@item virtual double min_radius() const
@item void set_radius(double x_radius@comma{} double y_radius@comma{} double x_hole_radius)
@end itemize

@subheading Members detail

@subsubheading EllipticalRing(double x_radius@comma{} double y_radius@comma{} double x_hole_radius)
@anchor{_1103}

Create a new elliptical ring with given external ring radius along the x and y axes and hole radius along the x axis.

@page

@heading shape::EllipticalRing class full member list
@anchor{shape_EllipticalRing_class_full_member_list}

@subheading Functions

@itemize
@item EllipticalRing(double x_radius@comma{} double y_radius@comma{} double x_hole_radius)
@item virtual math::vectorPair2 get_bounding_box() const
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item virtual double get_hole_radius(const math::vector2 &dir) const
@item virtual double get_outter_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item double get_x_hole_radius(void ) const
@item double get_x_radius(void ) const
@item double get_y_hole_radius(void ) const
@item double get_y_radius(void ) const
@item virtual bool inside(const math::vector2 &point) const
@item virtual double max_radius() const
@item virtual double min_radius() const
@item void set_radius(double x_radius@comma{} double y_radius@comma{} double x_hole_radius)
@end itemize

@page

@heading shape::Infinite class reference
@anchor{shape_Infinite_class_reference}

@subheading Declaration

@example
#include <goptical/core/shape/Infinite>

namespace goptical @{
  namespace shape @{
    class Infinite;
  @};
@};

@end example

 This class is a member of the shape namespace.

@subheading Inheritance

@subheading Description

This class implements an infinite shape with no edge. Any 2d points is located inside the shape. It is useful to describe unbounded image plane for instance.

The global variable infinite (@pxref{_1070}) provides an instance of this class.

@subheading Members

 See also the full member list (@pxref{shape_Infinite_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 12 members inherited from Base (@pxref{shape_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Infinite()
@item virtual math::vectorPair2 get_bounding_box() const
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item virtual double get_outter_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item virtual bool inside(const math::vector2 &point) const
@item virtual double max_radius() const
@item virtual double min_radius() const
@end itemize

@subheading Members detail

@subsubheading Infinite()
@anchor{_1104}

Create an infinite shape

@subsubheading virtual math::vectorPair2 get_bounding_box() const
@anchor{_1105}

This virtual function implements the @code{get_bounding_box (@pxref{_1073})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape bounding box

@subsubheading virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@anchor{_1106}

This virtual function implements the @code{get_contour (@pxref{_1074})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get contour polygone points for specified contour id. First contour is always outter edge. 

See also get_contour_count (@pxref{_1075}) function.

@subsubheading virtual unsigned int get_contour_count() const
@anchor{_1107}

This virtual function implements the @code{get_contour_count (@pxref{_1075})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get number of contours polygones. This function returns value is greater than 1 if shape has hole(s). 

See also get_contour (@pxref{_1074}) function.

@subsubheading virtual double get_outter_radius(const math::vector2 &dir) const
@anchor{_1108}

This virtual function implements the @code{get_outter_radius (@pxref{_1077})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and farthest shape edge in specified direction

@subsubheading virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@anchor{_1109}

This virtual function overrides the @code{get_pattern (@pxref{_1078})} virtual function defined in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get points distributed on shape area with given pattern

@subsubheading virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@anchor{_1110}

This virtual function implements the @code{get_triangles (@pxref{_1079})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape teselation triangles

@subsubheading virtual bool inside(const math::vector2 &point) const
@anchor{_1111}

This virtual function implements the @code{inside (@pxref{_1080})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Check if the (x@comma{}y) 2d point is inside 2d shape area

@subsubheading virtual double max_radius() const
@anchor{_1112}

This virtual function implements the @code{max_radius (@pxref{_1081})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and farthest shape edge

@subsubheading virtual double min_radius() const
@anchor{_1113}

This virtual function implements the @code{min_radius (@pxref{_1082})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and nearest shape outter edge

@page

@heading shape::Infinite class full member list
@anchor{shape_Infinite_class_full_member_list}

@subheading Functions

@itemize
@item Infinite()
@item virtual math::vectorPair2 get_bounding_box() const
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item virtual double get_hole_radius(const math::vector2 &dir) const
@item virtual double get_outter_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item virtual bool inside(const math::vector2 &point) const
@item virtual double max_radius() const
@item virtual double min_radius() const
@end itemize

@page

@heading shape::Polygon class reference
@anchor{shape_Polygon_class_reference}

@subheading Declaration

@example
#include <goptical/core/shape/Polygon>

namespace goptical @{
  namespace shape @{
    class Polygon;
  @};
@};

@end example

 This class is a member of the shape namespace.

@subheading Inheritance

@subheading Description

This class implements the polygon shape.

Triangle tessellation required for proper 3d display only works with convex polygons yet.

See also RegularPolygon (@pxref{shape_RegularPolygon_class_reference}) class.

@subheading Members

 See also the full member list (@pxref{shape_Polygon_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 12 members inherited from Base (@pxref{shape_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Polygon()
@item unsigned int add_vertex(const math::vector2 &v)
@item void delete_vertex(unsigned int id)
@item const math::vector2 & get_vertex(unsigned int id)
@item unsigned int get_vertices_count() const
@item void insert_vertex(const math::vector2 &v@comma{} unsigned int id)
@end itemize

@subheading Members detail

@subsubheading Polygon()
@anchor{_1114}

Create a polygon with given radius and edge count

@subsubheading unsigned int add_vertex(const math::vector2 &v)
@anchor{_1115}

No documentation available

@subsubheading void delete_vertex(unsigned int id)
@anchor{_1116}

No documentation available

@subsubheading const math::vector2 & get_vertex(unsigned int id)
@anchor{_1117}

No documentation available

@subsubheading unsigned int get_vertices_count() const
@anchor{_1118}

No documentation available

@subsubheading void insert_vertex(const math::vector2 &v@comma{} unsigned int id)
@anchor{_1119}

No documentation available

@page

@heading shape::Polygon class full member list
@anchor{shape_Polygon_class_full_member_list}

@subheading Functions

@itemize
@item Polygon()
@item unsigned int add_vertex(const math::vector2 &v)
@item void delete_vertex(unsigned int id)
@item virtual double get_hole_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed = @emph{[...]}) const
@item const math::vector2 & get_vertex(unsigned int id)
@item unsigned int get_vertices_count() const
@item void insert_vertex(const math::vector2 &v@comma{} unsigned int id)
@end itemize

@page

@heading shape::Rectangle class reference
@anchor{shape_Rectangle_class_reference}

@subheading Declaration

@example
#include <goptical/core/shape/Rectangle>

namespace goptical @{
  namespace shape @{
    class Rectangle;
  @};
@};

@end example

 This class is a member of the shape namespace.

@subheading Inheritance

@subheading Description
Rectangle and square shape
@subheading Members

 See also the full member list (@pxref{shape_Rectangle_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 12 members inherited from Base (@pxref{shape_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Rectangle(double width@comma{} double height)
@item Rectangle(double sqsize)
@item virtual math::vectorPair2 get_bounding_box() const
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item virtual double get_outter_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item virtual bool inside(const math::vector2 &point) const
@item virtual double max_radius() const
@item virtual double min_radius() const
@end itemize

@subheading Members detail

@subsubheading Rectangle(double width@comma{} double height)
@anchor{_1120}

Create a rectangle with given width and height

@subsubheading Rectangle(double sqsize)
@anchor{_1121}

Create a square with given side length

@subsubheading virtual math::vectorPair2 get_bounding_box() const
@anchor{_1122}

This virtual function implements the @code{get_bounding_box (@pxref{_1073})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape bounding box

@subsubheading virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@anchor{_1123}

This virtual function implements the @code{get_contour (@pxref{_1074})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get contour polygone points for specified contour id. First contour is always outter edge. 

See also get_contour_count (@pxref{_1075}) function.

@subsubheading virtual unsigned int get_contour_count() const
@anchor{_1124}

This virtual function implements the @code{get_contour_count (@pxref{_1075})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get number of contours polygones. This function returns value is greater than 1 if shape has hole(s). 

See also get_contour (@pxref{_1074}) function.

@subsubheading virtual double get_outter_radius(const math::vector2 &dir) const
@anchor{_1125}

This virtual function implements the @code{get_outter_radius (@pxref{_1077})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and farthest shape edge in specified direction

@subsubheading virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@anchor{_1126}

This virtual function overrides the @code{get_pattern (@pxref{_1078})} virtual function defined in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get points distributed on shape area with given pattern

@subsubheading virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@anchor{_1127}

This virtual function implements the @code{get_triangles (@pxref{_1079})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape teselation triangles

@subsubheading virtual bool inside(const math::vector2 &point) const
@anchor{_1128}

This virtual function implements the @code{inside (@pxref{_1080})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Check if the (x@comma{}y) 2d point is inside 2d shape area

@subsubheading virtual double max_radius() const
@anchor{_1129}

This virtual function implements the @code{max_radius (@pxref{_1081})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and farthest shape edge

@subsubheading virtual double min_radius() const
@anchor{_1130}

This virtual function implements the @code{min_radius (@pxref{_1082})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and nearest shape outter edge

@page

@heading shape::Rectangle class full member list
@anchor{shape_Rectangle_class_full_member_list}

@subheading Functions

@itemize
@item Rectangle(double width@comma{} double height)
@item Rectangle(double sqsize)
@item virtual math::vectorPair2 get_bounding_box() const
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item virtual double get_hole_radius(const math::vector2 &dir) const
@item virtual double get_outter_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item virtual bool inside(const math::vector2 &point) const
@item virtual double max_radius() const
@item virtual double min_radius() const
@end itemize

@page

@heading shape::RegularPolygon class reference
@anchor{shape_RegularPolygon_class_reference}

@subheading Declaration

@example
#include <goptical/core/shape/RegularPolygon>

namespace goptical @{
  namespace shape @{
    class RegularPolygon;
  @};
@};

@end example

 This class is a member of the shape namespace.

@subheading Inheritance

@subheading Description

See Polygon (@pxref{shape_Polygon_class_reference}) class.

@subheading Members

 See also the full member list (@pxref{shape_RegularPolygon_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 12 members inherited from Base (@pxref{shape_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item RegularPolygon(double radius@comma{} unsigned int edge_cnt@comma{} double degree_angle = @emph{[...]})
@item virtual math::vectorPair2 get_bounding_box() const
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item virtual double get_outter_radius(const math::vector2 &dir) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item virtual bool inside(const math::vector2 &point) const
@item virtual double max_radius() const
@item virtual double min_radius() const
@end itemize

@subheading Members detail

@subsubheading RegularPolygon(double radius@comma{} unsigned int edge_cnt@comma{} double degree_angle = 0.)
@anchor{_1131}

Create a regular_polygon with given radius and edge count.

@subsubheading virtual math::vectorPair2 get_bounding_box() const
@anchor{_1132}

This virtual function implements the @code{get_bounding_box (@pxref{_1073})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape bounding box

@subsubheading virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@anchor{_1133}

This virtual function implements the @code{get_contour (@pxref{_1074})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get contour polygone points for specified contour id. First contour is always outter edge. 

See also get_contour_count (@pxref{_1075}) function.

@subsubheading virtual unsigned int get_contour_count() const
@anchor{_1134}

This virtual function implements the @code{get_contour_count (@pxref{_1075})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get number of contours polygones. This function returns value is greater than 1 if shape has hole(s). 

See also get_contour (@pxref{_1074}) function.

@subsubheading virtual double get_outter_radius(const math::vector2 &dir) const
@anchor{_1135}

This virtual function implements the @code{get_outter_radius (@pxref{_1077})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and farthest shape edge in specified direction

@subsubheading virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@anchor{_1136}

This virtual function implements the @code{get_triangles (@pxref{_1079})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape teselation triangles

@subsubheading virtual bool inside(const math::vector2 &point) const
@anchor{_1137}

This virtual function implements the @code{inside (@pxref{_1080})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Check if the (x@comma{}y) 2d point is inside 2d shape area

@subsubheading virtual double max_radius() const
@anchor{_1138}

This virtual function implements the @code{max_radius (@pxref{_1081})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and farthest shape edge

@subsubheading virtual double min_radius() const
@anchor{_1139}

This virtual function implements the @code{min_radius (@pxref{_1082})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and nearest shape outter edge

@page

@heading shape::RegularPolygon class full member list
@anchor{shape_RegularPolygon_class_full_member_list}

@subheading Functions

@itemize
@item RegularPolygon(double radius@comma{} unsigned int edge_cnt@comma{} double degree_angle = @emph{[...]})
@item virtual math::vectorPair2 get_bounding_box() const
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item virtual double get_hole_radius(const math::vector2 &dir) const
@item virtual double get_outter_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed = @emph{[...]}) const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item virtual bool inside(const math::vector2 &point) const
@item virtual double max_radius() const
@item virtual double min_radius() const
@end itemize

@page

@heading shape::Ring class reference
@anchor{shape_Ring_class_reference}

@subheading Declaration

@example
#include <goptical/core/shape/Ring>

namespace goptical @{
  namespace shape @{
    class Ring;
  @};
@};

@end example

 This class is a member of the shape namespace.

@subheading Inheritance

@subheading Description

This is a disk shape with a hole in center.

@subheading Members

 See also the full member list (@pxref{shape_Ring_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 12 members inherited from Base (@pxref{shape_Base_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Ring(double radius@comma{} double hole_radius)
@item virtual math::vectorPair2 get_bounding_box() const
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item double get_hole_radius() const
@item virtual double get_hole_radius(const math::vector2 &dir) const
@item virtual double get_outter_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@item double get_radius() const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item virtual bool inside(const math::vector2 &point) const
@item virtual double max_radius() const
@item virtual double min_radius() const
@item void set_radius(double radius@comma{} double hole_radius)
@end itemize

@subheading Members detail

@subsubheading Ring(double radius@comma{} double hole_radius)
@anchor{_1140}

Create a new ring with given external radius and hole radius.

@page

@heading shape::Ring class full member list
@anchor{shape_Ring_class_full_member_list}

@subheading Functions

@itemize
@item Ring(double radius@comma{} double hole_radius)
@item virtual math::vectorPair2 get_bounding_box() const
@item virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@item virtual unsigned int get_contour_count() const
@item double get_hole_radius() const
@item virtual double get_hole_radius(const math::vector2 &dir) const
@item virtual double get_outter_radius(const math::vector2 &dir) const
@item virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@item double get_radius() const
@item virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@item virtual bool inside(const math::vector2 &point) const
@item virtual double max_radius() const
@item virtual double min_radius() const
@item void set_radius(double radius@comma{} double hole_radius)
@end itemize

@page

@heading shape::Round<shape::diskBase@comma{}false> internal class members

@subheading virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@anchor{_1141}

This virtual function implements the @code{get_contour (@pxref{_1074})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get contour polygone points for specified contour id. First contour is always outter edge. 

See also get_contour_count (@pxref{_1075}) function.

@subheading virtual unsigned int get_contour_count() const
@anchor{_1142}

This virtual function implements the @code{get_contour_count (@pxref{_1075})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get number of contours polygones. This function returns value is greater than 1 if shape has hole(s). 

See also get_contour (@pxref{_1074}) function.

@subheading virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@anchor{_1143}

This virtual function overrides the @code{get_pattern (@pxref{_1078})} virtual function defined in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get points distributed on shape area with given pattern

@subheading virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@anchor{_1144}

This virtual function implements the @code{get_triangles (@pxref{_1079})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape teselation triangles

@page

@heading shape::Round<shape::EllipseBase@comma{}false> internal class members

@subheading virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@anchor{_1145}

This virtual function implements the @code{get_contour (@pxref{_1074})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get contour polygone points for specified contour id. First contour is always outter edge. 

See also get_contour_count (@pxref{_1075}) function.

@subheading virtual unsigned int get_contour_count() const
@anchor{_1146}

This virtual function implements the @code{get_contour_count (@pxref{_1075})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get number of contours polygones. This function returns value is greater than 1 if shape has hole(s). 

See also get_contour (@pxref{_1074}) function.

@subheading virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@anchor{_1147}

This virtual function overrides the @code{get_pattern (@pxref{_1078})} virtual function defined in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get points distributed on shape area with given pattern

@subheading virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@anchor{_1148}

This virtual function implements the @code{get_triangles (@pxref{_1079})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape teselation triangles

@page

@heading shape::Round<shape::EllipticalRingBase@comma{}true> internal class members

@subheading virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@anchor{_1149}

This virtual function implements the @code{get_contour (@pxref{_1074})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get contour polygone points for specified contour id. First contour is always outter edge. 

See also get_contour_count (@pxref{_1075}) function.

@subheading virtual unsigned int get_contour_count() const
@anchor{_1150}

This virtual function implements the @code{get_contour_count (@pxref{_1075})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get number of contours polygones. This function returns value is greater than 1 if shape has hole(s). 

See also get_contour (@pxref{_1074}) function.

@subheading virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@anchor{_1151}

This virtual function overrides the @code{get_pattern (@pxref{_1078})} virtual function defined in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get points distributed on shape area with given pattern

@subheading virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@anchor{_1152}

This virtual function implements the @code{get_triangles (@pxref{_1079})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape teselation triangles

@page

@heading shape::Round<shape::RingBase@comma{}true> internal class members

@subheading virtual void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const
@anchor{_1153}

This virtual function implements the @code{get_contour (@pxref{_1074})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get contour polygone points for specified contour id. First contour is always outter edge. 

See also get_contour_count (@pxref{_1075}) function.

@subheading virtual unsigned int get_contour_count() const
@anchor{_1154}

This virtual function implements the @code{get_contour_count (@pxref{_1075})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get number of contours polygones. This function returns value is greater than 1 if shape has hole(s). 

See also get_contour (@pxref{_1074}) function.

@subheading virtual void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const
@anchor{_1155}

This virtual function overrides the @code{get_pattern (@pxref{_1078})} virtual function defined in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get points distributed on shape area with given pattern

@subheading virtual void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const
@anchor{_1156}

This virtual function implements the @code{get_triangles (@pxref{_1079})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape teselation triangles

@page

@heading shape::diskBase internal class members

@subheading double get_radius(void ) const
@anchor{_1157}

Get disk radius

@subheading void set_radius(double r)
@anchor{_1158}

Set disk radius

@page

@heading shape::EllipseBase internal class members

@subheading virtual math::vectorPair2 get_bounding_box() const
@anchor{_1159}

This virtual function implements the @code{get_bounding_box (@pxref{_1073})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape bounding box

@subheading virtual double get_outter_radius(const math::vector2 &dir) const
@anchor{_1160}

This virtual function implements the @code{get_outter_radius (@pxref{_1077})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and farthest shape edge in specified direction

@subheading double get_x_radius(void ) const
@anchor{_1161}

Set ellipse radius along x axis

@subheading double get_y_radius(void ) const
@anchor{_1162}

Set ellipse radius along y axis

@subheading virtual bool inside(const math::vector2 &point) const
@anchor{_1163}

This virtual function implements the @code{inside (@pxref{_1080})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Check if the (x@comma{}y) 2d point is inside 2d shape area

@subheading virtual double max_radius() const
@anchor{_1164}

This virtual function implements the @code{max_radius (@pxref{_1081})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and farthest shape edge

@subheading virtual double min_radius() const
@anchor{_1165}

This virtual function implements the @code{min_radius (@pxref{_1082})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and nearest shape outter edge

@subheading void set_radius(double xr@comma{} double yr)
@anchor{_1166}

Set ellipse radius along x and y axis

@page

@heading shape::EllipticalRingBase internal class members

@subheading virtual math::vectorPair2 get_bounding_box() const
@anchor{_1167}

This virtual function implements the @code{get_bounding_box (@pxref{_1073})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape bounding box

@subheading virtual double get_hole_radius(const math::vector2 &dir) const
@anchor{_1168}

This virtual function overrides the @code{get_hole_radius (@pxref{_1076})} virtual function defined in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and nearest shape outter edge in specified direction

@subheading virtual double get_outter_radius(const math::vector2 &dir) const
@anchor{_1169}

This virtual function implements the @code{get_outter_radius (@pxref{_1077})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and farthest shape edge in specified direction

@subheading double get_x_hole_radius(void ) const
@anchor{_1170}

Get hole radius along the x axis

@subheading double get_x_radius(void ) const
@anchor{_1171}

Get external ring radius along the x axis

@subheading double get_y_hole_radius(void ) const
@anchor{_1172}

Get hole radius along the y axis

@subheading double get_y_radius(void ) const
@anchor{_1173}

Get external ring radius along the y axis

@subheading virtual bool inside(const math::vector2 &point) const
@anchor{_1174}

This virtual function implements the @code{inside (@pxref{_1080})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Check if the (x@comma{}y) 2d point is inside 2d shape area

@subheading virtual double max_radius() const
@anchor{_1175}

This virtual function implements the @code{max_radius (@pxref{_1081})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and farthest shape edge

@subheading virtual double min_radius() const
@anchor{_1176}

This virtual function implements the @code{min_radius (@pxref{_1082})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and nearest shape outter edge

@subheading void set_radius(double x_radius@comma{} double y_radius@comma{} double x_hole_radius)
@anchor{_1177}

Set external ring radius along the x and y axes and hole radius along the x axis.

@page

@heading shape::RingBase internal class members

@subheading virtual math::vectorPair2 get_bounding_box() const
@anchor{_1178}

This virtual function implements the @code{get_bounding_box (@pxref{_1073})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get shape bounding box

@subheading double get_hole_radius() const
@anchor{_1179}

Get hole radius

@subheading virtual double get_hole_radius(const math::vector2 &dir) const
@anchor{_1180}

This virtual function overrides the @code{get_hole_radius (@pxref{_1076})} virtual function defined in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and nearest shape outter edge in specified direction

@subheading virtual double get_outter_radius(const math::vector2 &dir) const
@anchor{_1181}

This virtual function implements the @code{get_outter_radius (@pxref{_1077})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and farthest shape edge in specified direction

@subheading double get_radius() const
@anchor{_1182}

Get ring external radius

@subheading virtual bool inside(const math::vector2 &point) const
@anchor{_1183}

This virtual function implements the @code{inside (@pxref{_1080})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Check if the (x@comma{}y) 2d point is inside 2d shape area

@subheading virtual double max_radius() const
@anchor{_1184}

This virtual function implements the @code{max_radius (@pxref{_1081})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and farthest shape edge

@subheading virtual double min_radius() const
@anchor{_1185}

This virtual function implements the @code{min_radius (@pxref{_1082})} pure function declared in the @code{Base (@pxref{shape_Base_class_reference})} base abstract class.

Documentation inherited from base class:

Get distance between origin and nearest shape outter edge

@subheading void set_radius(double radius@comma{} double hole_radius)
@anchor{_1186}

Set ring external radius and hole radius

@page

@heading shape::Round internal class members

@subheading void get_contour(unsigned int contour@comma{} const math::vector2::put_delegate_t &f@comma{} double resolution) const

No documentation available

@subheading unsigned int get_contour_count() const

No documentation available

@subheading void get_pattern(const math::vector2::put_delegate_t &v@comma{} const trace::distribution &d@comma{} bool unobstructed) const

No documentation available

@subheading void get_triangles(const math::Triangle<2>::put_delegate_t &f@comma{} double resolution) const

No documentation available

@page

@heading sys namespace reference
@anchor{sys_namespace_reference}

@subheading Description
Optical system and components
@subheading Members

@subsubheading Types

@itemize
@item class Group
@item class image
@item class Lens
@item class mirror
@item class OpticalSurface
@item class source_point
@item class SourceRays
@item class system
@item class Container
@item class Element
@item enum LensEdge
@item class Source
@item enum SourceInfinityMode
@item class Stop
@item class Surface
@end itemize

@subsubheading Functions

@itemize
@item std::ostream & operator<<(std::ostream &o@comma{} const Element &e)
@item std::ostream & operator<<(std::ostream &o@comma{} const Container &v)
@end itemize

@subheading Members detail

@subsubheading enum LensEdge
@anchor{_1191}

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item StraightEdge @tab 
@item SlopeEdge @tab 
@end multitable

@subsubheading enum SourceInfinityMode
@anchor{_1192}

Specifies point source location mode

@multitable @columnfractions 0.309859154929577 0.690140845070423
@headitem Identifier @tab Description
@item SourceAtFiniteDistance @tab 
In finite distance mode the point source is located at specified position and all rays are traced from this point.

@item SourceAtInfinity @tab 
In infinity mode the point source generate parallel rays oriented along source direction vector.

@end multitable

@subsubheading std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  & operator<<(std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  &o@comma{} const Element &e)
@anchor{_1193}

No documentation available

@subsubheading std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  & operator<<(std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  &o@comma{} const Container &v)
@anchor{_1194}

No documentation available

@page

@heading sys::Group class reference
@anchor{sys_Group_class_reference}

@subheading Declaration

@example
#include <goptical/core/sys/Group>

namespace goptical @{
  namespace sys @{
    class Group;
  @};
@};

@end example

 This class is a member of the sys namespace.

@subheading Inheritance

@subheading Description

This class is used to form a group of optical elements. A group is a special kind of optical element which can contains other elements. A group has its own local coordinate system.

See also system hierarchy and groups (@pxref{system hierarchy and groups}) section.

@subheading Members

 See also the full member list (@pxref{sys_Group_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 16 members inherited from Container (@pxref{sys_Container_class_reference})
@item 40 members inherited from Element (@pxref{sys_Element_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Group(const math::vectorPair3 &p)
@item virtual ~Group()
@item virtual math::vectorPair3 get_bounding_box() const
@end itemize

@subheading Members detail

@subsubheading Group(const math::vectorPair3 &p)
@anchor{_1195}

Create a new group at given position

@subsubheading virtual ~Group()
@anchor{_1196}

No documentation available

@subsubheading virtual math::vectorPair3 get_bounding_box() const
@anchor{_1197}

This virtual function overrides the @code{get_bounding_box (@pxref{_1288})} virtual function defined in the @code{Element (@pxref{sys_Element_class_reference})} base class.

Documentation inherited from base class:

Get bounding box in local coordinates

@page

@heading sys::Group class full member list
@anchor{sys_Group_class_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } element_list_t
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item Group(const math::vectorPair3 &p)
@item virtual ~Group()
@item void add(const ref<Element> &e)
@item template bool contains(const X *x) const
@item void draw_2d(io::Renderer &r) const
@item void draw_2d_fit(io::renderer_viewport &r@comma{} bool keep_aspect = @emph{[...]}) const
@item void draw_3d(io::Renderer &r) const
@item void draw_3d_fit(io::renderer_viewport &r@comma{} double z_offset = @emph{[...]}) const
@item template void enable_single(const X &e)
@item template X * find() const
@item virtual math::vectorPair3 get_bounding_box() const
@item math::vector3 get_direction(const Element &e) const
@item math::vector3 get_direction() const
@item const Container::element_list_t & get_element_list() const
@item template void get_elements(const delegate<void(const X&)> &d) const
@item template void get_elements(const delegate<void(X&)> &d)
@item const math::Transform<3> & get_global_transform() const
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item Group * get_parent() const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const Element &e) const
@item math::vector3 get_position(const Element &e) const
@item math::vector3 get_position() const
@item system * get_system() const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const Element &e) const
@item const math::Transform<3> & get_transform_from(const Element *e) const
@item const math::Transform<3> & get_transform_to(const Element &e) const
@item const math::Transform<3> & get_transform_to(const Element *e) const
@item unsigned int get_version() const
@item unsigned int id() const
@item bool is_enabled() const
@item virtual void print(std::ostream &o) const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void remove(Element &e)
@item void rotate(double x@comma{} double y@comma{} double z)
@item void set_direction(const math::vector3 &v)
@item void set_enable_state(bool enabled)
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &v)
@item void set_transform(const math::Transform<3> &t)
@item void update_version()
@end itemize

@page

@heading sys::image class reference
@anchor{sys_image_class_reference}

@subheading Declaration

@example
#include <goptical/core/sys/image>

namespace goptical @{
  namespace sys @{
    class image;
  @};
@};

@end example

 This class is a member of the sys namespace.

@subheading Inheritance

@subheading Description
image plane optical element
@subheading Members

 See also the full member list (@pxref{sys_image_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 48 members inherited from Surface (@pxref{sys_Surface_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item image(const math::vectorPair3 &position@comma{} const const_ref<curve::Base> &curve@comma{} const const_ref<shape::Base> &shape)
@item image(const math::vectorPair3 &position@comma{} double radius)
@end itemize

@subheading Members detail

@subsubheading image(const math::vectorPair3 &position@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <curve::Base> &curve@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <shape::Base> &shape)
@anchor{_1198}

Create a new image plane at given position.

@subsubheading image(const math::vectorPair3 &position@comma{} double radius)
@anchor{_1199}

Create a new flat square image plane at given position with given half width

@page

@heading sys::image class full member list
@anchor{sys_image_class_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item image(const math::vectorPair3 &position@comma{} const const_ref<curve::Base> &curve@comma{} const const_ref<shape::Base> &shape)
@item image(const math::vectorPair3 &position@comma{} double radius)
@item virtual math::vectorPair3 get_bounding_box() const
@item virtual io::rgb get_color(const io::Renderer &r) const
@item const curve::Base & get_curve() const
@item math::vector3 get_direction(const Element &e) const
@item math::vector3 get_direction() const
@item double get_discard_intensity() const
@item const math::Transform<3> & get_global_transform() const
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item Group * get_parent() const
@item void get_pattern(const math::vector3::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed = @emph{[...]}) const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const Element &e) const
@item math::vector3 get_position(const Element &e) const
@item math::vector3 get_position() const
@item const shape::Base & get_shape() const
@item system * get_system() const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const Element &e) const
@item const math::Transform<3> & get_transform_from(const Element *e) const
@item const math::Transform<3> & get_transform_to(const Element &e) const
@item const math::Transform<3> & get_transform_to(const Element *e) const
@item unsigned int get_version() const
@item unsigned int id() const
@item virtual bool intersect(const trace::params &params@comma{} math::vectorPair3 &pt@comma{} const math::vectorPair3 &ray) const
@item bool is_enabled() const
@item virtual void print(std::ostream &o) const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void rotate(double x@comma{} double y@comma{} double z)
@item void set_curve(const const_ref<curve::Base> &c)
@item void set_direction(const math::vector3 &v)
@item void set_discard_intensity(double intensity)
@item void set_enable_state(bool enabled)
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &v)
@item void set_shape(const const_ref<shape::Base> &s)
@item void set_transform(const math::Transform<3> &t)
@item template void trace_ray(trace::Result &result@comma{} trace::Ray &incident@comma{} const math::vectorPair3 &local@comma{} const math::vectorPair3 &intersect) const
@item void update_version()
@end itemize

@page

@heading sys::Lens class reference
@anchor{sys_Lens_class_reference}

@subheading Declaration

@example
#include <goptical/core/sys/Lens>

namespace goptical @{
  namespace sys @{
    class Lens;
  @};
@};

@end example

 This class is a member of the sys namespace.

@subheading Inheritance

@subheading Description

This class is a group (@pxref{sys_Group_class_reference}) of optical surfaces (@pxref{sys_OpticalSurface_class_reference}). It contains functions to describe a lens or lens group component in a convenient way.

If material::none (@pxref{_528}) is passed as material@comma{} it will be replaced by system environement proxy (@pxref{material_Proxy_class_reference}) material when the optical surface becomes part of a system (@pxref{sys_system_class_reference}).

See also The Lens component (@pxref{The Lens component}) section.

@subheading Members

 See also the full member list (@pxref{sys_Lens_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 51 members inherited from Group (@pxref{sys_Group_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Lens(const math::vectorPair3 &p@comma{} double offset = @emph{[...]}@comma{} const const_ref<material::Base> &env = @emph{[...]})
@item Lens(const math::vectorPair3 &p@comma{} const const_ref<curve::Base> &curve0@comma{} const const_ref<shape::Base> &shape0@comma{} const const_ref<curve::Base> &curve1@comma{} const const_ref<shape::Base> &shape1@comma{} double thickness0@comma{} const const_ref<material::Base> &glass0@comma{} const const_ref<material::Base> &env = @emph{[...]})
@item Lens(const math::vectorPair3 &p@comma{} double roc0@comma{} double ap_radius0@comma{} double roc1@comma{} double ap_radius1@comma{} double thickness@comma{} const const_ref<material::Base> &glass0@comma{} const const_ref<material::Base> &env = @emph{[...]})
@item virtual ~Lens()
@item void add_stop(const const_ref<shape::Base> &shape@comma{} double thickness)
@item void add_stop(double ap_radius@comma{} double thickness)
@item unsigned int add_surface(const const_ref<curve::Base> &curve@comma{} const const_ref<shape::Base> &shape@comma{} double thickness = @emph{[...]}@comma{} const const_ref<material::Base> &glass = @emph{[...]})
@item unsigned int add_surface(double roc@comma{} double ap_radius@comma{} double thickness = @emph{[...]}@comma{} const const_ref<material::Base> &glass = @emph{[...]})
@item math::vectorPair3 get_exit_plane() const
@item const OpticalSurface & get_left_surface() const
@item OpticalSurface & get_left_surface()
@item const OpticalSurface & get_right_surface() const
@item OpticalSurface & get_right_surface()
@item const OpticalSurface & get_surface(unsigned int index) const
@item OpticalSurface & get_surface(unsigned int index)
@item double get_thickness(unsigned int index = @emph{[...]}) const
@item void set_curve(const const_ref<curve::Base> &c@comma{} unsigned int index)
@item void set_glass_material(const const_ref<material::Base> &m@comma{} unsigned int index = @emph{[...]})
@item void set_left_curve(const const_ref<curve::Base> &c)
@item void set_left_material(const const_ref<material::Base> &m)
@item void set_right_curve(const const_ref<curve::Base> &c)
@item void set_right_material(const const_ref<material::Base> &m)
@item void set_shape(const const_ref<shape::Base> &s)
@item void set_shape(const const_ref<shape::Base> &s@comma{} unsigned int index)
@item void set_thickness(double thickness@comma{} unsigned int index = @emph{[...]})
@end itemize

@subheading Members detail

@subsubheading Lens(const math::vectorPair3 &p@comma{} double offset = 0.@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &env = material::none)
@anchor{_1200}

Create an empty lens. Surfaces can be added with the add_surface (@pxref{_1206}) functions.

@subsubheading Lens(const math::vectorPair3 &p@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <curve::Base> &curve0@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <shape::Base> &shape0@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <curve::Base> &curve1@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <shape::Base> &shape1@comma{} double thickness0@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &glass0@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &env = material::none)
@anchor{_1201}

Create a lens at given position with given thickness@comma{} shapes@comma{} curvatures and glass. 

See also add_surface (@pxref{_1206}) function.

@subsubheading Lens(const math::vectorPair3 &p@comma{} double roc0@comma{} double ap_radius0@comma{} double roc1@comma{} double ap_radius1@comma{} double thickness@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &glass0@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &env = material::none)
@anchor{_1202}

Create a circular lens with flat or spherical surfaces at given position with given thickness@comma{} radius of curvature@comma{} aperture radius and glass. 

See also add_surface (@pxref{_1207}) function.

@subsubheading virtual ~Lens()
@anchor{_1203}

No documentation available

@subsubheading void add_stop(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <shape::Base> &shape@comma{} double thickness)
@anchor{_1204}

 Add an aperture stop with given@comma{} shape and thickness.

@subsubheading void add_stop(double ap_radius@comma{} double thickness)
@anchor{_1205}

 Add an aperture stop with circular aperture.

Parameters list:

@itemize
@item radius: circular aperture radius. 
@item thickness: distance to the next stop or exit plane. .
@end itemize

@subsubheading unsigned int add_surface(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <curve::Base> &curve@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <shape::Base> &shape@comma{} double thickness = 0.@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &glass = material::none)
@anchor{_1206}

 Add an optical surface with given curve@comma{} shape@comma{} thickness and material.

@subsubheading unsigned int add_surface(double roc@comma{} double ap_radius@comma{} double thickness = 0.@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &glass = material::none)
@anchor{_1207}

 Add a spherical or flat optical surface with circular aperture.

Parameters list:

@itemize
@item roc: spherical radius of curvature. 0 means flat curve. 
@item ap_radius: circular aperture radius. 
@item thickness: distance to the next surface or exit plane. . 
@item glass: material between added surface and next surface.
@end itemize

@subsubheading math::vectorPair3 get_exit_plane() const
@anchor{_1208}

Get plane of last surface + thickness z offset

@subsubheading const OpticalSurface & get_left_surface() const
@anchor{_1209}

Get a reference to left optical surface element

@subsubheading OpticalSurface & get_left_surface()
@anchor{_1210}

Get a reference to left optical surface element

@subsubheading const OpticalSurface & get_right_surface() const
@anchor{_1211}

Get a reference to right optical surface element

@subsubheading OpticalSurface & get_right_surface()
@anchor{_1212}

Get a reference to right optical surface element

@subsubheading const OpticalSurface & get_surface(unsigned int index) const
@anchor{_1213}

Get a reference to optical surface at given index

@subsubheading OpticalSurface & get_surface(unsigned int index)
@anchor{_1214}

Get a reference to optical surface at given index

@subsubheading double get_thickness(unsigned int index = 0) const
@anchor{_1215}

Get thickness between two surfaces

@subsubheading void set_curve(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <curve::Base> &c@comma{} unsigned int index)
@anchor{_1216}

Set curve of given surface index

@subsubheading void set_glass_material(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &m@comma{} unsigned int index = 0)
@anchor{_1217}

Set glass material

@subsubheading void set_left_curve(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <curve::Base> &c)
@anchor{_1218}

Set left curve

@subsubheading void set_left_material(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &m)
@anchor{_1219}

Set left material

@subsubheading void set_right_curve(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <curve::Base> &c)
@anchor{_1220}

Set right curve

@subsubheading void set_right_material(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &m)
@anchor{_1221}

Set left material

@subsubheading void set_shape(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <shape::Base> &s)
@anchor{_1222}

Set lens shape (all surfaces)

@subsubheading void set_shape(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <shape::Base> &s@comma{} unsigned int index)
@anchor{_1223}

Set lens shape of given surface index

@subsubheading void set_thickness(double thickness@comma{} unsigned int index = 0)
@anchor{_1224}

Adjust thickness between two surfaces

@page

@heading sys::Lens class full member list
@anchor{sys_Lens_class_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } element_list_t
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item Lens(const math::vectorPair3 &p@comma{} double offset = @emph{[...]}@comma{} const const_ref<material::Base> &env = @emph{[...]})
@item Lens(const math::vectorPair3 &p@comma{} const const_ref<curve::Base> &curve0@comma{} const const_ref<shape::Base> &shape0@comma{} const const_ref<curve::Base> &curve1@comma{} const const_ref<shape::Base> &shape1@comma{} double thickness0@comma{} const const_ref<material::Base> &glass0@comma{} const const_ref<material::Base> &env = @emph{[...]})
@item Lens(const math::vectorPair3 &p@comma{} double roc0@comma{} double ap_radius0@comma{} double roc1@comma{} double ap_radius1@comma{} double thickness@comma{} const const_ref<material::Base> &glass0@comma{} const const_ref<material::Base> &env = @emph{[...]})
@item virtual ~Lens()
@item void add_stop(const const_ref<shape::Base> &shape@comma{} double thickness)
@item void add_stop(double ap_radius@comma{} double thickness)
@item unsigned int add_surface(const const_ref<curve::Base> &curve@comma{} const const_ref<shape::Base> &shape@comma{} double thickness = @emph{[...]}@comma{} const const_ref<material::Base> &glass = @emph{[...]})
@item unsigned int add_surface(double roc@comma{} double ap_radius@comma{} double thickness = @emph{[...]}@comma{} const const_ref<material::Base> &glass = @emph{[...]})
@item template bool contains(const X *x) const
@item void draw_2d(io::Renderer &r) const
@item void draw_2d_fit(io::renderer_viewport &r@comma{} bool keep_aspect = @emph{[...]}) const
@item void draw_3d(io::Renderer &r) const
@item void draw_3d_fit(io::renderer_viewport &r@comma{} double z_offset = @emph{[...]}) const
@item template void enable_single(const X &e)
@item template X * find() const
@item virtual math::vectorPair3 get_bounding_box() const
@item math::vector3 get_direction(const Element &e) const
@item math::vector3 get_direction() const
@item const Container::element_list_t & get_element_list() const
@item template void get_elements(const delegate<void(const X&)> &d) const
@item template void get_elements(const delegate<void(X&)> &d)
@item math::vectorPair3 get_exit_plane() const
@item const math::Transform<3> & get_global_transform() const
@item const OpticalSurface & get_left_surface() const
@item OpticalSurface & get_left_surface()
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item Group * get_parent() const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const Element &e) const
@item math::vector3 get_position(const Element &e) const
@item math::vector3 get_position() const
@item const OpticalSurface & get_right_surface() const
@item OpticalSurface & get_right_surface()
@item const OpticalSurface & get_surface(unsigned int index) const
@item OpticalSurface & get_surface(unsigned int index)
@item system * get_system() const
@item double get_thickness(unsigned int index = @emph{[...]}) const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const Element &e) const
@item const math::Transform<3> & get_transform_from(const Element *e) const
@item const math::Transform<3> & get_transform_to(const Element &e) const
@item const math::Transform<3> & get_transform_to(const Element *e) const
@item unsigned int get_version() const
@item unsigned int id() const
@item bool is_enabled() const
@item virtual void print(std::ostream &o) const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void rotate(double x@comma{} double y@comma{} double z)
@item void set_curve(const const_ref<curve::Base> &c@comma{} unsigned int index)
@item void set_direction(const math::vector3 &v)
@item void set_enable_state(bool enabled)
@item void set_glass_material(const const_ref<material::Base> &m@comma{} unsigned int index = @emph{[...]})
@item void set_left_curve(const const_ref<curve::Base> &c)
@item void set_left_material(const const_ref<material::Base> &m)
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &v)
@item void set_right_curve(const const_ref<curve::Base> &c)
@item void set_right_material(const const_ref<material::Base> &m)
@item void set_shape(const const_ref<shape::Base> &s)
@item void set_shape(const const_ref<shape::Base> &s@comma{} unsigned int index)
@item void set_thickness(double thickness@comma{} unsigned int index = @emph{[...]})
@item void set_transform(const math::Transform<3> &t)
@item void update_version()
@end itemize

@page

@heading sys::mirror class reference
@anchor{sys_mirror_class_reference}

@subheading Declaration

@example
#include <goptical/core/sys/mirror>

namespace goptical @{
  namespace sys @{
    class mirror;
  @};
@};

@end example

 This class is a member of the sys namespace.

@subheading Inheritance

@subheading Description

This class provide a convenient way to describe a reflecting optical surface. light is reflected only on 1 side of the surface.

@subheading Members

 See also the full member list (@pxref{sys_mirror_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 51 members inherited from OpticalSurface (@pxref{sys_OpticalSurface_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item mirror(const math::vectorPair3 &p@comma{} const const_ref<curve::Base> &curve@comma{} const const_ref<shape::Base> &shape@comma{} bool light_from_left = @emph{[...]}@comma{} const const_ref<material::Base> &metal = @emph{[...]}@comma{} const const_ref<material::Base> &env = @emph{[...]})
@item mirror(const math::vectorPair3 &p@comma{} const const_ref<curve::Base> &curve@comma{} double ap_radius@comma{} bool light_from_left = @emph{[...]}@comma{} const const_ref<material::Base> &metal = @emph{[...]}@comma{} const const_ref<material::Base> &env = @emph{[...]})
@item mirror(const math::vectorPair3 &p@comma{} double roc@comma{} double sc@comma{} double ap_radius@comma{} bool light_from_left = @emph{[...]}@comma{} const const_ref<material::Base> &metal = @emph{[...]}@comma{} const const_ref<material::Base> &env = @emph{[...]})
@end itemize

@subheading Members detail

@subsubheading mirror(const math::vectorPair3 &p@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <curve::Base> &curve@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <shape::Base> &shape@comma{} bool light_from_left = true@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &metal = material::mirror@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &env = material::none)
@anchor{_1225}

Create a mirror at given position with given shape and curve. Default is to reflect light coming from left using material::mirror (@pxref{_527}) material.

@subsubheading mirror(const math::vectorPair3 &p@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <curve::Base> &curve@comma{} double ap_radius@comma{} bool light_from_left = true@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &metal = material::mirror@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &env = material::none)
@anchor{_1226}

Create a circular aperture mirror at given position with given curve. Default is to reflect light coming from left using material::mirror (@pxref{_527}) material.

@subsubheading mirror(const math::vectorPair3 &p@comma{} double roc@comma{} double sc@comma{} double ap_radius@comma{} bool light_from_left = true@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &metal = material::mirror@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &env = material::none)
@anchor{_1227}

Create a conic mirror with circular aperture at given position. Default is to reflect light coming from left using material::mirror (@pxref{_527}) material.

@page

@heading sys::mirror class full member list
@anchor{sys_mirror_class_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item mirror(const math::vectorPair3 &p@comma{} const const_ref<curve::Base> &curve@comma{} const const_ref<shape::Base> &shape@comma{} bool light_from_left = @emph{[...]}@comma{} const const_ref<material::Base> &metal = @emph{[...]}@comma{} const const_ref<material::Base> &env = @emph{[...]})
@item mirror(const math::vectorPair3 &p@comma{} const const_ref<curve::Base> &curve@comma{} double ap_radius@comma{} bool light_from_left = @emph{[...]}@comma{} const const_ref<material::Base> &metal = @emph{[...]}@comma{} const const_ref<material::Base> &env = @emph{[...]})
@item mirror(const math::vectorPair3 &p@comma{} double roc@comma{} double sc@comma{} double ap_radius@comma{} bool light_from_left = @emph{[...]}@comma{} const const_ref<material::Base> &metal = @emph{[...]}@comma{} const const_ref<material::Base> &env = @emph{[...]})
@item virtual math::vectorPair3 get_bounding_box() const
@item virtual io::rgb get_color(const io::Renderer &r) const
@item const curve::Base & get_curve() const
@item math::vector3 get_direction(const Element &e) const
@item math::vector3 get_direction() const
@item double get_discard_intensity() const
@item const math::Transform<3> & get_global_transform() const
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item const material::Base & get_material(unsigned int id) const
@item Group * get_parent() const
@item void get_pattern(const math::vector3::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed = @emph{[...]}) const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const Element &e) const
@item math::vector3 get_position(const Element &e) const
@item math::vector3 get_position() const
@item const shape::Base & get_shape() const
@item system * get_system() const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const Element &e) const
@item const math::Transform<3> & get_transform_from(const Element *e) const
@item const math::Transform<3> & get_transform_to(const Element &e) const
@item const math::Transform<3> & get_transform_to(const Element *e) const
@item unsigned int get_version() const
@item unsigned int id() const
@item virtual bool intersect(const trace::params &params@comma{} math::vectorPair3 &pt@comma{} const math::vectorPair3 &ray) const
@item bool is_enabled() const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void rotate(double x@comma{} double y@comma{} double z)
@item void set_curve(const const_ref<curve::Base> &c)
@item void set_direction(const math::vector3 &v)
@item void set_discard_intensity(double intensity)
@item void set_enable_state(bool enabled)
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_material(unsigned int index@comma{} const const_ref<material::Base> &m)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &v)
@item void set_shape(const const_ref<shape::Base> &s)
@item void set_transform(const math::Transform<3> &t)
@item template void trace_ray(trace::Result &result@comma{} trace::Ray &incident@comma{} const math::vectorPair3 &local@comma{} const math::vectorPair3 &intersect) const
@item void update_version()
@end itemize

@page

@heading sys::OpticalSurface class reference
@anchor{sys_OpticalSurface_class_reference}

@subheading Declaration

@example
#include <goptical/core/sys/OpticalSurface>

namespace goptical @{
  namespace sys @{
    class OpticalSurface;
  @};
@};

@end example

 This class is a member of the sys namespace.

@subheading Inheritance

@subheading Description

This class implements optical surfaces.

Optical surfaces are defined by material on both side of the surface@comma{} curve and contour shape. This class handle light rays refraction and reflection.

If material::none (@pxref{_528}) is passed as material@comma{} it will be replaced by system environement proxy (@pxref{material_Proxy_class_reference}) material when the optical surface becomes part of a system (@pxref{sys_system_class_reference}).

@subheading Members

 See also the full member list (@pxref{sys_OpticalSurface_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 48 members inherited from Surface (@pxref{sys_Surface_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item OpticalSurface(const math::vectorPair3 &p@comma{} const const_ref<curve::Base> &curve@comma{} const const_ref<shape::Base> &shape@comma{} const const_ref<material::Base> &left@comma{} const const_ref<material::Base> &right)
@item OpticalSurface(const math::vectorPair3 &p@comma{} const const_ref<curve::Base> &curve@comma{} double ap_radius@comma{} const const_ref<material::Base> &left@comma{} const const_ref<material::Base> &right)
@item OpticalSurface(const math::vectorPair3 &p@comma{} double roc@comma{} double ap_radius@comma{} const const_ref<material::Base> &left@comma{} const const_ref<material::Base> &right)
@item virtual ~OpticalSurface()
@item virtual io::rgb get_color(const io::Renderer &r) const
@item const material::Base & get_material(unsigned int id) const
@item void set_material(unsigned int index@comma{} const const_ref<material::Base> &m)
@end itemize

@subheading Members detail

@subsubheading OpticalSurface(const math::vectorPair3 &p@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <curve::Base> &curve@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <shape::Base> &shape@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &left@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &right)
@anchor{_1228}

Create an optical surface at specified location.

@subsubheading OpticalSurface(const math::vectorPair3 &p@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <curve::Base> &curve@comma{} double ap_radius@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &left@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &right)
@anchor{_1229}

Create a circular aperture optical surface at specified location. 

@itemize
@item ap_radius: circular aperture radius.
@end itemize

@subsubheading OpticalSurface(const math::vectorPair3 &p@comma{} double roc@comma{} double ap_radius@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &left@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &right)
@anchor{_1230}

Create a spherical optical surface with circular aperture at specified location. 

@itemize
@item roc: spherical radius of curvature. 0 means flat curve. 
@item ap_radius: circular aperture radius.
@end itemize

@subsubheading virtual ~OpticalSurface()
@anchor{_1231}

No documentation available

@subsubheading virtual io::rgb get_color(const io::Renderer &r) const
@anchor{_1232}

This virtual function overrides the @code{get_color (@pxref{_1343})} virtual function defined in the @code{Surface (@pxref{sys_Surface_class_reference})} base class.

Get surface natural color from material properties.

@subsubheading const material::Base & get_material(unsigned int id) const
@anchor{_1233}

Get surface left or right material

@subsubheading void set_material(unsigned int index@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &m)
@anchor{_1234}

Set surface left or right material

@page

@heading sys::OpticalSurface class full member list
@anchor{sys_OpticalSurface_class_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item OpticalSurface(const math::vectorPair3 &p@comma{} const const_ref<curve::Base> &curve@comma{} const const_ref<shape::Base> &shape@comma{} const const_ref<material::Base> &left@comma{} const const_ref<material::Base> &right)
@item OpticalSurface(const math::vectorPair3 &p@comma{} const const_ref<curve::Base> &curve@comma{} double ap_radius@comma{} const const_ref<material::Base> &left@comma{} const const_ref<material::Base> &right)
@item OpticalSurface(const math::vectorPair3 &p@comma{} double roc@comma{} double ap_radius@comma{} const const_ref<material::Base> &left@comma{} const const_ref<material::Base> &right)
@item virtual ~OpticalSurface()
@item virtual math::vectorPair3 get_bounding_box() const
@item virtual io::rgb get_color(const io::Renderer &r) const
@item const curve::Base & get_curve() const
@item math::vector3 get_direction(const Element &e) const
@item math::vector3 get_direction() const
@item double get_discard_intensity() const
@item const math::Transform<3> & get_global_transform() const
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item const material::Base & get_material(unsigned int id) const
@item Group * get_parent() const
@item void get_pattern(const math::vector3::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed = @emph{[...]}) const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const Element &e) const
@item math::vector3 get_position(const Element &e) const
@item math::vector3 get_position() const
@item const shape::Base & get_shape() const
@item system * get_system() const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const Element &e) const
@item const math::Transform<3> & get_transform_from(const Element *e) const
@item const math::Transform<3> & get_transform_to(const Element &e) const
@item const math::Transform<3> & get_transform_to(const Element *e) const
@item unsigned int get_version() const
@item unsigned int id() const
@item virtual bool intersect(const trace::params &params@comma{} math::vectorPair3 &pt@comma{} const math::vectorPair3 &ray) const
@item bool is_enabled() const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void rotate(double x@comma{} double y@comma{} double z)
@item void set_curve(const const_ref<curve::Base> &c)
@item void set_direction(const math::vector3 &v)
@item void set_discard_intensity(double intensity)
@item void set_enable_state(bool enabled)
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_material(unsigned int index@comma{} const const_ref<material::Base> &m)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &v)
@item void set_shape(const const_ref<shape::Base> &s)
@item void set_transform(const math::Transform<3> &t)
@item template void trace_ray(trace::Result &result@comma{} trace::Ray &incident@comma{} const math::vectorPair3 &local@comma{} const math::vectorPair3 &intersect) const
@item void update_version()
@end itemize

@page

@heading sys::source_point class reference
@anchor{sys_source_point_class_reference}

@subheading Declaration

@example
#include <goptical/core/sys/source_point>

namespace goptical @{
  namespace sys @{
    class source_point;
  @};
@};

@end example

 This class is a member of the sys namespace.

@subheading Inheritance

@subheading Description

This class implement a point light source. The source can either be infinitely far away with a direction vector@comma{} or located at a given position but without direction.

A ray is generated for each defined spectrum line for each distribution pattern point on target surface.

Default wavelen list contains a single 550nm entry.

@subheading Members

 See also the full member list (@pxref{sys_source_point_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 48 members inherited from Source (@pxref{sys_Source_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item source_point(SourceInfinityMode m@comma{} const math::vector3 &pos_dir)
@item void set_infinity_direction(const math::vector3 &dir)
@item void set_mode(SourceInfinityMode mode)
@item void set_position(const math::vector3 &pos)
@end itemize

@subheading Members detail

@subsubheading source_point(SourceInfinityMode m@comma{} const math::vector3 &pos_dir)
@anchor{_1235}

Create a point source with given mode. A direction vector must be provided when source is in infinity mode. If not in infinity mode@comma{} a position vector must be provided instead.

@subsubheading void set_infinity_direction(const math::vector3 &dir)
@anchor{_1236}

Set point source mode to infinity and adjust source direction vector

@subsubheading void set_mode(SourceInfinityMode mode)
@anchor{_1237}

Change current point source infinity mode

@subsubheading void set_position(const math::vector3 &pos)
@anchor{_1238}

This function shadows the @code{set_position (@pxref{_1321})} function defined in the @code{Element (@pxref{sys_Element_class_reference})} base class.

Set point source mode to positioned and adjust source position vector

@page

@heading sys::source_point class full member list
@anchor{sys_source_point_class_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@item typedef @emph{ [...] } targets_t
@end itemize

@subheading Functions

@itemize
@item source_point(SourceInfinityMode m@comma{} const math::vector3 &pos_dir)
@item void add_spectral_line(const light::SpectralLine &l)
@item void clear_spectrum()
@item virtual void draw_2d_e(io::Renderer &r@comma{} const Element *ref) const
@item virtual void draw_3d_e(io::Renderer &r@comma{} const Element *ref) const
@item template void generate_rays(trace::Result &result@comma{} const Source::targets_t &entry) const
@item virtual math::vectorPair3 get_bounding_box() const
@item math::vector3 get_direction(const Element &e) const
@item math::vector3 get_direction() const
@item const math::Transform<3> & get_global_transform() const
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item double get_max_intensity() const
@item double get_min_intensity() const
@item Group * get_parent() const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const Element &e) const
@item math::vector3 get_position(const Element &e) const
@item math::vector3 get_position() const
@item system * get_system() const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const Element &e) const
@item const math::Transform<3> & get_transform_from(const Element *e) const
@item const math::Transform<3> & get_transform_to(const Element &e) const
@item const math::Transform<3> & get_transform_to(const Element *e) const
@item unsigned int get_version() const
@item unsigned int id() const
@item bool is_enabled() const
@item virtual void print(std::ostream &o) const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void rotate(double x@comma{} double y@comma{} double z)
@item void set_direction(const math::vector3 &v)
@item void set_enable_state(bool enabled)
@item void set_infinity_direction(const math::vector3 &dir)
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_material(const const_ref<material::Base> &m)
@item void set_mode(SourceInfinityMode mode)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &pos)
@item void set_spectral_line(const light::SpectralLine &l@comma{} int index = @emph{[...]})
@item void set_transform(const math::Transform<3> &t)
@item void single_spectral_line(const light::SpectralLine &l)
@item void update_version()
@end itemize

@page

@heading sys::SourceRays class reference
@anchor{sys_SourceRays_class_reference}

@subheading Declaration

@example
#include <goptical/core/sys/SourceRays>

namespace goptical @{
  namespace sys @{
    class SourceRays;
  @};
@};

@end example

 This class is a member of the sys namespace.

@subheading Inheritance

@subheading Description

This class implement a light source which generates user defined rays.

Default wavelen list contains a single 550nm entry.

@subheading Members

 See also the full member list (@pxref{sys_SourceRays_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 48 members inherited from Source (@pxref{sys_Source_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item SourceRays(const math::vector3 &object = @emph{[...]})
@item void add_chief_rays(const system &sys)
@item void add_chief_rays(const Surface &s)
@item void add_marginal_rays(const system &sys@comma{} double entrance_height = @emph{[...]})
@item void add_marginal_rays(const Surface &s@comma{} double entrance_height = @emph{[...]})
@item void add_ray(const light::Ray &ray@comma{} const Element *ref = @emph{[...]})
@item void add_rays(const math::vectorPair3 &ray@comma{} const Element *ref = @emph{[...]})
@item void clear_rays()
@end itemize

@subheading Members detail

@subsubheading SourceRays(const math::vector3 &object = math::vector3_0)
@anchor{_1239}

Create a rays source. Source object position is used by some of the @samp{add_*} functions and may be specified.

@subsubheading void add_chief_rays(const system &sys)
@anchor{_1240}

Add chief rays to system entrance pupil for all defined wavelengths.

@subsubheading void add_chief_rays(const Surface &s)
@anchor{_1241}

Add chief rays to specified surface for all defined wavelengths.

@subsubheading void add_marginal_rays(const system &sys@comma{} double entrance_height = 0.)
@anchor{_1242}

Add marginal rays to system entrance pupil for all defined wavelengths. 

See also add_marginal_rays (@pxref{_1243}) function.

@subsubheading void add_marginal_rays(const Surface &s@comma{} double entrance_height = 0.)
@anchor{_1243}

Add marginal rays to specified surface for all defined wavelengths.

Source direction (rotation) is used to determine tangential plane.

Entrance height is set to surface aperture radius when 0.

@subsubheading void add_ray(const light::Ray &ray@comma{} const Element *ref = 0)
@anchor{_1244}

Add a single light ray; rays properties are copied from specified light ray. 

Ray origin and direction are expressed in specified @samp{ref} element coordinates or global coordinates if none is specified.

@subsubheading void add_rays(const math::vectorPair3 &ray@comma{} const Element *ref = 0)
@anchor{_1245}

Creates light rays from position and direction for all defined wavelengths. 

Ray origin and direction are expressed in specified @samp{ref} element coordinates or global coordinates if none is specified.

@subsubheading void clear_rays()
@anchor{_1246}

Discard all defined rays

@page

@heading sys::SourceRays class full member list
@anchor{sys_SourceRays_class_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@item typedef @emph{ [...] } targets_t
@end itemize

@subheading Functions

@itemize
@item SourceRays(const math::vector3 &object = @emph{[...]})
@item void add_chief_rays(const system &sys)
@item void add_chief_rays(const Surface &s)
@item void add_marginal_rays(const system &sys@comma{} double entrance_height = @emph{[...]})
@item void add_marginal_rays(const Surface &s@comma{} double entrance_height = @emph{[...]})
@item void add_ray(const light::Ray &ray@comma{} const Element *ref = @emph{[...]})
@item void add_rays(const math::vectorPair3 &ray@comma{} const Element *ref = @emph{[...]})
@item void add_spectral_line(const light::SpectralLine &l)
@item void clear_rays()
@item void clear_spectrum()
@item virtual void draw_2d_e(io::Renderer &r@comma{} const Element *ref) const
@item virtual void draw_3d_e(io::Renderer &r@comma{} const Element *ref) const
@item template void generate_rays(trace::Result &result@comma{} const Source::targets_t &entry) const
@item virtual math::vectorPair3 get_bounding_box() const
@item math::vector3 get_direction(const Element &e) const
@item math::vector3 get_direction() const
@item const math::Transform<3> & get_global_transform() const
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item double get_max_intensity() const
@item double get_min_intensity() const
@item Group * get_parent() const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const Element &e) const
@item math::vector3 get_position(const Element &e) const
@item math::vector3 get_position() const
@item system * get_system() const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const Element &e) const
@item const math::Transform<3> & get_transform_from(const Element *e) const
@item const math::Transform<3> & get_transform_to(const Element &e) const
@item const math::Transform<3> & get_transform_to(const Element *e) const
@item unsigned int get_version() const
@item unsigned int id() const
@item bool is_enabled() const
@item virtual void print(std::ostream &o) const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void rotate(double x@comma{} double y@comma{} double z)
@item void set_direction(const math::vector3 &v)
@item void set_enable_state(bool enabled)
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_material(const const_ref<material::Base> &m)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &v)
@item void set_spectral_line(const light::SpectralLine &l@comma{} int index = @emph{[...]})
@item void set_transform(const math::Transform<3> &t)
@item void single_spectral_line(const light::SpectralLine &l)
@item void update_version()
@end itemize

@page

@heading sys::system class reference
@anchor{sys_system_class_reference}

@subheading Declaration

@example
#include <goptical/core/sys/system>

namespace goptical @{
  namespace sys @{
    class system;
  @};
@};

@end example

 This class is a member of the sys namespace.

@subheading Inheritance

@subheading Description

This class is used to describe an optical system. Any optical element (@pxref{sys_Element_class_reference}) may be part of a system. This class handle 3d transformation between elements local coordinates.

See also Building the optical system (@pxref{Building the optical system}) section.

@subheading Members

 See also the full member list (@pxref{sys_system_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 16 members inherited from Container (@pxref{sys_Container_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item system()
@item virtual ~system()
@item Surface * colide_next(const trace::params &params@comma{} math::vectorPair3 &intersect@comma{} const trace::Ray &ray) const
@item Element & get_element(unsigned int index) const
@item unsigned int get_element_count() const
@item const Surface & get_entrance_pupil() const
@item const material::Base & get_environment() const
@item const Surface & get_exit_pupil() const
@item const math::Transform<3> & get_global_transform(const Element &from) const
@item const math::Transform<3> & get_local_transform(const Element &to) const
@item const trace::params & get_tracer_params() const
@item trace::params & get_tracer_params()
@item const math::Transform<3> & get_transform(const Element &from@comma{} const Element &to) const
@item unsigned int get_version() const
@item bool has_entrance_pupil() const
@item bool has_exit_pupil() const
@item void set_entrance_pupil(const const_ref<Surface> &entrance)
@item void set_environment(const const_ref<material::Base> &env)
@item void set_exit_pupil(const const_ref<Surface> &exit)
@item void undef_entrance_pupil()
@item void update_version()
@end itemize

@subheading Members detail

@subsubheading system()
@anchor{_1247}

Create a new empty system.

@subsubheading virtual ~system()
@anchor{_1248}

No documentation available

@subsubheading Surface * colide_next(const trace::params &params@comma{} math::vectorPair3 &intersect@comma{} const trace::Ray &ray) const
@anchor{_1249}

Find surface which colides with the given ray and update intersection point

@subsubheading Element & get_element(unsigned int index) const
@anchor{_1250}

Get registered element. first element has index 1

@subsubheading unsigned int get_element_count() const
@anchor{_1251}

Get the number of registered elements in the system

@subsubheading const Surface & get_entrance_pupil() const
@anchor{_1252}

Get defined entrance pupil surface or try to guess it if none defined

@subsubheading const material::Base & get_environment() const
@anchor{_1253}

get environment material

@subsubheading const Surface & get_exit_pupil() const
@anchor{_1254}

Get exit pupil

@subsubheading const math::Transform<3> & get_global_transform(const Element &from) const
@anchor{_1255}

Get transform from element local to global coordinates

@subsubheading const math::Transform<3> & get_local_transform(const Element &to) const
@anchor{_1256}

Get transform from global to element local coordinates

@subsubheading const trace::params & get_tracer_params() const
@anchor{_1257}

Get default tracer parameters

@subsubheading trace::params & get_tracer_params()
@anchor{_1258}

Get default tracer parameters

@subsubheading const math::Transform<3> & get_transform(const Element &from@comma{} const Element &to) const
@anchor{_1259}

Get transform between two elements local coordinates

@subsubheading unsigned int get_version() const
@anchor{_1260}

Get system version. version is updated each time system or associated elements properties are changed

@subsubheading bool has_entrance_pupil() const
@anchor{_1261}

Test if an entrance pupil has been defined

@subsubheading bool has_exit_pupil() const
@anchor{_1262}

Test if an exit pupil has been defined

@subsubheading void set_entrance_pupil(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <Surface> &entrance)
@anchor{_1263}

Define an entrance pupil surface used to project source rays

@subsubheading void set_environment(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &env)
@anchor{_1264}

set environment material

@subsubheading void set_exit_pupil(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <Surface> &exit)
@anchor{_1265}

Define an exit pupil surface

@subsubheading void undef_entrance_pupil()
@anchor{_1266}

Discard defined entrance pupil

@subsubheading void update_version()
@anchor{_1267}

Increase current system version

@page

@heading sys::system class full member list
@anchor{sys_system_class_full_member_list}

@subheading Type

@itemize
@item typedef @emph{ [...] } element_list_t
@end itemize

@subheading Functions

@itemize
@item system()
@item virtual ~system()
@item void add(const ref<Element> &e)
@item Surface * colide_next(const trace::params &params@comma{} math::vectorPair3 &intersect@comma{} const trace::Ray &ray) const
@item template bool contains(const X *x) const
@item void draw_2d(io::Renderer &r) const
@item void draw_2d_fit(io::renderer_viewport &r@comma{} bool keep_aspect = @emph{[...]}) const
@item void draw_3d(io::Renderer &r) const
@item void draw_3d_fit(io::renderer_viewport &r@comma{} double z_offset = @emph{[...]}) const
@item template void enable_single(const X &e)
@item template X * find() const
@item math::vectorPair3 get_bounding_box() const
@item Element & get_element(unsigned int index) const
@item unsigned int get_element_count() const
@item const Container::element_list_t & get_element_list() const
@item template void get_elements(const delegate<void(const X&)> &d) const
@item template void get_elements(const delegate<void(X&)> &d)
@item const Surface & get_entrance_pupil() const
@item const material::Base & get_environment() const
@item const Surface & get_exit_pupil() const
@item const math::Transform<3> & get_global_transform(const Element &from) const
@item const math::Transform<3> & get_local_transform(const Element &to) const
@item const trace::params & get_tracer_params() const
@item trace::params & get_tracer_params()
@item const math::Transform<3> & get_transform(const Element &from@comma{} const Element &to) const
@item unsigned int get_version() const
@item bool has_entrance_pupil() const
@item bool has_exit_pupil() const
@item void remove(Element &e)
@item void set_entrance_pupil(const const_ref<Surface> &entrance)
@item void set_environment(const const_ref<material::Base> &env)
@item void set_exit_pupil(const const_ref<Surface> &exit)
@item void undef_entrance_pupil()
@item void update_version()
@end itemize

@page

@heading sys::Container class reference
@anchor{sys_Container_class_reference}

@subheading Declaration

@example
#include <goptical/core/sys/Container>

namespace goptical @{
  namespace sys @{
    class Container;
  @};
@};

@end example

 This class is a member of the sys namespace.

This abstract class contains pure virtuals.

@subheading Inheritance

@subheading Description

This class base contains optical elements membership management code. It's used as a base class for system (@pxref{sys_system_class_reference}) and Group (@pxref{sys_Group_class_reference}) classes.

@subheading Members

 See also the full member list (@pxref{sys_Container_class_full_member_list}) section for this class.

@subsubheading Type

@itemize
@item typedef @emph{ [...] } element_list_t
@end itemize

@subsubheading Functions

@itemize
@item Container()
@item virtual ~Container()
@item void add(const ref<Element> &e)
@item template bool contains(const X *x) const
@item void draw_2d(io::Renderer &r) const
@item void draw_2d_fit(io::renderer_viewport &r@comma{} bool keep_aspect = @emph{[...]}) const
@item void draw_3d(io::Renderer &r) const
@item void draw_3d_fit(io::renderer_viewport &r@comma{} double z_offset = @emph{[...]}) const
@item template void enable_single(const X &e)
@item template X * find() const
@item math::vectorPair3 get_bounding_box() const
@item const element_list_t & get_element_list() const
@item template void get_elements(const delegate<void(const X&)> &d) const
@item template void get_elements(const delegate<void(X&)> &d)
@item void remove(Element &e)
@end itemize

@subheading Members detail

@subsubheading Container()
@anchor{_1268}

No documentation available

@subsubheading virtual ~Container()
@anchor{_1269}

No documentation available

@subsubheading void add(const  @uref{http://diaxen.ssji.net/dpp/ref_class_reference.html,,ref} <Element> &e)
@anchor{_1270}

Add an element

@subsubheading template <typename X> bool contains(const X *x) const
@anchor{_1271}

Test if element is contained in container and subcontainers

@subsubheading void draw_2d(io::Renderer &r) const
@anchor{_1272}

Draw system 2d layout using specified renderer. 

See also draw_2d_fit (@pxref{_1273}) function.

@subsubheading void draw_2d_fit(io::renderer_viewport &r@comma{} bool keep_aspect = true) const
@anchor{_1273}

Setup the renderer 2d viewport to best fit for this system or element group. 

This function calls io::Renderer::set_window and io::Renderer::set_feature_size (@pxref{_369}).

@subsubheading void draw_3d(io::Renderer &r) const
@anchor{_1274}

Draw system in 3d using specified renderer. 

See also draw_3d_fit (@pxref{_1275}) function.

@subsubheading void draw_3d_fit(io::renderer_viewport &r@comma{} double z_offset = 0) const
@anchor{_1275}

Move the renderer 3d camera to best fit for this system or element group. 

This function calls io::renderer_viewport::set_camera_transform (@pxref{_466}) and io::Renderer::set_feature_size (@pxref{_369}). 

@subsubheading typedef std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01085.html,,list} <ref<Element> > element_list_t
@anchor{_1276}

No documentation available

@subsubheading template <typename X> void enable_single(const X &e)
@anchor{_1277}

Disable all elements of specified type which are not specified element

@subsubheading template <typename X> X * find() const
@anchor{_1278}

Find first element of type X in container and subcontainers

@subsubheading math::vectorPair3 get_bounding_box() const
@anchor{_1279}

Get system or element group bounding box

@subsubheading const element_list_t & get_element_list() const
@anchor{_1280}

Return a reference to container children list

@subsubheading template <typename X> void get_elements(const  @uref{http://diaxen.ssji.net/dpp/delegate_class_reference.html,,delegate} <void(const X&)> &d) const
@anchor{_1281}

Invoke a delegate for each element of type X in container and subcontainers

@subsubheading template <typename X> void get_elements(const  @uref{http://diaxen.ssji.net/dpp/delegate_class_reference.html,,delegate} <void(X&)> &d)
@anchor{_1282}

Invoke a modifier delegate for each element of type X in container and subcontainers

@subsubheading void remove(Element &e)
@anchor{_1283}

Remove an element

@page

@heading sys::Container class full member list
@anchor{sys_Container_class_full_member_list}

@subheading Type

@itemize
@item typedef @emph{ [...] } element_list_t
@end itemize

@subheading Functions

@itemize
@item Container()
@item virtual ~Container()
@item void add(const ref<Element> &e)
@item template bool contains(const X *x) const
@item void draw_2d(io::Renderer &r) const
@item void draw_2d_fit(io::renderer_viewport &r@comma{} bool keep_aspect = @emph{[...]}) const
@item void draw_3d(io::Renderer &r) const
@item void draw_3d_fit(io::renderer_viewport &r@comma{} double z_offset = @emph{[...]}) const
@item template void enable_single(const X &e)
@item template X * find() const
@item math::vectorPair3 get_bounding_box() const
@item const element_list_t & get_element_list() const
@item template void get_elements(const delegate<void(const X&)> &d) const
@item template void get_elements(const delegate<void(X&)> &d)
@item void remove(Element &e)
@end itemize

@page

@heading sys::Element class reference
@anchor{sys_Element_class_reference}

@subheading Declaration

@example
#include <goptical/core/sys/Element>

namespace goptical @{
  namespace sys @{
    class Element;
  @};
@};

@end example

 This class is a member of the sys namespace.

@subheading Inheritance

@subheading Description

This is the base class for all optical elements.

Instances of this class may be registered as members of the Container (@pxref{sys_Container_class_reference}) class. It handles element position and transform to parent coordinates.

This class has virtual functions which must be reimplemented to handle incoming rays.

@subheading Members

 See also the full member list (@pxref{sys_Element_class_full_member_list}) section for this class.

@subsubheading Types

@itemize
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subsubheading Functions

@itemize
@item Element(const math::vectorPair3 &plane)
@item virtual ~Element()
@item virtual void draw_2d_e(io::Renderer &r@comma{} const Element *ref) const
@item virtual void draw_3d_e(io::Renderer &r@comma{} const Element *ref) const
@item virtual math::vectorPair3 get_bounding_box() const
@item math::vector3 get_direction(const Element &e) const
@item math::vector3 get_direction() const
@item const math::Transform<3> & get_global_transform() const
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item Group * get_parent() const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const Element &e) const
@item math::vector3 get_position(const Element &e) const
@item math::vector3 get_position() const
@item system * get_system() const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const Element &e) const
@item const math::Transform<3> & get_transform_from(const Element *e) const
@item const math::Transform<3> & get_transform_to(const Element &e) const
@item const math::Transform<3> & get_transform_to(const Element *e) const
@item unsigned int get_version() const
@item unsigned int id() const
@item bool is_enabled() const
@item virtual void print(std::ostream &o) const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void rotate(double x@comma{} double y@comma{} double z)
@item void set_direction(const math::vector3 &v)
@item void set_enable_state(bool enabled)
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &v)
@item void set_transform(const math::Transform<3> &t)
@item void update_version()
@end itemize

@subheading Members detail

@subsubheading Element(const math::vectorPair3 &plane)
@anchor{_1284}

Create a new optical element with given position and direction in parent coordinates system.

@subsubheading virtual ~Element()
@anchor{_1285}

No documentation available

@subsubheading virtual void draw_2d_e(io::Renderer &r@comma{} const Element *ref) const
@anchor{_1286}

Draw element 2d layout using the given renderer in given element coordinates.

@subsubheading virtual void draw_3d_e(io::Renderer &r@comma{} const Element *ref) const
@anchor{_1287}

Draw element in 3d using the given renderer in given element coordinates

@subsubheading virtual math::vectorPair3 get_bounding_box() const
@anchor{_1288}

Get bounding box in local coordinates

@subsubheading math::vector3 get_direction(const Element &e) const
@anchor{_1289}

Get element direction in given element coordinate system

@subsubheading math::vector3 get_direction() const
@anchor{_1290}

Get element direction in system global coordinates

@subsubheading const math::Transform<3> & get_global_transform() const
@anchor{_1291}

Get transform from this element local to global coordinates

@subsubheading math::vector3 get_local_direction() const
@anchor{_1292}

Get element direction in parent coordinate system

@subsubheading math::vectorPair3 get_local_plane() const
@anchor{_1293}

Get reference plane (position and direction) in parent coordinate system 

See also get_local_direction (@pxref{_1292}) function and get_local_position (@pxref{_1294}) function.

@subsubheading const math::vector3 & get_local_position() const
@anchor{_1294}

Get element position in parent local coordinate system

@subsubheading const math::Transform<3> & get_local_transform() const
@anchor{_1295}

Get transform from global to this element local coordinates

@subsubheading Group * get_parent() const
@anchor{_1296}

Get a pointer to parent element@comma{} if any.

@subsubheading math::vectorPair3 get_plane() const
@anchor{_1297}

Get reference plane (position and direction) in system global coordinates

See also get_direction (@pxref{_1289}) function and get_position (@pxref{_1299}) function.

@subsubheading math::vectorPair3 get_plane(const Element &e) const
@anchor{_1298}

Get reference plane (position and direction) in given element coordinates

See also get_direction (@pxref{_1289}) function and get_position (@pxref{_1299}) function.

@subsubheading math::vector3 get_position(const Element &e) const
@anchor{_1299}

Get element position in given element coordinate system

@subsubheading math::vector3 get_position() const
@anchor{_1300}

Get element position in system global coordinate system

@subsubheading system * get_system() const
@anchor{_1301}

Get a pointer to system

@subsubheading const math::Transform<3> & get_transform() const
@anchor{_1302}

Get transform from this element to parent element coordinate system

@subsubheading const math::Transform<3> & get_transform_from(const Element &e) const
@anchor{_1303}

Get transform from given element to this element coordinate system

@subsubheading const math::Transform<3> & get_transform_from(const Element *e) const
@anchor{_1304}

Get transform from given element to this element coordinate system. Transform from global coordinates is returned if paramter is 0.

@subsubheading const math::Transform<3> & get_transform_to(const Element &e) const
@anchor{_1305}

Get transform from this element to given element coordinate system

@subsubheading const math::Transform<3> & get_transform_to(const Element *e) const
@anchor{_1306}

Get transform from this element to given element coordinate system. Transform to global coordinates is returned if paramter is 0.

@subsubheading unsigned int get_version() const
@anchor{_1307}

Get element version. version is updated each time element or its children properties are changed

@subsubheading unsigned int id() const
@anchor{_1308}

Get element identifer in current system

@subsubheading bool is_enabled() const
@anchor{_1309}

Return true if element must be considered

@subsubheading typedef  @uref{http://diaxen.ssji.net/dpp/delegate_class_reference.html,,delegate} <void(Element&)> mod_delegate_t
@anchor{_1310}

No documentation available

@subsubheading virtual void print(std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  &o) const
@anchor{_1311}

No documentation available

@subsubheading template <trace::IntensityMode m> void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@anchor{_1312}

Batch process a list of light rays interacting with element. This function is only used in sequential ray trace mode.

@subsubheading typedef  @uref{http://diaxen.ssji.net/dpp/delegate_class_reference.html,,delegate} <void(const Element&)> put_delegate_t
@anchor{_1313}

No documentation available

@subsubheading void rotate(double x@comma{} double y@comma{} double z)
@anchor{_1314}

Rotate element direction. angles are in degrees

@subsubheading void set_direction(const math::vector3 &v)
@anchor{_1315}

Set element direction in system global coordinates

@subsubheading void set_enable_state(bool enabled)
@anchor{_1316}

Set enable state

@subsubheading void set_local_direction(const math::vector3 &v)
@anchor{_1317}

Set element direction in parent coordinate system

@subsubheading void set_local_plane(const math::vectorPair3 &p)
@anchor{_1318}

Set reference plane (position and direction) in parent coordinate system

See also set_local_direction (@pxref{_1317}) function and set_local_position (@pxref{_1319}) function.

@subsubheading void set_local_position(const math::vector3 &v)
@anchor{_1319}

Set element position in parent local coordinate system

@subsubheading void set_plane(const math::vectorPair3 &p)
@anchor{_1320}

Set reference plane (position and direction) in system global coordinates

See also set_direction (@pxref{_1315}) function and set_position (@pxref{_1321}) function.

@subsubheading void set_position(const math::vector3 &v)
@anchor{_1321}

Set element position in system global coordinate system

@subsubheading void set_transform(const math::Transform<3> &t)
@anchor{_1322}

Set transform to parant coordinate system

@subsubheading void update_version()
@anchor{_1323}

Increase current element version

@page

@heading sys::Element class full member list
@anchor{sys_Element_class_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item Element(const math::vectorPair3 &plane)
@item virtual ~Element()
@item virtual void draw_2d_e(io::Renderer &r@comma{} const Element *ref) const
@item virtual void draw_3d_e(io::Renderer &r@comma{} const Element *ref) const
@item virtual math::vectorPair3 get_bounding_box() const
@item math::vector3 get_direction(const Element &e) const
@item math::vector3 get_direction() const
@item const math::Transform<3> & get_global_transform() const
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item Group * get_parent() const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const Element &e) const
@item math::vector3 get_position(const Element &e) const
@item math::vector3 get_position() const
@item system * get_system() const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const Element &e) const
@item const math::Transform<3> & get_transform_from(const Element *e) const
@item const math::Transform<3> & get_transform_to(const Element &e) const
@item const math::Transform<3> & get_transform_to(const Element *e) const
@item unsigned int get_version() const
@item unsigned int id() const
@item bool is_enabled() const
@item virtual void print(std::ostream &o) const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void rotate(double x@comma{} double y@comma{} double z)
@item void set_direction(const math::vector3 &v)
@item void set_enable_state(bool enabled)
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &v)
@item void set_transform(const math::Transform<3> &t)
@item void update_version()
@end itemize

@page

@heading sys::Source class reference
@anchor{sys_Source_class_reference}

@subheading Declaration

@example
#include <goptical/core/sys/Source>

namespace goptical @{
  namespace sys @{
    class Source;
  @};
@};

@end example

 This class is a member of the sys namespace.

@subheading Inheritance

@subheading Description

This class is the base class for all light sources implementations.

@subheading Members

 See also the full member list (@pxref{sys_Source_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 40 members inherited from Element (@pxref{sys_Element_class_reference})
@end itemize

@subsubheading Type

@itemize
@item typedef @emph{ [...] } targets_t
@end itemize

@subsubheading Functions

@itemize
@item Source(const math::vectorPair3 &position)
@item void add_spectral_line(const light::SpectralLine &l)
@item void clear_spectrum()
@item template void generate_rays(trace::Result &result@comma{} const targets_t &entry) const
@item double get_max_intensity() const
@item double get_min_intensity() const
@item void set_material(const const_ref<material::Base> &m)
@item void set_spectral_line(const light::SpectralLine &l@comma{} int index = @emph{[...]})
@item void single_spectral_line(const light::SpectralLine &l)
@end itemize

@subheading Members detail

@subsubheading Source(const math::vectorPair3 &position)
@anchor{_1324}

Create a source at given position.

@subsubheading void add_spectral_line(const light::SpectralLine &l)
@anchor{_1325}

Add a new wavelen for ray generation

@subsubheading void clear_spectrum()
@anchor{_1326}

Clear wavelen list

@subsubheading template <trace::IntensityMode m> void generate_rays(trace::Result &result@comma{} const targets_t &entry) const
@anchor{_1327}

Generate light rays from source

@subsubheading double get_max_intensity() const
@anchor{_1328}

Get maximal spectral line intensity

@subsubheading double get_min_intensity() const
@anchor{_1329}

Get minimal spectral line intensity

@subsubheading void set_material(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <material::Base> &m)
@anchor{_1330}

Set material where light rays are generated. system environment material is used by default.

@subsubheading void set_spectral_line(const light::SpectralLine &l@comma{} int index = 0)
@anchor{_1331}

Set a wavelen in list for ray generation

@subsubheading void single_spectral_line(const light::SpectralLine &l)
@anchor{_1332}

Clear ray wavelen list and set a single wavelen

@subsubheading typedef std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01318.html,,vector} <const sys::Element*> targets_t
@anchor{_1333}

No documentation available

@page

@heading sys::Source class full member list
@anchor{sys_Source_class_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@item typedef @emph{ [...] } targets_t
@end itemize

@subheading Functions

@itemize
@item Source(const math::vectorPair3 &position)
@item void add_spectral_line(const light::SpectralLine &l)
@item void clear_spectrum()
@item virtual void draw_2d_e(io::Renderer &r@comma{} const Element *ref) const
@item virtual void draw_3d_e(io::Renderer &r@comma{} const Element *ref) const
@item template void generate_rays(trace::Result &result@comma{} const targets_t &entry) const
@item virtual math::vectorPair3 get_bounding_box() const
@item math::vector3 get_direction(const Element &e) const
@item math::vector3 get_direction() const
@item const math::Transform<3> & get_global_transform() const
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item double get_max_intensity() const
@item double get_min_intensity() const
@item Group * get_parent() const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const Element &e) const
@item math::vector3 get_position(const Element &e) const
@item math::vector3 get_position() const
@item system * get_system() const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const Element &e) const
@item const math::Transform<3> & get_transform_from(const Element *e) const
@item const math::Transform<3> & get_transform_to(const Element &e) const
@item const math::Transform<3> & get_transform_to(const Element *e) const
@item unsigned int get_version() const
@item unsigned int id() const
@item bool is_enabled() const
@item virtual void print(std::ostream &o) const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void rotate(double x@comma{} double y@comma{} double z)
@item void set_direction(const math::vector3 &v)
@item void set_enable_state(bool enabled)
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_material(const const_ref<material::Base> &m)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &v)
@item void set_spectral_line(const light::SpectralLine &l@comma{} int index = @emph{[...]})
@item void set_transform(const math::Transform<3> &t)
@item void single_spectral_line(const light::SpectralLine &l)
@item void update_version()
@end itemize

@page

@heading sys::Stop class reference
@anchor{sys_Stop_class_reference}

@subheading Declaration

@example
#include <goptical/core/sys/Stop>

namespace goptical @{
  namespace sys @{
    class Stop;
  @};
@};

@end example

 This class is a member of the sys namespace.

@subheading Inheritance

@subheading Description

This class implements an aperture stop surface.

This surface will block all rays which fall outside the surface shape and inside the external radius. (All rays which pass at a distance from the axis greater than the external radius are not affected.)

Rays which fall inside the surface shape may either be intercepted and reemited or unaffected. Rays are always intercepted in sequential raytrace mode. In non-sequential mode this can be changed with set_intercept_reemit (@pxref{_1339}); default is disabled.

@subheading Members

 See also the full member list (@pxref{sys_Stop_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 48 members inherited from Surface (@pxref{sys_Surface_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Stop(const math::vectorPair3 &p@comma{} const const_ref<shape::Base> &shape)
@item Stop(const math::vectorPair3 &p@comma{} double radius)
@item double get_external_radius() const
@item bool get_intercept_reemit() const
@item void set_external_radius(double external_radius)
@item void set_intercept_reemit(bool intercept_reemit)
@end itemize

@subheading Members detail

@subsubheading Stop(const math::vectorPair3 &p@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <shape::Base> &shape)
@anchor{_1334}

Create an aperture stop surface. External radius is set to twice the shape max radius.

@subsubheading Stop(const math::vectorPair3 &p@comma{} double radius)
@anchor{_1335}

Create a circular aperture stop surface with given radius. External radius is set to twice the shape max radius.

@subsubheading double get_external_radius() const
@anchor{_1336}

 Get stop external radius. .

See also set_external_radius (@pxref{_1338}) function and Stop (@pxref{sys_Stop_class_reference}) class.

@subsubheading bool get_intercept_reemit() const
@anchor{_1337}

 Get intercept and reemit enabled. .

See also set_intercept_reemit (@pxref{_1339}) function and Stop (@pxref{sys_Stop_class_reference}) class.

@subsubheading void set_external_radius(double external_radius)
@anchor{_1338}

 Set stop external radius. .

See also get_external_radius (@pxref{_1336}) function and Stop (@pxref{sys_Stop_class_reference}) class.

@subsubheading void set_intercept_reemit(bool intercept_reemit)
@anchor{_1339}

 Set intercept and reemit enabled. .

See also get_intercept_reemit (@pxref{_1337}) function and Stop (@pxref{sys_Stop_class_reference}) class.

@page

@heading sys::Stop class full member list
@anchor{sys_Stop_class_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item Stop(const math::vectorPair3 &p@comma{} const const_ref<shape::Base> &shape)
@item Stop(const math::vectorPair3 &p@comma{} double radius)
@item virtual math::vectorPair3 get_bounding_box() const
@item virtual io::rgb get_color(const io::Renderer &r) const
@item const curve::Base & get_curve() const
@item math::vector3 get_direction(const Element &e) const
@item math::vector3 get_direction() const
@item double get_discard_intensity() const
@item double get_external_radius() const
@item const math::Transform<3> & get_global_transform() const
@item bool get_intercept_reemit() const
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item Group * get_parent() const
@item void get_pattern(const math::vector3::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed = @emph{[...]}) const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const Element &e) const
@item math::vector3 get_position(const Element &e) const
@item math::vector3 get_position() const
@item const shape::Base & get_shape() const
@item system * get_system() const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const Element &e) const
@item const math::Transform<3> & get_transform_from(const Element *e) const
@item const math::Transform<3> & get_transform_to(const Element &e) const
@item const math::Transform<3> & get_transform_to(const Element *e) const
@item unsigned int get_version() const
@item unsigned int id() const
@item bool is_enabled() const
@item virtual void print(std::ostream &o) const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void rotate(double x@comma{} double y@comma{} double z)
@item void set_curve(const const_ref<curve::Base> &c)
@item void set_direction(const math::vector3 &v)
@item void set_discard_intensity(double intensity)
@item void set_enable_state(bool enabled)
@item void set_external_radius(double external_radius)
@item void set_intercept_reemit(bool intercept_reemit)
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &v)
@item void set_shape(const const_ref<shape::Base> &s)
@item void set_transform(const math::Transform<3> &t)
@item template void trace_ray(trace::Result &result@comma{} trace::Ray &incident@comma{} const math::vectorPair3 &local@comma{} const math::vectorPair3 &intersect) const
@item void update_version()
@end itemize

@page

@heading sys::Surface class reference
@anchor{sys_Surface_class_reference}

@subheading Declaration

@example
#include <goptical/core/sys/Surface>

namespace goptical @{
  namespace sys @{
    class Surface;
  @};
@};

@end example

 This class is a member of the sys namespace.

@subheading Inheritance

@subheading Description

This is the base class for surface element. A surface element is defined by its position@comma{} surface curve and contour shape.

This class can handle incoming rays and is responsible for finding rays intersection with the surface.

Depending on ray trace intensity mode@comma{} it will potentially adjust light absorption and then call trace_ray_simple@comma{} trace_ray_intensity or trace_ray_polarized. These functions must be reimplemented in sub classes@comma{} default implementations will throw.

@subheading Members

 See also the full member list (@pxref{sys_Surface_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 40 members inherited from Element (@pxref{sys_Element_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Surface(const math::vectorPair3 &p@comma{} const const_ref<curve::Base> &curve@comma{} const const_ref<shape::Base> &shape)
@item virtual ~Surface()
@item virtual math::vectorPair3 get_bounding_box() const
@item virtual io::rgb get_color(const io::Renderer &r) const
@item const curve::Base & get_curve() const
@item double get_discard_intensity() const
@item void get_pattern(const math::vector3::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed = @emph{[...]}) const
@item const shape::Base & get_shape() const
@item virtual bool intersect(const trace::params &params@comma{} math::vectorPair3 &pt@comma{} const math::vectorPair3 &ray) const
@item void set_curve(const const_ref<curve::Base> &c)
@item void set_discard_intensity(double intensity)
@item void set_shape(const const_ref<shape::Base> &s)
@item template void trace_ray(trace::Result &result@comma{} trace::Ray &incident@comma{} const math::vectorPair3 &local@comma{} const math::vectorPair3 &intersect) const
@end itemize

@subheading Members detail

@subsubheading Surface(const math::vectorPair3 &p@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <curve::Base> &curve@comma{} const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <shape::Base> &shape)
@anchor{_1340}

Create a surface element at given location.

@subsubheading virtual ~Surface()
@anchor{_1341}

No documentation available

@subsubheading virtual math::vectorPair3 get_bounding_box() const
@anchor{_1342}

This virtual function overrides the @code{get_bounding_box (@pxref{_1288})} virtual function defined in the @code{Element (@pxref{sys_Element_class_reference})} base class.

Documentation inherited from base class:

Get bounding box in local coordinates

@subsubheading virtual io::rgb get_color(const io::Renderer &r) const
@anchor{_1343}

Get surface apparent color

@subsubheading const curve::Base & get_curve() const
@anchor{_1344}

Get surface curve

@subsubheading double get_discard_intensity() const
@anchor{_1345}

Get minimal ray intensity.

@subsubheading void get_pattern(const math::vector3::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed = false) const
@anchor{_1346}

Get distribution pattern points projected on the surface

@subsubheading const shape::Base & get_shape() const
@anchor{_1347}

Get surface shape

@subsubheading virtual bool intersect(const trace::params &params@comma{} math::vectorPair3 &pt@comma{} const math::vectorPair3 &ray) const
@anchor{_1348}

Get intersection point and normal to surface at intersection. Return false if no intersection occured.

@subsubheading void set_curve(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <curve::Base> &c)
@anchor{_1349}

Set surface curve

@subsubheading void set_discard_intensity(double intensity)
@anchor{_1350}

Set minimal ray intensity. Incident rays with less intensity will be discarded

@subsubheading void set_shape(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <shape::Base> &s)
@anchor{_1351}

Set surface shape

@subsubheading template <trace::IntensityMode m> void trace_ray(trace::Result &result@comma{} trace::Ray &incident@comma{} const math::vectorPair3 &local@comma{} const math::vectorPair3 &intersect) const
@anchor{_1352}

trace a single ray through the surface

@page

@heading sys::Surface class full member list
@anchor{sys_Surface_class_full_member_list}

@subheading Types

@itemize
@item typedef @emph{ [...] } mod_delegate_t
@item typedef @emph{ [...] } put_delegate_t
@end itemize

@subheading Functions

@itemize
@item Surface(const math::vectorPair3 &p@comma{} const const_ref<curve::Base> &curve@comma{} const const_ref<shape::Base> &shape)
@item virtual ~Surface()
@item virtual math::vectorPair3 get_bounding_box() const
@item virtual io::rgb get_color(const io::Renderer &r) const
@item const curve::Base & get_curve() const
@item math::vector3 get_direction(const Element &e) const
@item math::vector3 get_direction() const
@item double get_discard_intensity() const
@item const math::Transform<3> & get_global_transform() const
@item math::vector3 get_local_direction() const
@item math::vectorPair3 get_local_plane() const
@item const math::vector3 & get_local_position() const
@item const math::Transform<3> & get_local_transform() const
@item Group * get_parent() const
@item void get_pattern(const math::vector3::put_delegate_t &f@comma{} const trace::distribution &d@comma{} bool unobstructed = @emph{[...]}) const
@item math::vectorPair3 get_plane() const
@item math::vectorPair3 get_plane(const Element &e) const
@item math::vector3 get_position(const Element &e) const
@item math::vector3 get_position() const
@item const shape::Base & get_shape() const
@item system * get_system() const
@item const math::Transform<3> & get_transform() const
@item const math::Transform<3> & get_transform_from(const Element &e) const
@item const math::Transform<3> & get_transform_from(const Element *e) const
@item const math::Transform<3> & get_transform_to(const Element &e) const
@item const math::Transform<3> & get_transform_to(const Element *e) const
@item unsigned int get_version() const
@item unsigned int id() const
@item virtual bool intersect(const trace::params &params@comma{} math::vectorPair3 &pt@comma{} const math::vectorPair3 &ray) const
@item bool is_enabled() const
@item virtual void print(std::ostream &o) const
@item template void process_rays(trace::Result &result@comma{} trace::rays_queue_t *input) const
@item void rotate(double x@comma{} double y@comma{} double z)
@item void set_curve(const const_ref<curve::Base> &c)
@item void set_direction(const math::vector3 &v)
@item void set_discard_intensity(double intensity)
@item void set_enable_state(bool enabled)
@item void set_local_direction(const math::vector3 &v)
@item void set_local_plane(const math::vectorPair3 &p)
@item void set_local_position(const math::vector3 &v)
@item void set_plane(const math::vectorPair3 &p)
@item void set_position(const math::vector3 &v)
@item void set_shape(const const_ref<shape::Base> &s)
@item void set_transform(const math::Transform<3> &t)
@item template void trace_ray(trace::Result &result@comma{} trace::Ray &incident@comma{} const math::vectorPair3 &local@comma{} const math::vectorPair3 &intersect) const
@item void update_version()
@end itemize

@page

@heading trace namespace reference
@anchor{trace_namespace_reference}

@subheading Description
Ray tracer and light propagation
@subheading Members

@subsubheading Types

@itemize
@item class distribution
@item class params
@item class Result
@item class sequence
@item class tracer
@item enum IntensityMode
@item enum Pattern
@item class Ray
@item typedef @emph{ [...] } rays_queue_t
@end itemize

@subsubheading Function

@itemize
@item std::ostream & operator<<(std::ostream &o@comma{} const sequence &s)
@end itemize

@subheading Members detail

@subsubheading enum IntensityMode
@anchor{_1353}

Specifies light intensity calculation mode to use by light propagation algorithms.

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item Simpletrace @tab 
No Intensity calculation is performed

@item Intensitytrace @tab 
light intensity computation is performed without taking polarization into account

@item Polarizedtrace @tab 
 light intensity with polarization computation is performed (not supported yet)

@end multitable

@subsubheading enum Pattern
@anchor{_1354}

Specifies point distribution patterns over a shape delimited surface.

@image{dist_patterns,,,Different patterns rendered on a disk with default density}

@multitable @columnfractions 0.3 0.7
@headitem Identifier @tab Description
@item DefaultDist @tab 
Preferred distribution pattern for a given shape

@item SagittalDist @tab 
Sagittal plane distribution (along the X axis@comma{} X/Z plane)

@item MeridionalDist @tab 
Meridional plane distribution (along the Y axis@comma{} Y/Z plane)

@item TangentialDist @tab 
Tangential plane distribution@comma{} same as MeridionalDist (@pxref{_1354})

@item CrossDist @tab 
Sagittal and Meridional distribution combined

@item SquareDist @tab 
Square pattern distribution

@item TriangularDist @tab 
Triangular pattern distribution

@item HexaPolarDist @tab 
Hexapolar pattern@comma{} suitable for circular shapes

@item RandomDist @tab 
Random distribution

@end multitable

See also distribution (@pxref{trace_distribution_class_reference}) class.

@subsubheading std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  & operator<<(std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01708.html#ge83348f0f14ec5bf401ed2b962cb6491,,ostream}  &o@comma{} const sequence &s)
@anchor{_1355}

No documentation available

@subsubheading typedef std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a00918.html,,deque} <Ray*> rays_queue_t
@anchor{_1356}

No documentation available

@page

@heading trace::distribution class reference
@anchor{trace_distribution_class_reference}

@subheading Declaration

@example
#include <goptical/core/trace/distribution>

namespace goptical @{
  namespace trace @{
    class distribution;
  @};
@};

@end example

 This class is a member of the trace namespace.

@subheading Description

This class describes distribution pattern and ray density used for light ray distribution over surfaces during light propagation.

Ray density is expressed as average number of rays along surface radius.

@image{dist_patterns,,,Different patterns rendered on a disk with default density}

@subheading Members

 See also the full member list (@pxref{trace_distribution_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item distribution(Pattern pattern = @emph{[...]}@comma{} unsigned int radial_density = @emph{[...]}@comma{} double scaling = @emph{[...]})
@item Pattern get_pattern() const
@item unsigned int get_radial_density() const
@item double get_scaling() const
@item void set_pattern(Pattern p)
@item void set_radial_density(unsigned int count)
@item void set_scaling(double scaling)
@item void set_uniform_pattern()
@end itemize

@subheading Members detail

@subsubheading distribution(Pattern pattern = DefaultDist@comma{} unsigned int radial_density = 5@comma{} double scaling = 0.999)
@anchor{_1357}

Creates a distribution pattern with specified pattern@comma{} radial ray density and scaling.

The scaling ratio parameter may be used to avoid distributing rays too close to the surface edge.

@subsubheading Pattern get_pattern() const
@anchor{_1358}

Get distribution pattern

@subsubheading unsigned int get_radial_density() const
@anchor{_1359}

Get current radial density

@subsubheading double get_scaling() const
@anchor{_1360}

get current scaling

@subsubheading void set_pattern(Pattern p)
@anchor{_1361}

Set distribution pattern

@subsubheading void set_radial_density(unsigned int count)
@anchor{_1362}

Set average number of ray to distribute on surface radius

@subsubheading void set_scaling(double scaling)
@anchor{_1363}

Set scaling@comma{} Rays are distributed on surface but are kept away from surface edge if scaling is less than 1.0.

@subsubheading void set_uniform_pattern()
@anchor{_1364}

Ensure uniform 2d pattern suitable for spot diagram and image analysis is selected. Change to default pattern if not.

@page

@heading trace::distribution class full member list
@anchor{trace_distribution_class_full_member_list}

@subheading Functions

@itemize
@item distribution(Pattern pattern = @emph{[...]}@comma{} unsigned int radial_density = @emph{[...]}@comma{} double scaling = @emph{[...]})
@item Pattern get_pattern() const
@item unsigned int get_radial_density() const
@item double get_scaling() const
@item void set_pattern(Pattern p)
@item void set_radial_density(unsigned int count)
@item void set_scaling(double scaling)
@item void set_uniform_pattern()
@end itemize

@page

@heading trace::params class reference
@anchor{trace_params_class_reference}

@subheading Declaration

@example
#include <goptical/core/trace/params>

namespace goptical @{
  namespace trace @{
    class params;
  @};
@};

@end example

 This class is a member of the trace namespace.

@subheading Description

This class is used to store light progation parameters. This includes sequential / non-sequential mode@comma{} light intensity computation mode and propagation mode (raytracing@comma{} diffraction@comma{} ...).

See also Performing light propagation (@pxref{Performing light propagation}) section.

@subheading Members

 See also the full member list (@pxref{trace_params_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item params()
@item const distribution & get_default_distribution() const
@item distribution & get_default_distribution()
@item const distribution & get_distribution(const sys::Surface &s) const
@item IntensityMode get_intensity_mode() const
@item double get_lost_ray_length() const
@item unsigned int get_max_bounce() const
@item bool get_unobstructed() const
@item bool is_sequential() const
@item void reset_distribution()
@item void set_default_distribution(const distribution &default_distribution)
@item void set_distribution(const sys::Surface &s@comma{} const distribution &dist)
@item void set_intensity_mode(IntensityMode intensity_mode)
@item void set_lost_ray_length(double lost_ray_length)
@item void set_max_bounce(unsigned int max_bounce)
@item void set_nonsequential_mode()
@item void set_sequential_mode(const const_ref<sequence> &seq)
@item void set_unobstructed(bool unobstructed)
@end itemize

@subheading Members detail

@subsubheading params()
@anchor{_1365}

No documentation available

@subsubheading const distribution & get_default_distribution() const
@anchor{_1366}

 Get default rays distribution pattern.

See also set_default_distribution (@pxref{_1375}) function.

@subsubheading distribution & get_default_distribution()
@anchor{_1367}

 Get default rays distribution pattern.

See also set_default_distribution (@pxref{_1375}) function.

@subsubheading const distribution & get_distribution(const sys::Surface &s) const
@anchor{_1368}

Get distribution pattern for a given surface

@subsubheading IntensityMode get_intensity_mode() const
@anchor{_1369}

 Get raytracing intensity mode.

See also set_intensity_mode (@pxref{_1377}) function.

@subsubheading double get_lost_ray_length() const
@anchor{_1370}

 Get lost ray length.

See also set_lost_ray_length (@pxref{_1378}) function.

@subsubheading unsigned int get_max_bounce() const
@anchor{_1371}

 Get maximum ray bounce count@comma{} default is 50.

See also set_max_bounce (@pxref{_1379}) function.

@subsubheading bool get_unobstructed() const
@anchor{_1372}

 Get unobstructed raytracing mode. Surface shapes are ignored@comma{} no rays are stopped.

See also set_unobstructed (@pxref{_1382}) function.

@subsubheading bool is_sequential() const
@anchor{_1373}

Test if in sequential ray tracing mode

@subsubheading void reset_distribution()
@anchor{_1374}

Reset all surface specific distribution settings to default

@subsubheading void set_default_distribution(const distribution &default_distribution)
@anchor{_1375}

 Set default rays distribution pattern.

See also get_default_distribution (@pxref{_1366}) function.

@subsubheading void set_distribution(const sys::Surface &s@comma{} const distribution &dist)
@anchor{_1376}

Set distribution pattern for a given surface

@subsubheading void set_intensity_mode(IntensityMode intensity_mode)
@anchor{_1377}

 Set raytracing intensity mode.

See also get_intensity_mode (@pxref{_1369}) function.

@subsubheading void set_lost_ray_length(double lost_ray_length)
@anchor{_1378}

 Set lost ray length.

See also get_lost_ray_length (@pxref{_1370}) function.

@subsubheading void set_max_bounce(unsigned int max_bounce)
@anchor{_1379}

 Set maximum ray bounce count@comma{} default is 50.

See also get_max_bounce (@pxref{_1371}) function.

@subsubheading void set_nonsequential_mode()
@anchor{_1380}

Set non sequential ray tracing mode (default)

@subsubheading void set_sequential_mode(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <sequence> &seq)
@anchor{_1381}

Set sequential ray tracing mode

@subsubheading void set_unobstructed(bool unobstructed)
@anchor{_1382}

 Set unobstructed raytracing mode. Surface shapes are ignored@comma{} no rays are stopped.

See also get_unobstructed (@pxref{_1372}) function.

@page

@heading trace::params class full member list
@anchor{trace_params_class_full_member_list}

@subheading Functions

@itemize
@item params()
@item const distribution & get_default_distribution() const
@item distribution & get_default_distribution()
@item const distribution & get_distribution(const sys::Surface &s) const
@item IntensityMode get_intensity_mode() const
@item double get_lost_ray_length() const
@item unsigned int get_max_bounce() const
@item bool get_unobstructed() const
@item bool is_sequential() const
@item void reset_distribution()
@item void set_default_distribution(const distribution &default_distribution)
@item void set_distribution(const sys::Surface &s@comma{} const distribution &dist)
@item void set_intensity_mode(IntensityMode intensity_mode)
@item void set_lost_ray_length(double lost_ray_length)
@item void set_max_bounce(unsigned int max_bounce)
@item void set_nonsequential_mode()
@item void set_sequential_mode(const const_ref<sequence> &seq)
@item void set_unobstructed(bool unobstructed)
@end itemize

@page

@heading trace::Result class reference
@anchor{trace_Result_class_reference}

@subheading Declaration

@example
#include <goptical/core/trace/Result>

namespace goptical @{
  namespace trace @{
    class Result;
  @};
@};

@end example

 This class is a member of the trace namespace.

@subheading Description

This class encapsulates rays data propagation result.

It must be properly configured before light propagation as needed by the analysis currently being performed. All requested light propagation informations will be store for further processing.

All Ray (@pxref{trace_Ray_class_reference}) object are allocated by this class. It is able to remember which element intercepted and generated each ray.

@subheading Members

 See also the full member list (@pxref{trace_Result_class_full_member_list}) section for this class.

@subsubheading Type

@itemize
@item typedef @emph{ [...] } sources_t
@end itemize

@subsubheading Functions

@itemize
@item Result()
@item ~Result()
@item void add_generated(const sys::Element &s@comma{} Ray &ray)
@item void add_intercepted(const sys::Surface &s@comma{} Ray &ray)
@item void add_ray_wavelen(double wavelen)
@item void clear()
@item void clear_save_states()
@item void draw_2d(io::Renderer &r@comma{} bool hit_image = @emph{[...]}@comma{} const sys::Element *ref = @emph{[...]}) const
@item void draw_3d(io::Renderer &r@comma{} bool hit_image = @emph{[...]}@comma{} const sys::Element *ref = @emph{[...]}) const
@item const rays_queue_t & get_generated(const sys::Element &s) const
@item bool get_generated_save_state(const sys::Element &e)
@item const rays_queue_t & get_intercepted(const sys::Surface &s) const
@item math::vector3 get_intercepted_center(const sys::Surface &s) const
@item math::vector3 get_intercepted_centroid(const sys::Surface &s) const
@item bool get_intercepted_save_state(const sys::Element &e)
@item math::vectorPair3 get_intercepted_window(const sys::Surface &s) const
@item double get_max_ray_intensity() const
@item const params & get_params() const
@item const std::set<double> & get_ray_wavelen_set() const
@item const sources_t & get_source_list() const
@item Ray & new_ray()
@item Ray & new_ray(const light::Ray &r)
@item void set_generated_save_state(const sys::Element &e@comma{} bool enabled = @emph{[...]})
@item void set_intercepted_save_state(const sys::Element &e@comma{} bool enabled = @emph{[...]})
@end itemize

@subheading Members detail

@subsubheading Result()
@anchor{_1383}

Crate a new empty result object

@subsubheading ~Result()
@anchor{_1384}

No documentation available

@subsubheading void add_generated(const sys::Element &s@comma{} Ray &ray)
@anchor{_1385}

Declare a new ray generation

@subsubheading void add_intercepted(const sys::Surface &s@comma{} Ray &ray)
@anchor{_1386}

Declare a new ray interception

@subsubheading void add_ray_wavelen(double wavelen)
@anchor{_1387}

Declare ray wavelen used for tracing

@subsubheading void clear()
@anchor{_1388}

Clear all result data

@subsubheading void clear_save_states()
@anchor{_1389}

Set all save states to false

@subsubheading void draw_2d(io::Renderer &r@comma{} bool hit_image = false@comma{} const sys::Element *ref = 0) const
@anchor{_1390}

Draw all tangential rays using specified renderer. Only rays which end up hitting the image plane are drawn when @samp{hit_image} is set.

@subsubheading void draw_3d(io::Renderer &r@comma{} bool hit_image = false@comma{} const sys::Element *ref = 0) const
@anchor{_1391}

Draw all rays using specified renderer. Only rays which end up hitting the image plane are drawn when @samp{hit_image} is set.

@subsubheading const rays_queue_t & get_generated(const sys::Element &s) const
@anchor{_1392}

Get the list of rays generated by a given element

@subsubheading bool get_generated_save_state(const sys::Element &e)
@anchor{_1393}

Return true if generated rays must be saved for this element

@subsubheading const rays_queue_t & get_intercepted(const sys::Surface &s) const
@anchor{_1394}

Get the list of rays striking a given surface

@subsubheading math::vector3 get_intercepted_center(const sys::Surface &s) const
@anchor{_1395}

Get center of window

@subsubheading math::vector3 get_intercepted_centroid(const sys::Surface &s) const
@anchor{_1396}

Get centroid of all ray intercepted on a surface

@subsubheading bool get_intercepted_save_state(const sys::Element &e)
@anchor{_1397}

Return true if generated rays must be saved for this element

@subsubheading math::vectorPair3 get_intercepted_window(const sys::Surface &s) const
@anchor{_1398}

Get window which include all ray intercepted on a surface

@subsubheading double get_max_ray_intensity() const
@anchor{_1399}

Get maximum intensity for a single ray FIXME

@subsubheading const params & get_params() const
@anchor{_1400}

Get reference to tracer parameters used

@subsubheading const std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01190.html,,set} <double> & get_ray_wavelen_set() const
@anchor{_1401}

Get ray wavelen in use set

@subsubheading const sources_t & get_source_list() const
@anchor{_1402}

Get list of sources used for ray tracing

@subsubheading Ray & new_ray()
@anchor{_1403}

Allocate a new trace::Ray object from result

@subsubheading Ray & new_ray(const light::Ray &r)
@anchor{_1404}

Allocate a new trace::Ray object from result

@subsubheading void set_generated_save_state(const sys::Element &e@comma{} bool enabled = true)
@anchor{_1405}

List of rays generated by this element must be saved when tracing rays

@subsubheading void set_intercepted_save_state(const sys::Element &e@comma{} bool enabled = true)
@anchor{_1406}

List of rays striking this surface must be saved when tracing rays

@subsubheading typedef std:: @uref{http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a01318.html,,vector} <const sys::Source*> sources_t
@anchor{_1407}

No documentation available

@page

@heading trace::Result class full member list
@anchor{trace_Result_class_full_member_list}

@subheading Type

@itemize
@item typedef @emph{ [...] } sources_t
@end itemize

@subheading Functions

@itemize
@item Result()
@item ~Result()
@item void add_generated(const sys::Element &s@comma{} Ray &ray)
@item void add_intercepted(const sys::Surface &s@comma{} Ray &ray)
@item void add_ray_wavelen(double wavelen)
@item void clear()
@item void clear_save_states()
@item void draw_2d(io::Renderer &r@comma{} bool hit_image = @emph{[...]}@comma{} const sys::Element *ref = @emph{[...]}) const
@item void draw_3d(io::Renderer &r@comma{} bool hit_image = @emph{[...]}@comma{} const sys::Element *ref = @emph{[...]}) const
@item const rays_queue_t & get_generated(const sys::Element &s) const
@item bool get_generated_save_state(const sys::Element &e)
@item const rays_queue_t & get_intercepted(const sys::Surface &s) const
@item math::vector3 get_intercepted_center(const sys::Surface &s) const
@item math::vector3 get_intercepted_centroid(const sys::Surface &s) const
@item bool get_intercepted_save_state(const sys::Element &e)
@item math::vectorPair3 get_intercepted_window(const sys::Surface &s) const
@item double get_max_ray_intensity() const
@item const params & get_params() const
@item const std::set<double> & get_ray_wavelen_set() const
@item const sources_t & get_source_list() const
@item Ray & new_ray()
@item Ray & new_ray(const light::Ray &r)
@item void set_generated_save_state(const sys::Element &e@comma{} bool enabled = @emph{[...]})
@item void set_intercepted_save_state(const sys::Element &e@comma{} bool enabled = @emph{[...]})
@end itemize

@page

@heading trace::sequence class reference
@anchor{trace_sequence_class_reference}

@subheading Declaration

@example
#include <goptical/core/trace/sequence>

namespace goptical @{
  namespace trace @{
    class sequence;
  @};
@};

@end example

 This class is a member of the trace namespace.

@subheading Inheritance

@subheading Description

There are two light propagation modes in common use: sequential and non sequential. When using the sequential mode@comma{} light only interacts with sequence elements in given sequence order.

This class will hold the user defined ordered list of elements used by sequential light propagation algorithm implemented in the tracer (@pxref{trace_tracer_class_reference}) class.

@subheading Members

 See also the full member list (@pxref{trace_sequence_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item sequence()
@item sequence(const sys::system &system)
@item void add(const sys::system &system)
@item unsigned int append(const sys::Element &element)
@item void clear()
@item const sys::Element & get_element(unsigned int index) const
@item void insert(unsigned int index@comma{} const sys::Element &element)
@item void remove(unsigned int index)
@end itemize

@subheading Members detail

@subsubheading sequence()
@anchor{_1408}

Create a new empty sequence

@subsubheading sequence(const sys::system &system)
@anchor{_1409}

Create a new sequence and insert all elements present in the system. This is equivalent to calling add() on empty sequence.

@subsubheading void add(const sys::system &system)
@anchor{_1410}

Add all elements from the given system. Element are sorted in axis order starting from left; reflecting elements do reverse direction.

@subsubheading unsigned int append(const sys::Element &element)
@anchor{_1411}

Insert an element at end of sequence. 

The return value is position of the element in the sequence

@subsubheading void clear()
@anchor{_1412}

Remove all elements from sequence

@subsubheading const sys::Element & get_element(unsigned int index) const
@anchor{_1413}

Get a reference to an element in sequence

@subsubheading void insert(unsigned int index@comma{} const sys::Element &element)
@anchor{_1414}

Insert an element in sequence at given position

@subsubheading void remove(unsigned int index)
@anchor{_1415}

Remove an element from sequence

@page

@heading trace::sequence class full member list
@anchor{trace_sequence_class_full_member_list}

@subheading Functions

@itemize
@item sequence()
@item sequence(const sys::system &system)
@item void add(const sys::system &system)
@item unsigned int append(const sys::Element &element)
@item void clear()
@item const sys::Element & get_element(unsigned int index) const
@item void insert(unsigned int index@comma{} const sys::Element &element)
@item void remove(unsigned int index)
@end itemize

@page

@heading trace::tracer class reference
@anchor{trace_tracer_class_reference}

@subheading Declaration

@example
#include <goptical/core/trace/Tracer>

namespace goptical @{
  namespace trace @{
    class tracer;
  @};
@};

@end example

 This class is a member of the trace namespace.

@subheading Description

This class handle light propagation in an optical system.

Propagation result is stored in a Result (@pxref{trace_Result_class_reference}) object. Propagation parameters are stored in a params (@pxref{trace_params_class_reference}) object.

See also Performing light propagation (@pxref{Performing light propagation}) section.

@subheading Members

 See also the full member list (@pxref{trace_tracer_class_full_member_list}) section for this class.

@subsubheading Functions

@itemize
@item tracer(const const_ref<sys::system> &system)
@item ~tracer()
@item const params & get_params() const
@item params & get_params()
@item const sys::system & get_system() const
@item Result & get_trace_result() const
@item Result & set_default_trace_result()
@item void set_params(const params &params)
@item void set_trace_result(Result &res)
@item void trace()
@end itemize

@subheading Members detail

@subsubheading tracer(const  @uref{http://diaxen.ssji.net/dpp/const_ref_class_reference.html,,const_ref} <sys::system> &system)
@anchor{_1416}

Create a new light porpagator object

@subsubheading ~tracer()
@anchor{_1417}

No documentation available

@subsubheading const params & get_params() const
@anchor{_1418}

get tracer parameters

@subsubheading params & get_params()
@anchor{_1419}

get tracer parameters

@subsubheading const sys::system & get_system() const
@anchor{_1420}

Get attached system

@subsubheading Result & get_trace_result() const
@anchor{_1421}

No documentation available

@subsubheading Result & set_default_trace_result()
@anchor{_1422}

Undefine user defined Result object. Next ray trace operation will allocate a new internal trace result object

@subsubheading void set_params(const params &params)
@anchor{_1423}

replace all tracer parameters

@subsubheading void set_trace_result(Result &res)
@anchor{_1424}

Set the Result object which must be used to store ray tracing data. a new Result object will be allocated on first ray trace operation if none were defined.

@subsubheading void trace()
@anchor{_1425}

Launch ray tracing operation

@page

@heading trace::tracer class full member list
@anchor{trace_tracer_class_full_member_list}

@subheading Functions

@itemize
@item tracer(const const_ref<sys::system> &system)
@item ~tracer()
@item const params & get_params() const
@item params & get_params()
@item const sys::system & get_system() const
@item Result & get_trace_result() const
@item Result & set_default_trace_result()
@item void set_params(const params &params)
@item void set_trace_result(Result &res)
@item void trace()
@end itemize

@page

@heading trace::Ray class reference
@anchor{trace_Ray_class_reference}

@subheading Declaration

@example
#include <goptical/core/trace/Ray>

namespace goptical @{
  namespace trace @{
    class Ray;
  @};
@};

@end example

 This class is a member of the trace namespace.

@subheading Inheritance

@subheading Description

This class is used to describe a light::Ray (@pxref{light_Ray_class_reference}) with all tracing and propagation informations attached.

@subheading Members

 See also the full member list (@pxref{trace_Ray_class_full_member_list}) section for this class.

@subsubheading Inherited members

@itemize
@item 36 members inherited from light::Ray (@pxref{light_Ray_class_reference})
@end itemize

@subsubheading Functions

@itemize
@item Ray()
@item Ray(const light::Ray &r)
@item void add_generated(Ray *r)
@item const sys::Element * get_creator() const
@item math::vector3 get_direction() const
@item math::vector3 get_direction(const sys::Element &e) const
@item Ray * get_first_child() const
@item sys::Element & get_intercept_element() const
@item double get_intercept_intensity() const
@item const math::vector3 & get_intercept_point() const
@item double get_len() const
@item const material::Base * get_material() const
@item Ray * get_next_child() const
@item Ray * get_parent() const
@item math::vector3 get_position() const
@item math::vector3 get_position(const sys::Element &e) const
@item bool is_lost() const
@item void set_creator(const sys::Element *creator)
@item void set_intercept(const sys::Element &e@comma{} const math::vector3 &point)
@item void set_intercept_intensity(double intercept_intensity)
@item void set_len(double len)
@item void set_material(const material::Base *material)
@end itemize

@subheading Members detail

@subsubheading Ray()
@anchor{_1426}

This constructor shadows the @code{Ray (@pxref{_489})} constructor defined in the @code{Ray (@pxref{light_Ray_class_reference})} base class.

Create a propagated light ray

@subsubheading Ray(const light::Ray &r)
@anchor{_1427}

Create a propagated light ray

@subsubheading void add_generated(Ray *r)
@anchor{_1428}

Define a new child generated ray

@subsubheading const sys::Element * get_creator() const
@anchor{_1429}

 Get element which generated this ray..

See also set_creator (@pxref{_1443}) function.

@subsubheading math::vector3 get_direction() const
@anchor{_1430}

Get global direction

@subsubheading math::vector3 get_direction(const sys::Element &e) const
@anchor{_1431}

Get direction relative to given element

@subsubheading Ray * get_first_child() const
@anchor{_1432}

Get first ray generated from this one

@subsubheading sys::Element & get_intercept_element() const
@anchor{_1433}

Get light ray interception element

@subsubheading double get_intercept_intensity() const
@anchor{_1434}

 Get ray intensity at interception point..

See also set_intercept_intensity (@pxref{_1445}) function.

@subsubheading const math::vector3 & get_intercept_point() const
@anchor{_1435}

Get light ray interception point

@subsubheading double get_len() const
@anchor{_1436}

 Get light ray length..

See also set_len (@pxref{_1446}) function.

@subsubheading const material::Base * get_material() const
@anchor{_1437}

 Get material ray is propagated in..

See also set_material (@pxref{_1447}) function.

@subsubheading Ray * get_next_child() const
@anchor{_1438}

Get next sibling ray generated by same parent

@subsubheading Ray * get_parent() const
@anchor{_1439}

Get ray which generated this one

@subsubheading math::vector3 get_position() const
@anchor{_1440}

Get global position

@subsubheading math::vector3 get_position(const sys::Element &e) const
@anchor{_1441}

Get position relative to given element

@subsubheading bool is_lost() const
@anchor{_1442}

Return true if ray is not intercepted

@subsubheading void set_creator(const sys::Element *creator)
@anchor{_1443}

 Set element which generated this ray..

See also get_creator (@pxref{_1429}) function.

@subsubheading void set_intercept(const sys::Element &e@comma{} const math::vector3 &point)
@anchor{_1444}

Set light ray interception point and element

@subsubheading void set_intercept_intensity(double intercept_intensity)
@anchor{_1445}

 Set ray intensity at interception point..

See also get_intercept_intensity (@pxref{_1434}) function.

@subsubheading void set_len(double len)
@anchor{_1446}

 Set light ray length..

See also get_len (@pxref{_1436}) function.

@subsubheading void set_material(const material::Base *material)
@anchor{_1447}

 Set material ray is propagated in..

See also get_material (@pxref{_1437}) function.

@page

@heading trace::Ray class full member list
@anchor{trace_Ray_class_full_member_list}

@subheading Functions

@itemize
@item Ray()
@item Ray(const light::Ray &r)
@item void add_generated(Ray *r)
@item math::vector<N> & direction()
@item const math::vector<N> & direction() const
@item const sys::Element * get_creator() const
@item math::vector3 get_direction() const
@item math::vector3 get_direction(const sys::Element &e) const
@item Ray * get_first_child() const
@item double get_intensity() const
@item sys::Element & get_intercept_element() const
@item double get_intercept_intensity() const
@item const math::vector3 & get_intercept_point() const
@item double get_len() const
@item const material::Base * get_material() const
@item Ray * get_next_child() const
@item Ray * get_parent() const
@item math::vector3 get_position() const
@item math::vector3 get_position(const sys::Element &e) const
@item double get_wavelen() const
@item bool is_lost() const
@item math::vector<3> ln_ln_clst_pt(const math::vectorPair<3> &line) const
@item double ln_ln_clst_pt_scale(const math::vectorPair<3> &line) const
@item math::vector<N> ln_pt_clst_pt(const math::vector<N> &point) const
@item double ln_pt_clst_pt_scale(const math::vector<N> &point) const
@item math::vector<N> & normal()
@item const math::vector<N> & normal() const
@item math::vectorPairBase<3> operator*(double factor)
@item const math::vectorPairBase<3> & operator+=(const math::vectorPairBase<3> &p)
@item const math::vector<N> & operator[](int n) const
@item math::vector<N> & operator[](int n)
@item math::vector<N> & origin()
@item const math::vector<N> & origin() const
@item math::vector<3> pl_ln_intersect(const math::vectorPair<3> &line) const
@item double pl_ln_intersect_scale(const math::vectorPair<3> &line) const
@item math::vector<N> seg_pt_clst_pt(const math::vector<N> &point) const
@item double seg_pt_clst_pt_scale(const math::vector<N> &point) const
@item void set_creator(const sys::Element *creator)
@item void set_intensity(double intensity)
@item void set_intercept(const sys::Element &e@comma{} const math::vector3 &point)
@item void set_intercept_intensity(double intercept_intensity)
@item void set_len(double len)
@item void set_material(const material::Base *material)
@item void set_wavelen(double wavelen)
@item double x0() const
@item double & x0()
@item double x1() const
@item double & x1()
@item double y0() const
@item double & y0()
@item double y1() const
@item double & y1()
@item double z0() const
@item double & z0()
@item double z1() const
@item double & z1()
@end itemize

@page

@node GNU Free Documentation License,,API documentation,Top
@chapter GNU Free Documentation License

 Version 1.3@comma{} 3 November 2008

Copyright (C) 2000@comma{} 2001@comma{} 2002@comma{} 2007@comma{} 2008 Free Software Foundation@comma{} Inc.  @uref{http://fsf.org/,,http://fsf.org/} 

Everyone is permitted to copy and distribute verbatim copies of this license document@comma{} but changing it is not allowed.

@heading 0 PREAMBLE

The purpose of this License is to make a manual@comma{} textbook@comma{} or other functional and useful document free in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it@comma{} with or without modifying it@comma{} either commercially or noncommercially. Secondarily@comma{} this License preserves for the author and publisher a way to get credit for their work@comma{} while not being considered responsible for modifications made by others.

This License is a kind of "copyleft"@comma{} which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License@comma{} which is a copyleft license designed for free software.

We have designed this License in order to use it for manuals for free software@comma{} because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work@comma{} regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.

@heading 1 APPLICABILITY AND DEFINITIONS

This License applies to any manual or other work@comma{} in any medium@comma{} that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide@comma{} royalty-free license@comma{} unlimited in duration@comma{} to use that work under the conditions stated herein. The "Document"@comma{} below@comma{} refers to any such manual or work. Any member of the public is a licensee@comma{} and is addressed as "you". You accept the license if you copy@comma{} modify or distribute the work in a way requiring permission under copyright law.

A "Modified Version" of the Document means any work containing the Document or a portion of it@comma{} either copied verbatim@comma{} or with modifications and/or translated into another language.

A "Secondary Section" is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document's overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus@comma{} if the Document is in part a textbook of mathematics@comma{} a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters@comma{} or of legal@comma{} commercial@comma{} philosophical@comma{} ethical or political position regarding them.

The "Invariant Sections" are certain Secondary Sections whose titles are designated@comma{} as being those of Invariant Sections@comma{} in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none.

The "Cover Texts" are certain short passages of text that are listed@comma{} as Front-Cover Texts or Back-Cover Texts@comma{} in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words@comma{} and a Back-Cover Text may be at most 25 words.

A "Transparent" copy of the Document means a machine-readable copy@comma{} represented in a format whose specification is available to the general public@comma{} that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor@comma{} and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup@comma{} or absence of markup@comma{} has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not "Transparent" is called "Opaque".

Examples of suitable formats for Transparent copies include plain ascii without markup@comma{} @emph{Texinfo} input format@comma{} @emph{LaTeX} input format@comma{} @emph{SGML} or @emph{XML} using a publicly available @emph{DTD} @comma{} and standard-conforming simple @emph{HTML} @comma{} @emph{PostScript} or @emph{PDF} designed for human modification. Examples of transparent image formats include @emph{PNG} @comma{} @emph{XCF} and @emph{JPG} . Opaque formats include proprietary formats that can be read and edited only by proprietary word processors@comma{} @emph{SGML} or @emph{XML} for which the @emph{DTD} and/or processing tools are not generally available@comma{} and the machine-generated @emph{HTML} @comma{} @emph{PostScript} or @emph{PDF} produced by some word processors for output purposes only.

The "Title Page" means@comma{} for a printed book@comma{} the title page itself@comma{} plus such following pages as are needed to hold@comma{} legibly@comma{} the material this License requires to appear in the title page. For works in formats which do not have any title page as such@comma{} "Title Page" means the text near the most prominent appearance of the work's title@comma{} preceding the beginning of the body of the text.

The "publisher" means any person or entity that distributes copies of the Document to the public.

A section "Entitled XYZ" means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below@comma{} such as "Acknowledgements"@comma{} "Dedications"@comma{} "Endorsements"@comma{} or "History".) To "Preserve the Title" of such a section when you modify the Document means that it remains a section "Entitled XYZ" according to this definition.

The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License@comma{} but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.

@heading 2 VERBATIM COPYING

You may copy and distribute the Document in any medium@comma{} either commercially or noncommercially@comma{} provided that this License@comma{} the copyright notices@comma{} and the license notice saying this License applies to the Document are reproduced in all copies@comma{} and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However@comma{} you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3.

You may also lend copies@comma{} under the same conditions stated above@comma{} and you may publicly display copies.

@heading 3 COPYING IN QUANTITY

If you publish printed copies (or copies in media that commonly have printed covers) of the Document@comma{} numbering more than 100@comma{} and the Document's license notice requires Cover Texts@comma{} you must enclose the copies in covers that carry@comma{} clearly and legibly@comma{} all these Cover Texts: Front-Cover Texts on the front cover@comma{} and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers@comma{} as long as they preserve the title of the Document and satisfy these conditions@comma{} can be treated as verbatim copying in other respects.

If the required texts for either cover are too voluminous to fit legibly@comma{} you should put the first ones listed (as many as fit reasonably) on the actual cover@comma{} and continue the rest onto adjacent pages.

If you publish or distribute Opaque copies of the Document numbering more than 100@comma{} you must either include a machine-readable Transparent copy along with each Opaque copy@comma{} or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document@comma{} free of added material. If you use the latter option@comma{} you must take reasonably prudent steps@comma{} when you begin distribution of Opaque copies in quantity@comma{} to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public.

It is requested@comma{} but not required@comma{} that you contact the authors of the Document well before redistributing any large number of copies@comma{} to give them a chance to provide you with an updated version of the Document.

@heading 4 MODIFICATIONS

You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above@comma{} provided that you release the Modified Version under precisely this License@comma{} with the Modified Version filling the role of the Document@comma{} thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition@comma{} you must do these things in the Modified Version:

@itemize
@item 
 Use in the Title Page (and on the covers@comma{} if any) a title distinct from that of the Document@comma{} and from those of previous versions (which should@comma{} if there were any@comma{} be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.

@item 
 List on the Title Page@comma{} as authors@comma{} one or more persons or entities responsible for authorship of the modifications in the Modified Version@comma{} together with at least five of the principal authors of the Document (all of its principal authors@comma{} if it has fewer than five)@comma{} unless they release you from this requirement.

@item 
 State on the Title page the name of the publisher of the Modified Version@comma{} as the publisher.

@item 
 Preserve all the copyright notices of the Document.

@item 
 Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.

@item 
 Include@comma{} immediately after the copyright notices@comma{} a license notice giving the public permission to use the Modified Version under the terms of this License@comma{} in the form shown in the Addendum below.

@item 
 Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document's license notice.

@item 
 Include an unaltered copy of this License.

@item 
 Preserve the section Entitled "History"@comma{} Preserve its Title@comma{} and add to it an item stating at least the title@comma{} year@comma{} new authors@comma{} and publisher of the Modified Version as given on the Title Page. If there is no section Entitled "History" in the Document@comma{} create one stating the title@comma{} year@comma{} authors@comma{} and publisher of the Document as given on its Title Page@comma{} then add an item describing the Modified Version as stated in the previous sentence.

@item 
 Preserve the network location@comma{} if any@comma{} given in the Document for public access to a Transparent copy of the Document@comma{} and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the "History" section. You may omit a network location for a work that was published at least four years before the Document itself@comma{} or if the original publisher of the version it refers to gives permission.

@item 
 For any section Entitled "Acknowledgements" or "Dedications"@comma{} Preserve the Title of the section@comma{} and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.

@item 
 Preserve all the Invariant Sections of the Document@comma{} unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.

@item 
 Delete any section Entitled "Endorsements". Such a section may not be included in the Modified Version.

@item 
 Do not retitle any existing section to be Entitled "Endorsements" or to conflict in title with any Invariant Section.

@item 
 Preserve any Warranty Disclaimers.

@end itemize

If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document@comma{} you may at your option designate some or all of these sections as invariant. To do this@comma{} add their titles to the list of Invariant Sections in the Modified Version's license notice. These titles must be distinct from any other section titles.

You may add a section Entitled "Endorsements"@comma{} provided it contains nothing but endorsements of your Modified Version by various parties---for example@comma{} statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard.

You may add a passage of up to five words as a Front-Cover Text@comma{} and a passage of up to 25 words as a Back-Cover Text@comma{} to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover@comma{} previously added by you or by arrangement made by the same entity you are acting on behalf of@comma{} you may not add another; but you may replace the old one@comma{} on explicit permission from the previous publisher that added the old one.

The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.

@heading 5 COMBINING DOCUMENTS

You may combine the Document with other documents released under this License@comma{} under the terms defined in section 4 above for modified versions@comma{} provided that you include in the combination all of the Invariant Sections of all of the original documents@comma{} unmodified@comma{} and list them all as Invariant Sections of your combined work in its license notice@comma{} and that you preserve all their Warranty Disclaimers.

The combined work need only contain one copy of this License@comma{} and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents@comma{} make the title of each such section unique by adding at the end of it@comma{} in parentheses@comma{} the name of the original author or publisher of that section if known@comma{} or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work.

In the combination@comma{} you must combine any sections Entitled "History" in the various original documents@comma{} forming one section Entitled "History"; likewise combine any sections Entitled "Acknowledgements"@comma{} and any sections Entitled "Dedications". You must delete all sections Entitled "Endorsements."

@heading 6 COLLECTIONS OF DOCUMENTS

You may make a collection consisting of the Document and other documents released under this License@comma{} and replace the individual copies of this License in the various documents with a single copy that is included in the collection@comma{} provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects.

You may extract a single document from such a collection@comma{} and distribute it individually under this License@comma{} provided you insert a copy of this License into the extracted document@comma{} and follow this License in all other respects regarding verbatim copying of that document.

@heading 7 AGGREGATION WITH INDEPENDENT WORKS

A compilation of the Document or its derivatives with other separate and independent documents or works@comma{} in or on a volume of a storage or distribution medium@comma{} is called an "aggregate" if the copyright resulting from the compilation is not used to limit the legal rights of the compilation's users beyond what the individual works permit. When the Document is included in an aggregate@comma{} this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document.

If the Cover Text requirement of section 3 is applicable to these copies of the Document@comma{} then if the Document is less than one half of the entire aggregate@comma{} the Document's Cover Texts may be placed on covers that bracket the Document within the aggregate@comma{} or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.

@heading 8 TRANSLATION

Translation is considered a kind of modification@comma{} so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders@comma{} but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License@comma{} and all the license notices in the Document@comma{} and any Warranty Disclaimers@comma{} provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer@comma{} the original version will prevail.

If a section in the Document is Entitled "Acknowledgements"@comma{} "Dedications"@comma{} or "History"@comma{} the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.

@heading 9 TERMINATION

You may not copy@comma{} modify@comma{} sublicense@comma{} or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy@comma{} modify@comma{} sublicense@comma{} or distribute it is void@comma{} and will automatically terminate your rights under this License.

However@comma{} if you cease all violation of this License@comma{} then your license from a particular copyright holder is reinstated (a) provisionally@comma{} unless and until the copyright holder explicitly and finally terminates your license@comma{} and (b) permanently@comma{} if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.

Moreover@comma{} your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means@comma{} this is the first time you have received notice of violation of this License (for any work) from that copyright holder@comma{} and you cure the violation prior to 30 days after your receipt of the notice.

Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated@comma{} receipt of a copy of some or all of the same material does not give you any rights to use it.

@heading 10 FUTURE REVISIONS OF THIS LICENSE

The Free Software Foundation may publish new@comma{} revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version@comma{} but may differ in detail to address new problems or concerns. See  @uref{http://www.gnu.org/copyleft/,,http://www.gnu.org/copyleft/}  .

Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License "or any later version" applies to it@comma{} you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License@comma{} you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used@comma{} that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Document.

@heading 11 RELICENSING

"Massive Multiauthor Collaboration Site" (or "MMC Site") means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A "Massive Multiauthor Collaboration" (or "MMC") contained in the site means any set of copyrightable works thus published on the MMC site.

"CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation@comma{} a not-for-profit corporation with a principal place of business in San Francisco@comma{} California@comma{} as well as future copyleft versions of that license published by that same organization.

"Incorporate" means to publish or republish a Document@comma{} in whole or in part@comma{} as part of another Document.

An MMC is "eligible for relicensing" if it is licensed under this License@comma{} and if all works that were first published under this License somewhere other than this MMC@comma{} and subsequently incorporated in whole or in part into the MMC@comma{} (1) had no cover texts or invariant sections@comma{} and (2) were thus incorporated prior to November 1@comma{} 2008.

The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1@comma{} 2009@comma{} provided the MMC is eligible for relicensing.

@heading ADDENDUM: How to use this License for your documents

To use this License in a document you have written@comma{} include a copy of the License in the document and put the following copyright and license notices just after the title page:

Copyright (C) YEAR YOUR NAME. Permission is granted to copy@comma{} distribute and/or modify this document under the terms of the GNU Free Documentation License@comma{} Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections@comma{} no Front-Cover Texts@comma{} and no Back-Cover Texts. A copy of the license is included in the section entitled "GNU Free Documentation License".

If you have Invariant Sections@comma{} Front-Cover Texts and Back-Cover Texts@comma{} replace the "with...Texts." line with this:

with the Invariant Sections being LIST THEIR TITLES@comma{} with the Front-Cover Texts being LIST@comma{} and with the Back-Cover Texts being LIST.

If you have Invariant Sections without Cover Texts@comma{} or some other combination of the three@comma{} merge those two alternatives to suit the situation.

If your document contains nontrivial examples of program code@comma{} we recommend releasing these examples in parallel under your choice of free software license@comma{} such as the GNU General Public License@comma{} to permit their use in free software.

@bye
