@c Copyright (C) 2010 Free Software Foundation, Inc. Permission is
@c granted to copy, distribute and/or modify this document under the
@c terms of the GNU Free Documentation License, Version 1.3 or any later
@c version published by the Free Software Foundation; with no Invariant
@c Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the
@c license is included in the section entitled GNU Free Documentation
@c License.

@section THP {Tutorial}

  This section contains some commented example of applications and
  codes which use the <goptical/core library to model optical systems.

  @insert localtoc

  @section TP {A simple refractor design}

    @image refractor_layout.png {Refractor optical system 2d layout}

    @section T {Building the optical system}
       @label {tuto_system}

      Unlike much optical design software which relies on a list of
      surfaces to sequentially propagate light through the system,
      <goptical/core uses an object representation of the optical system in 3d
      space.

      To model an optical system with <goptical/core, we just have to
      instantiate components and add them to the system.

      For this refractor example we first need to deal with glass
      materials used in the design. Our achromatic refractor design
      needs two lenses of different glass materials. In this example we
      choose to model Bk7 and F3 glasses with the Sellmeier model:

      @example examples/simple_refractor/refractor.cc:material P

      The @ref sys::OpticalSurface class is used to model a single
      optical surface.

      The two lenses have the same disk outline shape, so we declare
      the shape model once:

      @example examples/simple_refractor/refractor.cc:lens_shape

      Surface curves rely on dedicated models which are not dependent on
      optical component being used. Here we need two simple spherical
      curves for the first lens.

      The first lens component can then be instantiated. We need to
      specify its 3d position, thickness, shape model, curve models
      and material models. @ref material::none will later be replaced
      by system environment material.

      @example examples/simple_refractor/refractor.cc:lens1

      More convenient optical surface constructors are available for
      simple cases, with circular aperture and spherical
      curvature. They are used for the second lens:

      @example examples/simple_refractor/refractor.cc:lens2

      The @ref sys::Lens class is more convenient to use for
      most designs as it can handle a list of surfaces. In this example
      we choose to use the @ref sys::OpticalSurface class directly to
      show how things work. The convenient method is used in @xref
      {A photo lens design} {the next example}.

      We then create a point light source at infinite distance with a
      direction vector aimed at entry surface (left of first lens):

      @example examples/simple_refractor/refractor.cc:src

      And we finally create an image plane near the expected focal point:

      @example examples/simple_refractor/refractor.cc:image

      All these components need to be added to an optical system:

      @example examples/simple_refractor/refractor.cc:sys

      This simple optical design is ready for ray tracing and analysis.

    @end section

    @section T {Performing light propagation}
      @label {tuto_seqtrace}

      light propagation through the optical system is performed by the
      @ref trace::tracer class. There are several tracer
      parameters which can be tweaked before starting light
      propagation. Some default parameters can be set for an optical
      system instance; they will be used for each new tracer
      created for the system.

      When light is propagated through the system, a tracer may be
      instructed to keep track of rays hitting or generated by some of
      the components for further analysis.

      Some @ref analysis {analysis classes} are provided which embed a tracer
      configured for a particular analysis, but it's still possible to
      request a light propagation by directly instantiating a tracer
      object.

      There are two major approaches to trace rays through an optical
      system:
      @list
        @item Sequential ray tracing: This requires an ordered list of
          surfaces to traverse. Rays are generated by the light source
          and propagated in the specified sequence order. Any light
          ray which doesn't reach the next surface in order is lost.
        @item Non-sequential ray tracing: Rays are generated by the
          light source and each ray interacts with the first optical
          component found on its path. Rays are propagated this way
          across system components until they reach an image plane or
          get lost.
      @end list

      The default behavior in <goptical/core is to perform a non-sequential
      ray trace when no sequence is provided.

      @section {Non-sequential ray trace}
        A non-sequential ray trace needs the specification of an entrance
        pupil so that rays from light sources can be targeted at
        optical system entry.

        Performing light propagation only needs instantiation of a @ref
        trace::tracer object and invocation of its @ref
        trace::tracer::trace function. tracer parameters are inherited
        from system default tracer parameters:

        @example examples/simple_refractor/refractor.cc:nonseq|trace

        When performing a non-sequential ray trace, only optical
        components based on @ref sys::Surface will interact with light.

        All enabled light sources which are part of the system are
        considered.
      @end section

      @section {Sequential ray trace}
        Switching to a sequential ray trace is easy: The sequence is
        setup from components found in the system, in order along the
        Z axis.

        @example examples/simple_refractor/refractor.cc:seq

        More complicated sequences must be created empty and described
        explicitly using the @ref trace::sequence::add function.

        Optical system and sequence objects can be displayed using stl
        streams:

        @example examples/simple_refractor/refractor.cc:print

        Ray tracing is then performed in the same way as for
        non-sequential ray traces:

        @example examples/simple_refractor/refractor.cc:trace

        When performing a sequential ray trace, all optical components
        can process incoming light rays.

        A single light source must be present at the beginning of the
        sequence.
      @end section

    @end section

    @section T {Rendering optical layout and rays}

      The result of ray tracing is stored in a @ref trace::Result object
      which stores information about generated and intercepted rays and
      involved components for each ray. Not all rays' interactions are
      stored by default, and the result object must be first configured
      to specify which interactions should be stored for further analysis.

      Here we want to draw all rays which are traced through the
      system. We first have to instruct our @ref trace::Result object
      to remember which rays were generated by the source component in
      the system, so that it can used as a starting point for drawing
      subsequently scattered and reflected rays.

      We use an @ref io::Renderer based object which is able to draw
      various things. We use it to draw system components as well as
      to recursively draw all rays generated by light sources.

      Here is what we need to do in order:

      @list
        @item Instantiate a renderer object able to write graphics in
          some output format.
        @item Fit renderer viewport to optical system.
        @item Draw system components.
        @item Optionally change the ray distribution on entrance pupil
          so that only meridional rays are traced.
        @item Instruct the result object to keep track of rays
          generated by the source component.
        @item Perform the ray tracing.
        @item Draw traced rays.
      @end list

      @example examples/simple_refractor/refractor.cc:layout

    @end section

    @section T {Performing a ray fan analysis}
      @label {tuto_fan1}

      The @ref analysis namespace contains classes to perform some
      common analysis on optical systems. analysis classes may
      embed a @ref trace::tracer object if light propagation is
      needed to perform analysis.

      Ray fan plots can be computed using the @ref analysis::RayFan
      class which is able to plot various ray measurements on both
      2d plot axes.

      The example below shows how to produce a transverse aberration
      plot by plotting entrance ray height against transverse distance:

      @example examples/simple_refractor/refractor.cc:rayfan
      @image refractor_fan.png

    @end section

  @end section

  @c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
  
  @section TP {A photo lens design}

    @image tessar_layout.png {Tessar lens system 2d layout with chief and marginal rays}

    @section T {Using the Lens component}

      The @ref sys::Lens class is a convenient way to model a list of
      optical surfaces. In this example we use it to model a Tessar
      photo lens by adding all optical surfaces to the lens object.
      Several functions are available to add surfaces to the lens; one
      of the simplest can create spherical surfaces with circular
      aperture for us. In this example, the glass material models used are
      created on the fly:

      @example examples/tessar_lens/tessar.cc:lens P

    @end section

    @section T {Adding multiple light sources}

      The @ref sys::source_point class can be used to create a point
      light source suitable for analysis, but we sometimes want to
      trace custom rays. This can be achieved by using the @ref
      sys::SourceRays component class.

      In this example we add both source types to our system but
      enable a single one at the same time. The @ref sys::SourceRays
      is used to draw a 2d layout with chief and marginal rays whereas
      the @ref sys::source_point source is used with multiple
      wavelengths for ray fan and spot diagram analysis:

      @example examples/tessar_lens/tessar.cc:sources

      The object is located at -1000 on the Z axis and has a height of 27.5.

    @end section

    @section T {Plotting spot diagram}
      @label {tuto_spot1}

      The @ref analysis::spot class can be used to plot spot diagrams:

      @example examples/tessar_lens/tessar.cc:spot
      @image tessar_spot.png {Tessar lens spot diagram}

      @example examples/tessar_lens/tessar.cc:spot_plot
      @image tessar_spot_intensity.png

    @end section

    @section T {Plotting ray fans}
      @label {tuto_fan2}

      Various ray fan plots can be obtained by using the @ref
      analysis::RayFan class:

      @example examples/tessar_lens/tessar.cc:opd_fan
      @image tessar_opdfan.png

      @example examples/tessar_lens/tessar.cc:transverse_fan
      @image tessar_transverse.png

      @example examples/tessar_lens/tessar.cc:longitudinal_fan
      @image tessar_longitudinal.png

    @end section

  @end section

  @c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

  @section TP {system hierarchy and groups}
    @label {tuto_group}

    <goptical/core allows arranging components of the optical system in a
    hierarchical manner. Optical component classes all inherit from
    the @ref sys::Element class. Elements which inherit from the @ref
    sys::Group class can contain nested elements.

    Each element has a local coordinate system and stores a @ref
    math::Transform<3> object which describes its translation and
    rotation relative to the parent coordinate system.

    @section T {The Lens component}
      @label {tuto_lens}

      The @ref sys::Lens optical component is a good example of group
      component. It is based on the @ref sys::Group class so that it
      can embed @ref sys::OpticalSurface and @ref sys::Stop elements.

      When displaying the system and ray trace sequence of the @xref {A
      photo lens design} {tessar lens design described in the previous
      section}, we notice that the system hierarchy has been
      flattened in the sequence:

      @code R
system:
   [1]<goptical/core::sys::Lens at [0, 0, 0]
   [10]<goptical/core::sys::image at [0, 0, 125.596]
   [11]<goptical/core::sys::SourceRays at [0, 27.5, -1000]
   [12]<goptical/core::sys::source_point at [0, 27.5, -1000]
sequence:
   [11]<goptical/core::sys::SourceRays at [0, 27.5, -1000]
   [12]<goptical/core::sys::source_point at [0, 27.5, -1000]
   [2]<goptical/core::sys::OpticalSurface at [0, 0, 0]
   [3]<goptical/core::sys::OpticalSurface at [0, 0, 4.6278]
   [4]<goptical/core::sys::OpticalSurface at [0, 0, 10.0452]
   [5]<goptical/core::sys::OpticalSurface at [0, 0, 13.7735]
   [6]<goptical/core::sys::Stop at [0, 0, 18.1914]
   [7]<goptical/core::sys::OpticalSurface at [0, 0, 20.4803]
   [8]<goptical/core::sys::OpticalSurface at [0, 0, 21.9796]
   [9]<goptical/core::sys::OpticalSurface at [0, 0, 29.9758]
   [10]<goptical/core::sys::image at [0, 0, 125.596]
      @end code

      Positions of optical surfaces are relative to the parent lens
      position.

    @end section

    @section T {A newton telescope with corrector}
      @label {tuto_newton}

      Object-oriented programming together with the hierarchical optical
      components organization in <goptical/core allows writing complex and
      dynamically parameterized optical component models composed of
      simple components.

      @section {Using the telescope model}

        Usage of the @ref Design::telescope::Newton {newton telescope
        model class} is presented here as an example of parameterized
        models which contain simple components. The following example
        shows how to build an optical design composed of a light source, the
        newton telescope model, a corrector lens assembly and an image plane.

        The model constructor is called with the basic newton telescope
        parameters and the model internally computes other parameters of
        the telescope and instantiates internal optical components as
        needed.

        @example examples/hierarchical_design/newton.cc:telescope P

        We can query the telescope model to get the 3d position of the
        focal plane within parent coordinates. This enables us to attach
        the image plane or next optical component at right location
        without much calculation.

      @end section

      @section {Adding a corrector}

        We choose to attach a Wynne 4 lens corrector to the telescope.
        As usual we describe the corrector lens group using the @ref
        sys::Lens component:

        @example examples/hierarchical_design/newton.cc:corrector

        The first surface of the corrector is located relative to origin
        of the @tt wynne lens component with a Z offset of -48.4585 in
        the lens coordinate system but the whole lens is rotated and
        positioned at the telescope focal plane in the parent
        coordinate system.

        Finally an image plane is created and positioned according to
        the corrector position and last surface thickness.

      @end section

      @section {Querying model and rendering layouts}

        The model class may also provide access to some internal
        construction details:
        
        @example examples/hierarchical_design/newton.cc:print

        2d and 3d layouts of the whole system or groups can be
        rendered. The following code uses paging to render two such
        different views of the system:

        @example examples/hierarchical_design/newton.cc:layout

        @image newton_wynne4_layout.png {3d layout of the system and 2d
        layout closeup of the corrector}

      @end section

    @end section

  @end section

  @c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

  @section TP {A parameterizable segmented mirror model}

    This section shows how to take advantages of the @xref
    {tuto_group} {hierarchical design} feature of <goptical/core to write
    your own parameterizable optical component models. The code of a
    segmented mirror component model is presented and this new
    component is used as the primary mirror in a Ritchey-Chretien
    telescope design.

    @image hexseg_mirror.png {3d layout of a Ritchey-Chretien telescope with segmented primary mirror (X3D output)}

    @section T {Writing the component model class}

      The segmented mirror model uses hexagonal segments and takes a
      surface curve model, an aperture shape model, segment size and
      segment separation as parameters. We start the definition of
      our model class which inherits from the @ref sys::Group class:

      @example examples/segmented_mirror/segmented.cc:hexseg1 P

      When the model is instantiated, all hexagonal mirrors need to be
      created from the constructor. We use two loops in order to
      build the hexagonal mirror tessellation:

      @example examples/segmented_mirror/segmented.cc:hexseg2

      The aperture shape is then used to check if a segment mirror
      must exist at each location:

      @example examples/segmented_mirror/segmented.cc:hexseg3

      The segment mirror curve must take into account the offset from the main
      mirror origin. We also decide to subtract the sagitta offset from
      the segment curve and add it to its Z component position
      instead; this allows its origin to lie on the segment surface,
      which may be more convenient when tilting the segment. The @ref
      curve::Composer class is used here to apply required
      transformations to the model curve passed as a parameter:

      @example examples/segmented_mirror/segmented.cc:hexseg4

      The segment mirror is then created and added to the model group:

      @example examples/segmented_mirror/segmented.cc:hexseg5

      We finally add some code to keep track of the segments so that
      they can be accessed (and modified) separately after model
      instantiation:
    
      @example examples/segmented_mirror/segmented.cc:hexseg6

      This model class is less than 70 lines long, including comments.

    @end section

    @section T {Using the model in Ritchey-Chretien design}

      Our new model can now be used like other component models in
      optical systems and groups. We use it here with a ring aperture
      shape and conic curvature to model the primary mirror of a
      Ritchey-Chretien telescope:

      @example examples/segmented_mirror/segmented.cc:rc
    
    @end section

  @end section

  @c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

  @section TP {A custom surface curve model}
    @label {tuto_usercurve}

    Common curve models are available in the @ref curve namespace but
    extending this set with user-defined models is easy, as explained
    in this tutorial.

    @section T {Writing the curve model class}

      In this example, we chose to model a rotationally symmetric @url
      http://en.wikipedia.org/wiki/Catenary {catenary} curve. This
      curve has the following sagitta formula:

      @math $ z = a \, \cosh \left ({r \over a} \right ) - a $

      Our curve model needs to provide several functions in order to
      be useful to the raytracer. Fortunately there are base classes
      which provide default implementations for most curve model
      functions. This include differentiation functions and ray
      intersection functions.

      The @ref curve::rotational class allows modeling rotationally
      symmetric curves by only dealing with 2d formulas. Our model
      class just has to inherit from this class and provide an
      implementation for the @tt sagitta function:

      @example examples/curve_model/usercurve.cc:mycurve1 P

      The model can be improved by specifying the derivative
      function. This make calculations more efficient by avoiding use
      of the default numerical differentiation implementation:

      @example examples/curve_model/usercurve.cc:mycurve2

      Although more functions from @ref curve::Base and @ref
      curve::rotational can be reimplemented to further improve model
      efficiency, this curve model can readily be used in an optical design.

    @end section

    @section T {Using the new model in optical design}

      To check our model, we then use it in a simple optical system
      composed of a point source, a mirror and an image plane. The
      catenary mirror resemble a parabolic mirror as used in a newton
      telescope.

      @example examples/curve_model/usercurve.cc:system

      The best point of focus is slightly offset from the parabola focal
      length. We use the @ref analysis::focus class to find the best
      point of focus and move the image plane at this location:

      @example examples/curve_model/usercurve.cc:focus

      @label {tuto_spot2}
      Finally we plot some spot diagrams using the @ref analysis::spot class.
      The point light source is rotated for each diagram:

      @example examples/curve_model/usercurve.cc:spot

      @image catenary_spot.png {spot diagrams with image at best point of focus for the catenary curve}

    @end section

  @end section

@end section
